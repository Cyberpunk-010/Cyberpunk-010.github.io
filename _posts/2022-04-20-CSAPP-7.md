---
title:  "CS:APP Chapter 7 Summary 🔗"
excerpt: "Chatper 7 - Linking"
toc: true
classes: wide

categories:
  - CSAPP

---
Recently, I've been studying CS:APP - I'm posting my own summary of chapter 7 that I wrote up using [Notion](https://cw00h.notion.site/CS-APP-6d3c5c01e6e1456ca51f594a80b5c1f0).
<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Chapter 7 : Linking</title><style>
/* cspell:disable-file */
/* webkit printing magic: print all background colors */

.Notion a,
.Notion a.visited {
	color: inherit;
	text-decoration: underline;
}

.Notion strong {
    font-weight: 600;
}

.Notion .pdf-relative-link-path {
	font-size: 80%;
	color: #444;
}

.Notion h1,
.Notion h2,
.Notion h3 {
	letter-spacing: -0.01em;
	line-height: 1.2;
	font-weight: 600;
	margin-bottom: 0;
    display: flex;
}

.page-title {
	font-size: 2.5rem;
	font-weight: 700;
	margin-top: 0;
	margin-bottom: 0.75em;
}

.Notion h1 {
	font-size: 1.875rem;
	margin-top: 1.875rem;
}

.Notion h2 {
	font-size: 1.5rem;
	margin-top: 1.5rem;
}

.Notion h3 {
	font-size: 1.25rem;
	margin-top: 1.25rem;
}

.source {
	border: 1px solid #ddd;
	border-radius: 3px;
	padding: 1.5em;
	word-break: break-all;
}

.callout {
	border-radius: 3px;
	padding: 1rem;
}

.Notion figure {
	margin: 1.25em 0;
	page-break-inside: avoid;
}

.Notion figcaption {
	opacity: 0.5;
	font-size: 85%;
	margin-top: 0.5em;
}

.Notion mark {
	background-color: transparent;
}

.indented {
	padding-left: 1.5em;
}

.Notion hr {
	background: transparent;
	display: block;
	width: 100%;
	height: 1px;
	visibility: visible;
	border: none;
	border-bottom: 1px solid rgba(55, 53, 47, 0.09);
}

.Notion img {
	max-width: 100%;
}

@media only print {
	.Notion img {
		max-height: 100vh;
		object-fit: contain;
	}
}

@page {
	margin: 1in;
}

.collection-content {
	font-size: 0.875rem;
}

.column-list {
	display: flex;
	justify-content: space-between;
}

.column {
	padding: 0 1em;
}

.column:first-child {
	padding-left: 0;
}

.column:last-child {
	padding-right: 0;
}

.table_of_contents-item {
	display: block;
	font-size: 0.875rem;
	line-height: 1.3;
	padding: 0.125rem;
}

.table_of_contents-indent-1 {
	margin-left: 1.5rem;
}

.table_of_contents-indent-2 {
	margin-left: 3rem;
}

.table_of_contents-indent-3 {
	margin-left: 4.5rem;
}

.table_of_contents-link {
	text-decoration: none;
	opacity: 0.7;
	border-bottom: 1px solid rgba(55, 53, 47, 0.18);
}

.Notion table,
.Notion th,
.Notion td {
	border: 1px solid rgba(55, 53, 47, 0.09);
	border-collapse: collapse;
}

.Notion table {
	border-left: none;
	border-right: none;
}

.Notion th,
.Notion td {
	font-weight: normal;
	padding: 0.25em 0.5em;
	line-height: 1.5;
	min-height: 1.5em;
	text-align: left;
}

.Notion th {
	color: rgba(55, 53, 47, 0.6);
}

.Notion ol,
.Notion ul {
	margin: 0;
	margin-block-start: 0.6em;
	margin-block-end: 0.6em;
}

.Notion li > ol:first-child,
.Notion li > ul:first-child {
	margin-block-start: 0.6em;
}

.Notion ul > li {
	list-style: disc;
}

.Notion ul.to-do-list {
	text-indent: -1.7em;
}

.Notion ul.to-do-list > li {
	list-style: none;
}

.to-do-children-checked {
	text-decoration: line-through;
	opacity: 0.375;
}

.Notion ul.toggle > li {
	list-style: none;
}

.Notion ul {
	padding-inline-start: 1.7em;
}

.Notion ul > li {
	padding-left: 0.1em;
}

.Notion ol {
	padding-inline-start: 1.6em;
}

.Notion ol > li {
	padding-left: 0.2em;
}

.mono ol {
	padding-inline-start: 2em;
}

.mono ol > li {
	text-indent: -0.4em;
}

.toggle {
	padding-inline-start: 0em;
	list-style-type: none;
}

/* Indent toggle children */
.toggle > li > details {
	padding-left: 1.7em;
}

.toggle > li > details > summary {
	margin-left: -1.1em;
}

.selected-value {
	display: inline-block;
	padding: 0 0.5em;
	background: rgba(206, 205, 202, 0.5);
	border-radius: 3px;
	margin-right: 0.5em;
	margin-top: 0.3em;
	margin-bottom: 0.3em;
	white-space: nowrap;
}

.collection-title {
	display: inline-block;
	margin-right: 1em;
}

.simple-table {
	margin-top: 1em;
	font-size: 0.875rem;
	empty-cells: show;
}
.simple-table td {
	height: 29px;
	min-width: 120px;
}

.simple-table th {
	height: 29px;
	min-width: 120px;
}

.simple-table-header-color {
	background: rgb(247, 246, 243);
	color: black;
}
.simple-table-header {
	font-weight: 500;
}

.Notion time {
	opacity: 0.5;
}

.icon {
	display: inline-block;
	max-width: 1.2em;
	max-height: 1.2em;
	text-decoration: none;
	vertical-align: text-bottom;
	margin-right: 0.5em;
}

.Notion img.icon {
	border-radius: 3px;
}

.user-icon {
	width: 1.5em;
	height: 1.5em;
	border-radius: 100%;
	margin-right: 0.5rem;
}

.user-icon-inner {
	font-size: 0.8em;
}

.text-icon {
	border: 1px solid #000;
	text-align: center;
}

.page-cover-image {
	display: block;
	object-fit: cover;
	width: 100%;
	max-height: 30vh;
}

.page-header-icon {
	font-size: 3rem;
	margin-bottom: 1rem;
}

.page-header-icon-with-cover {
	margin-top: -0.72em;
	margin-left: 0.07em;
}

.page-header-icon img {
	border-radius: 3px;
}

.link-to-page {
	margin: 1em 0;
	padding: 0;
	border: none;
	font-weight: 500;
}

.Notion p > .user {
	opacity: 0.5;
}

.Notion td > .user,
.Notion td > time {
	white-space: nowrap;
}

input[type="checkbox"] {
	transform: scale(1.5);
	margin-right: 0.6em;
	vertical-align: middle;
}

.Notion p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
}

.image {
	border: none;
	margin: 1.5em 0;
	padding: 0;
	border-radius: 0;
	text-align: center;
}

.code,
.Notion code {
	background: rgba(135, 131, 120, 0.15);
	border-radius: 3px;
	padding: 0.2em 0.4em;
	border-radius: 3px;
	font-size: 85%;
	tab-size: 2;
}

.Notion code {
	color: #eb5757;
}

.code {
	padding: 1.5em 1em;
}

.code-wrap {
	white-space: pre-wrap;
	word-break: break-all;
}

.code > code {
	background: none;
	padding: 0;
	font-size: 100%;
	color: inherit;
}

.Notion blockquote {
	font-size: 1.25em;
	margin: 1em 0;
	padding-left: 1em;
	border-left: 3px solid rgb(55, 53, 47);
}

.bookmark {
	text-decoration: none;
	max-height: 8em;
	padding: 0;
	display: flex;
	width: 100%;
	align-items: stretch;
}

.bookmark-title {
	font-size: 0.85em;
	overflow: hidden;
	text-overflow: ellipsis;
	height: 1.75em;
	white-space: nowrap;
}

.bookmark-text {
	display: flex;
	flex-direction: column;
}

.bookmark-info {
	flex: 4 1 180px;
	padding: 12px 14px 14px;
	display: flex;
	flex-direction: column;
	justify-content: space-between;
}

.bookmark-image {
	width: 33%;
	flex: 1 1 180px;
	display: block;
	position: relative;
	object-fit: cover;
	border-radius: 1px;
}

.bookmark-description {
	color: rgba(55, 53, 47, 0.6);
	font-size: 0.75em;
	overflow: hidden;
	max-height: 4.5em;
	word-break: break-word;
}

.bookmark-href {
	font-size: 0.75em;
	margin-top: 0.25em;
}

.sans { font-family: ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
.code { font-family: "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace; }
.serif { font-family: Lyon-Text, Georgia, ui-serif, serif; }
.mono { font-family: iawriter-mono, Nitti, Menlo, Courier, monospace; }
.pdf .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK JP'; }
.pdf:lang(zh-CN) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC'; }
.pdf:lang(zh-TW) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK TC'; }
.pdf:lang(ko-KR) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK KR'; }
.pdf .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK JP'; }
.pdf:lang(zh-CN) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK SC'; }
.pdf:lang(zh-TW) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK TC'; }
.pdf:lang(ko-KR) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK KR'; }
.pdf .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.highlight-default {
	color: rgba(55, 53, 47, 1);
}
.highlight-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.highlight-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.highlight-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.highlight-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.highlight-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.highlight-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.highlight-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.highlight-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.highlight-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.highlight-gray_background {
	background: rgba(241, 241, 239, 1);
}
.highlight-brown_background {
	background: rgba(244, 238, 238, 1);
}
.highlight-orange_background {
	background: rgba(251, 236, 221, 1);
}
.highlight-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.highlight-teal_background {
	background: rgba(237, 243, 236, 1);
}
.highlight-blue_background {
	background: rgba(231, 243, 248, 1);
}
.highlight-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.highlight-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.highlight-red_background {
	background: rgba(253, 235, 236, 1);
}
.block-color-default {
	color: inherit;
	fill: inherit;
}
.block-color-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.block-color-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.block-color-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.block-color-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.block-color-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.block-color-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.block-color-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.block-color-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.block-color-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.block-color-gray_background {
	background: rgba(241, 241, 239, 1);
}
.block-color-brown_background {
	background: rgba(244, 238, 238, 1);
}
.block-color-orange_background {
	background: rgba(251, 236, 221, 1);
}
.block-color-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.block-color-teal_background {
	background: rgba(237, 243, 236, 1);
}
.block-color-blue_background {
	background: rgba(231, 243, 248, 1);
}
.block-color-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.block-color-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.block-color-red_background {
	background: rgba(253, 235, 236, 1);
}
.select-value-color-pink { background-color: rgba(245, 224, 233, 1); }
.select-value-color-purple { background-color: rgba(232, 222, 238, 1); }
.select-value-color-green { background-color: rgba(219, 237, 219, 1); }
.select-value-color-gray { background-color: rgba(227, 226, 224, 1); }
.select-value-color-opaquegray { background-color: rgba(255, 255, 255, 0.0375); }
.select-value-color-orange { background-color: rgba(250, 222, 201, 1); }
.select-value-color-brown { background-color: rgba(238, 224, 218, 1); }
.select-value-color-red { background-color: rgba(255, 226, 221, 1); }
.select-value-color-yellow { background-color: rgba(253, 236, 200, 1); }
.select-value-color-blue { background-color: rgba(211, 229, 239, 1); }

.checkbox {
	display: inline-flex;
	vertical-align: text-bottom;
	width: 16;
	height: 16;
	background-size: 16px;
	margin-left: 2px;
	margin-right: 5px;
}

.checkbox-on {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
}

.checkbox-off {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
}
	
</style></head><body><article id="1a783ffd-808e-41da-aa52-0d1ae5e3bd5a" class="page sans Notion" style="width: 100%; padding: 0px;"><div class="page-body"><h2 id="d7147b10-b896-4790-b6f9-7db7ea784344" class=""><details open=""><summary><mark class="highlight-blue">7.1</mark> Compiler Drivers</summary></details></h2><div class="indented"><p id="7d810814-0566-4e83-8010-847ecca26a8a" class="">Most compilation systems provide a <strong>compiler driver</strong> that invokes the language <strong>preprocessor</strong>, <strong>compiler</strong>, <strong>assembler</strong>, and <strong>linker</strong>.</p><p id="df36e01b-dca0-4d8f-b6f6-ca61c5a4f776" class="">Example :</p><pre id="afd57c3e-d770-44a6-9911-e5813e64a096" class="code"><code>/* main.c */
int sum(int *a, int n);

int array[2] = {1, 2};

int main(){
	int val = sum(array, 2);
	return val;
}

/* sum.c */
int sum(int *a, int n){
	int i, s = 0;
	for(i = 0; i &lt; n; i++){
		s += a[i];
	}
	return s;
}</code></pre><p id="61dd3096-5819-41ea-9fa6-d75b54eac0e2" class="">To build example program above using the GNU compilation system, invoke the <strong>GCC driver</strong> by typing the following command : <code>linux&gt; gcc -0g -o prog main.c sum.c</code></p><figure id="5cb404a2-6598-447b-8a88-d8986b4e4cc2" class="image"><a href="/assets/images/CSAPP-7/Untitled.png"><img style="width:288px" src="/assets/images/CSAPP-7/Untitled.png"/></a></figure><p id="151f7aa4-0c90-49af-822d-570d5e3a7778" class="">Then, the driver follows next steps :</p><ol type="1" id="7e9f9344-66f7-40a6-86ce-57bf9ebcca59" class="numbered-list" start="1"><li>Run <strong>C preprocessor</strong> <code>cpp</code> - translates the C source file <code>main.c</code> into an <strong>ASCII intermediate file</strong> <code>main.i</code> : <code>cpp [other arguments] main.c /tmp/main.i</code></li></ol><ol type="1" id="460862a1-57ce-412c-a607-1b0cb69d752f" class="numbered-list" start="2"><li>Run <strong>C compiler</strong> <code>cc1</code> - translates <code>main.i</code> into an <strong>ASCII assembly-language file</strong> <code>main.s</code> : <code>cc1 /tmp/main.i -0g [other arguments] -o /tmp/main.s</code></li></ol><ol type="1" id="689bed55-bee9-4cdf-99cf-1904c4052f87" class="numbered-list" start="3"><li>Run <strong>assembler </strong><code>as</code> - translates <code>main.s</code> into a <strong>binary relocatable object file</strong> <code>main.o</code> : <code>as [other arguments] -o /tmp/main.o /tmp/main.s</code></li></ol><ol type="1" id="f7e7884b-3287-4be7-bc32-56e04262e889" class="numbered-list" start="4"><li>Go through the same process to generate <code>sum.o</code>.</li></ol><ol type="1" id="b82da27f-adf0-470c-85be-15826587ff4d" class="numbered-list" start="5"><li>Run <strong>linker program</strong> <code>ld</code> - <strong>combines </strong><code>main.o</code>, <code>sum.o</code>, and necessary system object files to create the <strong>binary executable object file</strong> <code>prog</code> : <code>ld -o prog [system object files and args] /tmp/main.o /tmp/sum.o</code></li></ol><p id="df5fb198-89b8-487e-9ff9-0aec9ff60b54" class="">To run the executable <code>prog</code>, type its name on shell’s command : <code>linux&gt; ./prog</code>. Then, the shell invokes a function in OS called the <strong>loader </strong>- copies the code and data<strong> </strong>in <code>prog</code> <strong>into memory</strong>, and then <strong>transfers control</strong> to the beginning of the program.</p></div><h2 id="31fb7eaf-e152-4886-bebd-d8a8d9a638ea" class=""><details open=""><summary><mark class="highlight-blue">7.2</mark> Static Linking</summary></details></h2><div class="indented"><ul id="af2656a2-83e3-42e3-b942-9d93ef28a2a8" class="bulleted-list"><li style="list-style-type:disc">Static linker’s <strong>input </strong>: <strong>relocatable object files</strong> &amp; command-line arguments<p id="ed2c7324-7ac4-415e-9b21-20f3fc8a6e85" class=""><strong>Relocatable object files</strong> consist of various code and data <strong>sections </strong>- each section is a contiguous sequence of bytes. <strong>Instructions</strong>, <strong>initialized global variables</strong>, and <strong>uninitialized variables</strong> are in different section respectively. </p></li></ul><ul id="8439e39a-989a-4da1-8895-82c58ace8626" class="bulleted-list"><li style="list-style-type:disc">Static linker’s <strong>output </strong>: fully linked executable object file.</li></ul><ul id="e7beacc7-e409-436f-9910-8445d9714334" class="bulleted-list"><li style="list-style-type:disc">Linker’s two main tasks<ul id="2ee2ae7d-1388-4557-8603-2855d66d7499" class="bulleted-list"><li style="list-style-type:circle"><strong>Symbol resolution</strong> </li></ul><p id="e2366e33-4167-4127-926c-653c773d15b2" class="">Object files define and reference <strong>symbols</strong>, where each symbol corresponds to a function, a global var, or a static var. The linker <strong>associates each symbol reference with a symbol definition</strong>.</p><ul id="447a481b-7075-4f44-b57a-3e4b705146f6" class="bulleted-list"><li style="list-style-type:circle"><strong>Relocation</strong></li></ul><p id="183be785-d84d-4a5e-8f17-bdc079ce3f84" class=""><strong>Compilers &amp; assemblers</strong> generate code and data sections that <strong>start at address 0</strong>. The linker relocates sections by <strong>associating a memory location with each symbol definition</strong>, and <strong>modifying all references to point to this memory location</strong>. The linker <strong>blindly </strong>performs these relocations using <strong>relocation entries</strong>, which is detailed instructions generated by the assembler.</p></li></ul><ul id="b7053b77-5df4-42f6-a92f-1e3b071cbf03" class="bulleted-list"><li style="list-style-type:disc">Linkers have <strong>minimal understanding of the target machine</strong> - The compilers &amp; assemblers have already done most of the work.</li></ul></div><h2 id="209a190f-d1b7-4c8f-b7d6-3b3c9dd98891" class=""><details open=""><summary><mark class="highlight-blue">7.3</mark> Object Files</summary></details></h2><div class="indented"><p id="555dad8f-405b-4c2d-93fc-81a78e9f65a8" class=""><strong>Object files</strong> come in three forms :</p><ol type="1" id="924e38d2-8b3c-460c-9ed7-9ad12ce6fa8d" class="numbered-list" start="1"><li><strong>Relocatable object file</strong> : Contains binary code &amp; data in a form that can be <strong>combined with other relocatable object files at compile time</strong> to create an executable object file.</li></ol><ol type="1" id="05d3d251-2c44-4693-9a51-21eaf88bb27a" class="numbered-list" start="2"><li><strong>Executable object file</strong> : Contains binary code &amp; data in a form that can be <strong>copied directly into memory and executed</strong>.</li></ol><ol type="1" id="c5fcedac-e9fa-4812-ad40-06dd362a3a99" class="numbered-list" start="3"><li><strong>Shared object file</strong> : A special type of relocatable object file that can be loaded into memory and <strong>linked dynamically, at either load time or run time</strong>.</li></ol><p id="c818d5ad-ccaa-4864-af35-4bca2f4cd6af" class=""><strong>Compilers &amp; assemblers</strong> generate <strong>relocatable object files</strong> or <strong>shared object file</strong>, while <strong>linkers </strong>generate <strong>executable object files</strong>.</p><p id="81e5d131-f3ba-448e-8b47-e64fabe3366d" class="">Object files are organized according to specific <strong>object file formats</strong>, which vary from system to system.</p></div><h2 id="406586d8-2224-4f3e-a5e7-511b9d4a917a" class=""><details open=""><summary><mark class="highlight-blue">7.4</mark> Relocatable Object Files</summary></details></h2><div class="indented"><figure id="1c6a7caa-92d0-451e-a005-27d6b3965610" class="image"><a href="/assets/images/CSAPP-7/Untitled%201.png"><img style="width:288px" src="/assets/images/CSAPP-7/Untitled%201.png"/></a></figure><p id="0b390bfb-e478-4535-8aa9-2f2638fe2f2e" class="">Format of a typical <strong>ELF relocatable object files</strong></p><ul id="2e021ad9-b811-46a5-9e35-83bed9487376" class="bulleted-list"><li style="list-style-type:disc"><strong>ELF header</strong><ul id="1689ca19-e658-4d3d-b2ab-8943a293d08a" class="bulleted-list"><li style="list-style-type:circle">describes <strong>word size</strong> and <strong>byte ordering</strong> of the system</li></ul><ul id="de87710d-1091-4e4b-bde6-0afc416311c4" class="bulleted-list"><li style="list-style-type:circle">contains information for <strong>parsing and interpreting the object file</strong> :<ul id="af40391e-aed7-4a2f-bb5a-e69cbae7c257" class="bulleted-list"><li style="list-style-type:square">the size of ELF header</li></ul><ul id="18efcfd6-91c2-4ba7-a8ec-302ce951184d" class="bulleted-list"><li style="list-style-type:square">the object file type (<em>example : relocatable, executable, or shared</em>)</li></ul><ul id="726bb556-291b-429e-9178-c31be706f510" class="bulleted-list"><li style="list-style-type:square">the machine type (<em>example : x86-64</em>)</li></ul><ul id="ce07d405-0dfd-4e81-a112-a2ade08c9a44" class="bulleted-list"><li style="list-style-type:square">the file offset of the section header table</li></ul><ul id="f2abb5dd-3c9d-4fe6-941c-1f59142b40db" class="bulleted-list"><li style="list-style-type:square">the size and number of entries in the section header table</li></ul></li></ul></li></ul><ul id="35b27efd-7b15-4608-9fbf-1b1a44c04b71" class="bulleted-list"><li style="list-style-type:disc"><strong>Section header table</strong><ul id="10f0198e-d85c-4a78-9bbd-5b8ea17932a2" class="bulleted-list"><li style="list-style-type:circle">describes the <strong>locations and sizes</strong> of the various <strong>sections</strong></li></ul><ul id="0d65eacc-a75e-4101-bfde-28926580c11f" class="bulleted-list"><li style="list-style-type:circle">contains a fixed-size entry for each section in the object file</li></ul></li></ul><ul id="6e594fdb-20d0-42de-80fc-52300d2f4acf" class="bulleted-list"><li style="list-style-type:disc"><strong><code>.text</code></strong> : The <strong>machine code</strong> of the compiled program</li></ul><ul id="487da01c-e80a-4241-bad9-a7fb3182a374" class="bulleted-list"><li style="list-style-type:disc"><strong><code>.rodata</code></strong> : <strong>Read-only data</strong> (<em>example : format strings in </em><code><em>printf</em></code><em> statements, and jump tables for switch statements</em>)</li></ul><ul id="50a2eb37-6390-4f09-a640-802ae2084645" class="bulleted-list"><li style="list-style-type:disc"><strong><code>.data</code></strong> : <strong>Initialized global and static C variables</strong></li></ul><ul id="8a3e7abd-0fba-40e0-b23d-c7a54422ccd5" class="bulleted-list"><li style="list-style-type:disc"><strong><code>.bss</code></strong> : <strong>Uninitialized global and static C variables</strong>, and any <strong>global or static</strong> variables that are <strong>initialized into 0</strong>.<ul id="c091e4ef-236f-44cb-b467-69e061dfd891" class="bulleted-list"><li style="list-style-type:circle">This section occupies <strong>no actual space</strong> in the object file.</li></ul><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="c51f7c4f-6374-41ce-b3fe-d6552cb3a4d7"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%">Object file formats distinguish between initialized and uninitialized variables for <strong>space efficiency</strong> : uninitialized variables don’t have to occupy any disk space in the object file. <strong>At run time, these variables are allocated in memory with an initial value of zero</strong>.</div></figure><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="a1bd0754-c385-4dec-895f-2c3d2384c574"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%"><strong>Local C variables</strong> are maintained at run time on the <strong>stack</strong>, and don’t appear in either the <code>.data</code> or <code>.bss</code> sections.</div></figure></li></ul><ul id="b5338b7c-536b-4454-a799-7dddbf42283e" class="bulleted-list"><li style="list-style-type:disc"><strong><code>.symtab</code></strong> : A <strong>symbol table</strong> with information about <strong>functions </strong>and <strong>global variables</strong>.<ul id="7db8faac-a97a-410a-b180-e363db96b85a" class="bulleted-list"><li style="list-style-type:circle">doesn’t contain entries for <strong>local variables</strong>.</li></ul></li></ul><ul id="270b8243-3c3f-47c8-887c-a6d929a8da57" class="bulleted-list"><li style="list-style-type:disc"><strong><code>.rel.text</code></strong> : A list of <strong>locations in the </strong><strong><code>.text</code></strong><strong> section</strong> that will <strong>need to be modified</strong> when the linker combines this object file with others.<ul id="fbbfb26e-018a-484e-aa93-cca363bcd51d" class="bulleted-list"><li style="list-style-type:circle">example : <strong>instruction </strong>that calls an <strong>external function</strong> or <strong>references a global variable</strong></li></ul><ul id="dee7ac95-4077-4830-9b1b-9f6f8a0b31af" class="bulleted-list"><li style="list-style-type:circle">instructions that call local functions don’t need to be modified.</li></ul><ul id="2386c15b-d0b7-45d9-8ee1-1efdaec8da21" class="bulleted-list"><li style="list-style-type:circle">Relocation information is not needed in executable object files → <strong>usually omitted in executable object files</strong></li></ul></li></ul><ul id="ec2f7535-c79e-4d59-ad40-3cf85b2e4d2c" class="bulleted-list"><li style="list-style-type:disc"><strong><code>.rel.data</code></strong> : <strong>Relocation information for global variables</strong>. (<em>example : any initialized global variable whose initial value is the address of a global variable, or externally defined function</em>)</li></ul><ul id="cf4acf1d-9425-4836-98b3-45fd7a909b46" class="bulleted-list"><li style="list-style-type:disc"><strong><code>.debug</code></strong> : A <strong>debugging symbol table</strong>. Only present if the compiler driver is invoked with the <code>-g</code> option.</li></ul><ul id="e5276682-b849-43fe-b093-dfd6c09b314b" class="bulleted-list"><li style="list-style-type:disc"><strong><code>.line</code></strong> : A <strong>mapping </strong>between <strong>line numbers</strong> in the original C source program and <strong>machine code instructions</strong> in the <code>.text</code> section. Only present if the compiler driver is invoked with the <code>-g</code> option.</li></ul><ul id="929bdde4-3470-450b-a062-43427f95bf40" class="bulleted-list"><li style="list-style-type:disc"><strong><code>.strtab</code></strong> : A <strong>string table</strong> for the <strong>symbol tables</strong> in the <code>.symtab</code> and <code>.debug</code> sections and for the <strong>section names</strong> in the section headers. A sequence of null-terminated character strings.</li></ul></div><h2 id="d4547eef-53c7-4414-9fc5-023de70040d8" class=""><details open=""><summary><mark class="highlight-blue">7.5</mark> Symbols and Symbol Tables</summary></details></h2><div class="indented"><p id="55d1279f-fd7e-4fef-af2f-c423a0573cc0" class="">Each <strong>relocatable object module</strong>, <strong><em>m</em></strong>, has a <strong>symbol table </strong>that contains information about the symbols that are defined &amp; referenced by <em>m</em>. </p><ul id="a3c4e67c-c4db-4973-8d24-b35e125b41b3" class="toggle"><li><details open=""><summary><strong>Global Symbols, Externals, and Local Symbols</strong></summary><p id="9dcaea17-14d1-4290-8e12-496ad556c94b" class="">There are 3 different kinds of symbols :</p><ul id="021194fb-7bf8-477e-801c-04e3075a3c52" class="bulleted-list"><li style="list-style-type:disc"><strong>Global symbols</strong> : <strong>defined by </strong><strong><em>m</em></strong> and can be <strong>referenced by other modules</strong>. → nonstatic C functions and global variables</li></ul><ul id="f6145eb5-e3f7-483a-8531-031853762170" class="bulleted-list"><li style="list-style-type:disc"><strong>Externals </strong>: referenced by <em>m</em> but <strong>defined by some other modules</strong>. → nonstatic C functions and global variables that are <strong>defined in other modules</strong>.</li></ul><ul id="ad0255f4-6c3f-413f-8295-b6a442a51916" class="bulleted-list"><li style="list-style-type:disc"><strong>Local symbols</strong> : <strong>defined &amp; referenced exclusively by </strong><strong><em>m</em></strong>. → static C functions and global variables that are <strong>defined with </strong><strong><code>static</code></strong><strong> attribute</strong>.</li></ul><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="59c59cc0-8976-4aa4-8b4d-3c2490ea5e03"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%"><strong>Local linker symbols ≠ Local program variables</strong> : The symbol table doesn’t contain any symbols that correspond to <strong>local </strong>nonstatic program variables. These are managed at run time on <strong>stack</strong>.</div></figure><p id="2161eeaa-9e23-46de-860f-031161870177" class=""><strong>Local procedure variables</strong> that are defined with <strong><code>static</code></strong><strong> attribute</strong> are <strong>not </strong>managed on the <strong>stack </strong>- The compiler allocates <strong>space in </strong><strong><code>.data</code></strong><strong> or </strong><strong><code>.bss</code></strong> for each definition and <strong>creates a local linker symbol</strong> in the symbol table <strong>with a unique name</strong>. </p><pre id="20591f39-2a6f-465e-a534-7dfe3cd57d9e" class="code"><code>int f(){
	static int x = 0;
	return x;
}

int g(){
	static int x = 1;
	return x;
}</code></pre><p id="4af05d6c-2a3f-4482-b2e1-2a33d8a7757e" class="">⇒ The compiler exports a pair of local linker symbols with <strong>different </strong>names to the assembler. (<em>example : </em><code><em>x.1</em></code><em><em> for the definition in </em></em><code><em><em>f</em></em></code><em><em>, and </em></em><code><em><em>x.2</em></em></code><em><em> for the definition in </em></em><code><em><em>g</em></em></code><em><em>.</em></em>)</p></details></li></ul><ul id="9bc81af9-ed92-4cba-bd28-06408d668b22" class="toggle"><li><details open=""><summary><strong>ELF Symbol Table Entry</strong></summary><p id="c7998f84-4a19-406a-9aca-b34c29565b9b" class="">Symbol tables are built by <strong>assemblers</strong>, using <strong>symbols </strong>exported by the compiler into to <strong>assembly-language </strong><strong><code>.s</code></strong><strong> file</strong>. </p><p id="5c493dc2-a259-4667-b66d-3b0585cd8b46" class="">The format of <strong>ELF symbol table entry</strong> :</p><pre id="6f77bb66-e0bc-4bc1-845e-03a6b0d761b4" class="code"><code>typedef struct{
	int name;       /* String table offset */
	char type:4,    /* Function or data (4 bits) */
			 binding:4; /* Local or global (4 bits) */
	char reserved;  /* Unused */
	short section;  /* Section header index */
	long value;     /* Section offset or absolute address */
	long size;      /* Object size in bytes */
} Elf64_Symbol;</code></pre><ul id="28a02d2a-eb58-4a72-b77b-6ccc5c918498" class="bulleted-list"><li style="list-style-type:disc"><code>name</code> : a <strong>byte offset</strong> into the <strong>string table</strong> that points to the null-terminated string <strong>name of the symbol</strong>.</li></ul><ul id="e7426f85-b315-4705-bf48-8d0ac11fc4b9" class="bulleted-list"><li style="list-style-type:disc"><code>type</code> : data or function</li></ul><ul id="90624625-7275-42a7-884b-c2d95b00bb87" class="bulleted-list"><li style="list-style-type:disc"><code>binding</code> : indicates whether the symbol is local or global</li></ul><ul id="1c38cd0f-941b-43c2-b162-066f481de135" class="bulleted-list"><li style="list-style-type:disc"><code>section</code> : an index into <strong>the section header table</strong> that indicates which section the symbol is assigned to</li></ul><ul id="7583c736-1853-4062-a4e5-3f6fec9b3060" class="bulleted-list"><li style="list-style-type:disc"><code>value</code> : the symbol’s address - an <strong>offset from the beginning of the section</strong> where the object is defined for <strong>relocatable modules</strong>, and an <strong>absolute run-time address</strong> for <strong>executable object files</strong>.</li></ul><ul id="188af645-868e-46be-a438-5cd7e21ed701" class="bulleted-list"><li style="list-style-type:disc"><code>size</code> : the size of the object in bytes</li></ul></details></li></ul><ul id="b19acfdb-8a31-430b-ab4c-dd08c2919ee6" class="toggle"><li><details open=""><summary><strong>Pseudosections </strong></summary><p id="ac77b2f5-bbfa-433b-b75f-75b98239d966" class="">There are 3 special <strong>pseudosections </strong>that exist <strong>only in relocatable object files</strong>, and don’t have entries in the section header table :</p><ul id="219ddb83-2d56-4a1f-bd23-dd77da010f38" class="bulleted-list"><li style="list-style-type:disc"><strong>ABS </strong>: for symbols that should not be relocated</li></ul><ul id="d1e2689b-ad0b-4f13-8acf-f605650353f6" class="bulleted-list"><li style="list-style-type:disc"><strong>UNDEF </strong>: for undefined symbols - symbols that are <strong>referenced in this object module but defined elsewhere</strong></li></ul><ul id="1ac82051-24e2-4445-809c-f3166ae08834" class="bulleted-list"><li style="list-style-type:disc"><strong>COMMON </strong>: for uninitialized data objects that are not yet allocated<ul id="376a5ce7-2219-4de3-abf4-f69593fbe512" class="bulleted-list"><li style="list-style-type:circle">For COMMON symbols, the <strong><code>value</code></strong><strong> field</strong> gives the <strong>alignment requirement</strong>, and <strong><code>size</code></strong><strong> </strong>gives the <strong>minimum size</strong>.</li></ul><ul id="b10ec261-a38f-4f16-9bbe-af7ff448da67" class="bulleted-list"><li style="list-style-type:circle"><strong>COMMON vs. </strong><strong><code>.bss</code></strong><strong> → </strong>explained in Section <strong><mark class="highlight-blue">7.6</mark></strong><ul id="87df0f0b-f091-4979-8045-222af0a4eaae" class="bulleted-list"><li style="list-style-type:square"><strong>COMMON </strong>: <strong>Uninitialized global variables</strong></li></ul><ul id="71d6f898-360b-4976-9874-1640157943bd" class="bulleted-list"><li style="list-style-type:square"><code>.bss</code> : Uninitialized static variables, &amp; global or static variables that are initialized to zero</li></ul></li></ul></li></ul></details></li></ul></div><h2 id="fe76b6c1-713c-4fff-a754-53608a7a51d3" class=""><details open=""><summary><mark class="highlight-blue">7.6</mark> Symbol Resolution</summary></details></h2><div class="indented"><ul id="ed6eea0c-e8e7-4db7-9dbd-b7e2d8bcd06f" class="toggle"><li><details open=""><summary><strong>Symbol Resolution for Local Symbols</strong></summary><p id="3d1ad58a-a60b-492c-bffd-209d0076b9a0" class=""><strong>Symbol resolution</strong> for <strong>local symbols</strong> is <strong>straightforward </strong>- the compiler allows <strong>only one definition</strong> of each local symbol per module, and ensures that static local variables have <strong>unique names</strong>.</p></details></li></ul><ul id="c26a5948-42fc-47a3-ad76-3caf1605e8b5" class="toggle"><li><details open=""><summary><strong>Symbol Resolution for Global Symbols</strong></summary><ul id="c1954564-3a35-428d-888e-83ee5c6aeaf1" class="bulleted-list"><li style="list-style-type:disc"><strong>Undefined Global Symbol</strong></li></ul><p id="7bd5134f-3e6e-4acb-9552-3eebd632e5ad" class="">When the <strong>compiler </strong>encounters a symbol that is <strong>not defined in current module</strong>, it generates a <strong>linker symbol table entry</strong> assuming it is defined in some other module, and leaves it for the linker to handle. → If the <strong>linker can’t find a definition </strong>in any of its input modules, it prints an <strong>error </strong>message and terminates.</p><ul id="05e4c3b9-4e94-41cb-883e-fd052011f5f9" class="bulleted-list"><li style="list-style-type:disc"><strong>Resolving Duplicate Symbol Names</strong></li></ul><p id="201badc3-21e2-4926-b483-093255a0d977" class="">Multiple object modules might define global symbols with the <strong>same name</strong>. Linux compilation system solve duplicate symbol names as below :</p><ol type="1" id="2c92cccb-b10a-4eee-af95-da16ff6bd686" class="numbered-list" start="1"><li>At compile time, <strong>the compiler</strong> exports each global symbol to the assembler as either <strong>strong </strong>or <strong>weak</strong>.<ul id="99483ed7-b776-48f4-9b28-f2979c15da3e" class="bulleted-list"><li style="list-style-type:disc"><strong>Strong symbol</strong> : <strong>Functions &amp; initialized global variables</strong></li></ul><ul id="f2708731-5f0c-4222-8fa6-bebb9d4ae7ab" class="bulleted-list"><li style="list-style-type:disc"><strong>Weak symbol</strong> : <strong>Uninitialized global variables</strong></li></ul></li></ol><ol type="1" id="c33e939d-5143-4b11-848c-a16c67add516" class="numbered-list" start="2"><li><strong>The assembler</strong> encodes this information implicitly <strong>in the symbol table</strong> of the relocatable object file.</li></ol><ol type="1" id="4bb32cf6-8a9c-4c17-8917-2793e4892e6a" class="numbered-list" start="3"><li>Given this notion of strong and weak symbols, <strong>Linux linkers</strong> use the following rules for dealing with duplicate symbol names :<p id="308a8e04-a21b-4d3a-854c-e40dd1e41fc3" class="">Rule 1. <strong>Multiple strong symbols</strong> with the same name are <strong>not allowed</strong>.</p><p id="68519dc1-d431-4b10-945d-21dea6ebc7de" class="">Rule 2. Given <strong>a strong symbol</strong> <strong>&amp; multiple weak symbols</strong> with the same name, <strong>choose the strong symbol</strong>.</p><p id="2aeccd36-7190-4062-bcf3-1a0cc401bccc" class="">Rule 3. Given <strong>multiple weak symbols</strong> with the same name, <strong>choose any of the weak symbols</strong>.</p></li></ol><ul id="e39f438c-65da-4209-aa5a-c2e56494acc2" class="bulleted-list"><li style="list-style-type:disc"><strong>Example Code</strong> - Duplicate Symbol Definitions Having<strong> Different Types</strong><pre id="a70e8ba5-8e7e-4f72-9843-9aba60bb9c24" class="code"><code>/* foo5.c */
#include &lt;stdio.h&gt;
void f(void);

int y = 15212;
int x = 15213; //strong symbol

int main(){
	f();
	printf(&quot;x = 0x%x y = 0x%x \n&quot;, x, y);
	return 0;
}

/* bar5.c */
double x; //weak symbol

void f(){
	x = -0.0;
}</code></pre><p id="fcee06c7-3b4c-482d-9592-b7a5625459b3" class="">The linker will <strong>choose the strong symbol</strong> according to <strong>rule 2</strong>. → Since <code>double</code> is 8 bytes and <code>int</code> is 4 bytes, the address of <code>x</code> is <code>0x601020</code>, and the address of <code>y</code> is <code>0x601024</code> → <strong>The assignment </strong><strong><code>x = -0.0</code></strong><strong> in </strong><strong><code>bar5.c</code></strong><strong> will overwrite the memory locations for </strong><strong><code>x</code></strong><strong> and </strong><strong><code>y</code></strong><strong>.</strong> ⇒ The output is <code>x = 0x0 y = 0x80000000</code>.</p></li></ul><ul id="2220accc-761e-4f96-a32f-e4ad7c7185d8" class="bulleted-list"><li style="list-style-type:disc"> <strong>COMMON vs. </strong><strong><code>.bss</code></strong><p id="0eae19a4-d862-4ad1-b0e4-b70a1b7067ff" class="">The compiler uses a seemingly arbitrary convention to assign symbols to <strong>COMMON and </strong><strong><code>.bss</code></strong> - This is because the linker allows multiple modules to <strong>define global symbols with the same name</strong> in some cases.</p><p id="7cecc321-7120-48ba-9e43-8eb0db6820ed" class="">When the compiler encounters a <strong>weak global symbol</strong>, <code>x</code>, it doesn’t know if other modules also define <code>x</code> → It can’t predict which of the multiple instances of <code>x</code> the linker might choose. → The compiler <strong>defers the decision to the linker</strong> by assigning <code>x</code> to <strong>COMMON</strong>.</p><p id="bfb59822-8ae9-4b30-bc58-fb183128c8c1" class="">On the other hand, if <code>x</code> is <strong>initialized to zero</strong>, then it’s <strong>strong symbol </strong>→ <code>x</code> must be <strong>unique </strong>by rule 2 → The compiler can confidently assign it to <strong><code>.bss</code></strong>. </p><p id="e71540c8-a456-4c1f-b51b-8f4a6bf4efb8" class="">Similarly, <strong>static symbols</strong> are <strong>unique </strong>by construction → The compiler can confidently assign them to either <strong><code>.data</code></strong><strong> or </strong><strong><code>.bss</code></strong>.</p><p id="8b0b97d7-d830-4692-b92f-aed841bd8c1e" class="">
</p></li></ul></details></li></ul><ul id="dfd09209-38ae-46be-8314-0f3a3744693a" class="toggle"><li><details open=""><summary><strong>Linking with Static Libraries</strong></summary><ul id="9bd82f72-0bfa-4a1a-8437-3df9f9458617" class="bulleted-list"><li style="list-style-type:disc"><strong>Static Library </strong><p id="3f7c6f42-0c6b-4122-9995-8d69574278ee" class=""><strong>Static library</strong> is a single file which is <strong>a package of related object modules</strong>. Static libraries can be supplied as <strong>input </strong>to <strong>the linker</strong> -  When the linker builds the output executable, it copies <strong>only the object modules that are referenced</strong> by the application program.</p></li></ul><ul id="afbb5b04-ed29-444c-ac5f-2ff1fd8b1283" class="bulleted-list"><li style="list-style-type:disc">Why use <strong>libraries</strong>?<p id="caf0c30a-4096-42c0-8bd8-400c93aa3e73" class="">To understand why do systems support the notion of the libraries, let’s consider the different approaches that compiler developers might use to provide functions to users.</p><ul id="604a0a53-2112-40bc-adbd-b79c7533fb31" class="bulleted-list"><li style="list-style-type:circle">Having the compiler recognize calls to the standard functions<ul id="2215833e-255a-4c2d-a44a-4369b95a9937" class="bulleted-list"><li style="list-style-type:square">Convenient to application programmers 👍</li></ul><ul id="1b2e3ad4-77b7-47c0-a746-0ef49f1756a0" class="bulleted-list"><li style="list-style-type:square">Add significant complexity to the compiler 👎</li></ul><ul id="1591149a-3db1-4c28-a9ac-1aceaac41e99" class="bulleted-list"><li style="list-style-type:square">Would require a new compiler version each time functions were modified 👎</li></ul></li></ul><ul id="71401e92-e7d3-4023-84dc-cfda2b073fdc" class="bulleted-list"><li style="list-style-type:circle">Putting all of the standard C functions in a single relocatable object module<ul id="b0aafcdb-bc60-40aa-b3d0-2717af16da8a" class="bulleted-list"><li style="list-style-type:square">Would decouple the implementation of the standard functions from the implementation of the compiler 👍</li></ul><ul id="eea4c3e5-c6ee-4fa7-9ac6-f53fbeded882" class="bulleted-list"><li style="list-style-type:square">Convenient to application programmers 👍</li></ul><ul id="8f74f424-cd1d-482e-9da4-bcf0aa769913" class="bulleted-list"><li style="list-style-type:square">Every executable file would contain a complete copy of the collection of standard functions → Extremely wasteful of disk space 👎</li></ul><ul id="c3dcc99f-ca8b-4a5e-b80a-35c0fe62c263" class="bulleted-list"><li style="list-style-type:square">Each running program would contain a copy of the functions in memory → Extremely wasteful of memory 👎</li></ul><ul id="48fa9a4a-4fd1-43f1-b6cc-b6a995f65180" class="bulleted-list"><li style="list-style-type:square">Any change to any standard function would require the re-compilation of the entire source file 👎</li></ul></li></ul><ul id="d5810839-b1a0-4760-abb5-b1482bfadffd" class="bulleted-list"><li style="list-style-type:circle">Creating a separate relocatable file for each standard function<ul id="6e88c871-0402-466b-995b-45087c455449" class="bulleted-list"><li style="list-style-type:square">Require application programmers to explicitly link the appropriate object modules → error prone &amp; time consuming 👎</li></ul></li></ul><ul id="a3deafb2-449a-4377-a0df-f2e91ad28250" class="bulleted-list"><li style="list-style-type:circle"><strong>Advantages of Static libraries</strong><ul id="2e0e2484-82e5-4599-a312-0f9a7e239304" class="bulleted-list"><li style="list-style-type:square">Application programmers can use any functions in the library by <strong>specifying a single filename</strong> : <code>linux&gt; gcc main.c /user/lib/libm.a /user/lib/libc.a</code> → <strong>Convenient</strong>! 👍</li></ul><ul id="628a1ab7-2b32-44a9-8547-36021d7215bd" class="bulleted-list"><li style="list-style-type:square">The linker will <strong>only copy</strong> the object modules that are <strong>referenced</strong> by the program → <strong>Reduced size of the executable</strong> on disk and in memory 👍</li></ul></li></ul></li></ul><ul id="7a39d6fd-4d94-43a0-8804-ec16006fa49c" class="bulleted-list"><li style="list-style-type:disc"><strong>Linking with Static Libraries</strong><p id="b8e1872a-f7d3-47a4-89c1-ff074ab31e61" class="">On Linux systems, <strong>static libraries</strong> are stored in a particular file format, <strong>archive</strong>.</p><p id="f08f81ec-5447-412c-86ff-8ef7ba972c99" class=""><strong>Archive </strong>is <strong>a collection of concatenated relocatable object files</strong> + <strong>a header</strong> that describes the <strong>size &amp; location</strong> of each object files. Archive filenames are denoted with the <strong><code>.a</code></strong><strong> suffix</strong>.</p><pre id="3f32888a-5c64-40bf-894b-12f218e72a36" class="code"><code>/* addvec.o */
int addcnt = 0;
void addvec(int *x, int *y, int *z, int n){
	int i;
	addcnt++;
	for(i = 0; i &lt; n; ++i){
		z[i] = x[i] + y[i];
	}
}

/* main2.o */
#include &lt;stdio.h&gt;
#include &quot;vector.h&quot;

int x[2] = {1, 2};
int y[2] = {3, 4};
int z[2];

int main(){
	addvec(x, y, z, 2);
	printf(&quot;z = [%d %d]\n&quot;, z[0], z[1]);
	return 0;
}</code></pre><ol type="1" id="f181dbf7-ddad-4633-a3fb-527bab540bc8" class="numbered-list" start="1"><li>To <strong>create a static library</strong> of a function <code>addvec</code>, use the <code>AR</code> tool : <code>linux&gt; gcc -c addvec.c [other .c files]</code> → <code>linux&gt; ar rcs libvector.a addvec.o [other .o files]</code>  </li></ol><ol type="1" id="99dc4c77-0870-4887-9d56-ea20dad61d41" class="numbered-list" start="2"><li>To use the library, write an application <code>main2.c</code> which invokes the <code>addvec</code> library routine. <code>vector.h</code> defines the function prototypes for the routines in <code>libvector.a</code>.</li></ol><ol type="1" id="5e9b1821-df1d-4b2c-93bf-6d3e08676914" class="numbered-list" start="3"><li>To <strong>build the executable</strong>, compile and link the input files <code>main2.o</code> &amp; <code>libvector.a</code> : <code>linux&gt; gcc -c main2.c</code> → <code>linux&gt; gcc -static -o prog2c main2.o ./libvector.a</code><figure id="912fb42d-d483-4793-9304-68a58967a7ab" class="image"><a href="/assets/images/CSAPP-7/Untitled%202.png"><img style="width:576px" src="/assets/images/CSAPP-7/Untitled%202.png"/></a></figure></li></ol><p id="c73786ce-7fb2-4ba2-a0fd-e81e0b29c6fa" class="">The linker determines that <strong>the </strong><strong><code>addvec</code></strong><strong> symbol is referenced by </strong><strong><code>main2.o</code></strong><strong> </strong>→ It <strong>copies </strong><strong><code>addvec.o</code></strong><strong> into the executable</strong>.</p><p id="6c642aef-2e9d-4b56-8838-a8ac47b195de" class="">The linker also copies the <code>printf.o</code> module from <code>libc.a</code>, along with a number of other modules from the C run-time system. </p><p id="368e3861-6c38-463e-ad35-a64fcbecacb4" class="">The program doesn’t reference any symbols defined by other modules → The linker <strong>doesn’t copy any other modules</strong> into the executable.</p><p id="d32700cb-00ac-4ab2-8112-5a99cd74cf47" class="">
</p></li></ul></details></li></ul><ul id="5bd6b984-2e7f-4f5e-a361-ae70671d89de" class="toggle"><li><details open=""><summary><strong>How Linkers Use Static Libraries to Resolve References</strong></summary><p id="52717a29-d24b-4e16-9ed9-f08c69f56443" class="">During the<strong> symbol resolution phase</strong>, the linker scans the relocatable object files &amp; archives <strong>in the same order they appear on the command line</strong>. </p><p id="30d1d750-f662-4eee-ac04-f7cccc7fa3a2" class="">During this scan, the linker maintains a <strong>set </strong><strong><em>E, U, D</em></strong>, which are initially empty :</p><ul id="1ce39e1e-0a82-41db-ba21-5f45fca34fdb" class="bulleted-list"><li style="list-style-type:disc"><strong>Set </strong><strong><em>E</em></strong><strong> </strong>: A set of relocatable object files that <strong>will be merged</strong> to form the executable</li></ul><ul id="5b66736c-a9b6-4d1c-8d9f-4530d263269d" class="bulleted-list"><li style="list-style-type:disc"><strong>Set </strong><strong><em>U</em></strong><strong> </strong>: A set of <strong>unresolved symbols</strong> (<em>example : symbols referred to but not yet defined</em>)</li></ul><ul id="99110951-b976-4eea-8a10-2477e6d42e69" class="bulleted-list"><li style="list-style-type:disc"><strong>Set </strong><strong><em>D</em></strong> : A set of symbols that have been <strong>defined in previous input files.</strong></li></ul><hr id="2cb73b16-4406-4ef0-840a-b3c742ee1630"/><p id="a281393a-3147-48b9-8ca4-26472918a5b7" class="">Linker resolves references following the next algorithm :</p><ol type="1" id="cb943d02-db08-47ac-8d21-e51da4b37a61" class="numbered-list" start="1"><li>For each file <em>f </em>on the command line, determine if <em>f</em> is an <strong>object file</strong> or an <strong>archive</strong>.</li></ol><ol type="1" id="8a25cce6-92e8-4c2d-a63b-ef8f2bafc6f1" class="numbered-list" start="2"><li><em>f</em> is an <strong>object file</strong> → <strong>Add </strong><strong><em>f</em></strong><strong> to </strong><strong><em>E</em></strong><em>, </em><strong>update </strong><strong><em>U &amp; D</em></strong> to reflect symbol definitions &amp; references in <em>f, </em>and proceed to the next input file.</li></ol><ol type="1" id="acc7f665-47d0-4556-ae2f-d2e547f5083b" class="numbered-list" start="3"><li><em>f</em> is an <strong>archive </strong>→ Attempt to <strong>match the unresolved symbols</strong> in <em>U</em> against the symbols in the archive.<ol type="a" id="262e694c-1861-4338-91c9-babe96f8cf72" class="numbered-list" start="1"><li>Some archive member <em>m</em> defines a symbol that resolves a reference in <em>U → </em><strong>Add </strong><strong><em>m</em></strong><strong> to </strong><strong><em>E</em></strong>, and <strong>update </strong><strong><em>U &amp; D</em></strong><strong> </strong>to reflect the symbol definitions and references in <strong><em>m</em></strong>.</li></ol><ol type="a" id="7cd3b4fd-a093-4df6-9834-bd487f007a73" class="numbered-list" start="2"><li>Iterate the member object files in the archive until a fixed point is reached where<strong> </strong><strong><em>U &amp; D </em></strong><strong>no longer change</strong>. </li></ol><ol type="a" id="168cb868-58eb-449e-b9fd-af182f29ed4b" class="numbered-list" start="3"><li>After the iteration is over, <strong>discard any member object files not contained in </strong><strong><em>E.</em></strong></li></ol><ol type="a" id="f2edd52f-3137-4cb3-a8e9-4f7e47405fd1" class="numbered-list" start="4"><li>Proceed to the next input file.</li></ol></li></ol><ol type="1" id="4089f49f-8c3f-4e4b-8e50-7416a05b0604" class="numbered-list" start="4"><li>After the scanning, <strong><em>U</em></strong><strong> is empty</strong> → <strong>Merge &amp; relocate</strong> the object files in <em>E</em> to build the output executable file.</li></ol><ol type="1" id="5b515d01-605e-4a70-b282-d3316b32f363" class="numbered-list" start="5"><li>After the scanning,<em> </em><strong><em>U</em></strong><strong> isn’t empty</strong> → Print an <strong>error </strong>and terminate. </li></ol><hr id="a198cedc-769e-4654-8553-4246c829612c"/><p id="d4d98709-1b9d-4013-b069-c44c0b65f2f5" class="">If <strong>the library that defines a symbol</strong> appears on the command line <strong>before the object file that references that symbol</strong>, then the <strong>reference won’t be resolved</strong> and linking will fail! <em>(example : </em><em><code>linux&gt; gcc -static ./libvecctor.a main2.c</code></em><em> → Error occurs due to an undefined reference to </em><em><code>addvec</code></em><em>.)</em></p><p id="a9cf6bbc-d931-4f8a-997a-bc8e9ff125df" class="">⇒ <strong>Place libraries at the end</strong> of the command line.</p><p id="86efdd0b-3a8d-48f9-9a82-e2d2b0f335fc" class="">If the libraries are <strong>not independent</strong>, they must be ordered so that for each symbol <em>s</em> that is referenced externally by a member of an archive, <strong>at least one definition of </strong><strong><em>s</em></strong><strong> follows a reference to </strong><strong><em>s </em></strong>on the command line. <strong>Libraries can be repeated</strong> on the command line if necessary to satisfy the dependence requirements. (<em>example : </em><code><em>linux&gt; gcc foo.c libx.a liby.a libx.a</em></code>)</p><p id="1a54908c-bc9b-4898-abc4-bb8625b0374e" class="">
</p></details></li></ul></div><h2 id="2da9e055-be66-4b5b-9945-27f83f42e4de" class=""><details open=""><summary><mark class="highlight-blue">7.7</mark> Relocation</summary></details></h2><div class="indented"><p id="336c03d8-d9c3-4086-8b4b-ae419478a36a" class="">Once the linker has completed the symbol resolution step, the linker is now ready to begin the <strong>relocation</strong> step, where it <strong>merges the input modules</strong> and <strong>assigns run-time addresses to each symbol</strong>.</p><ul id="9dfa1a74-7f3a-45c1-9cf2-cf2333187298" class="toggle"><li><details open=""><summary><strong>Two Steps of Relocation</strong></summary><ol type="1" id="250af6df-8149-449e-91dc-6c8e64cf2aa6" class="numbered-list" start="1"><li>Relocating <strong>sections &amp; symbol definitions</strong><ol type="a" id="98c4f59d-e7d1-465b-8de7-8ead871d6a8a" class="numbered-list" start="1"><li>The linker <strong>merges all sections of the same type</strong> into a new aggregate section of the same type. (<em>example</em> <em>: </em><code><em>.data</em></code><em> sections from input modules are all merged into one </em><code><em>.data</em></code><em> section for the output executable object file.</em>)</li></ol><ol type="a" id="1d689a81-3b6f-4d68-9891-c060744deb78" class="numbered-list" start="2"><li>The linker <strong>assigns run-time memory addresses</strong> to the new aggregate sections, to each section defined by the input modules, and to each symbol.</li></ol></li></ol><ol type="1" id="7ea0781d-07cd-4544-9b2f-c57642a797b0" class="numbered-list" start="2"><li>Relocating <strong>symbol references</strong> within sections<ol type="a" id="9eeac634-6432-4b8e-9665-48d46e1fb50c" class="numbered-list" start="1"><li>The linker <strong>modifies every symbol references</strong> in the code and data sections <strong>so that they point to the correct run-time addresses</strong>.</li></ol></li></ol></details></li></ul><ul id="3646d71f-352d-4ba2-acce-ef385124bad6" class="toggle"><li><details open=""><summary><strong>Relocation Entries</strong></summary><p id="df7b8777-325a-47e3-805c-b73cf600bbef" class="">When the assembler encounters a reference to an object whose ultimate location is unknown, it generates a <strong>relocation entry</strong> that <strong>tells the linker how to modify the reference</strong> when it merges the object file into an executable. Relocation entries for <strong>code </strong>are placed in <strong><code>.rel.text</code></strong>, and relocation entries for <strong>data </strong>are placed in <strong><code>.rel.data</code></strong>.</p><pre id="44078230-4efc-41dd-82ff-8db3998bc26f" class="code"><code> typedef struct {
	long offset; /* Offset of the reference to relocate */
	long type:32, /* Relocation type */
			 symbol:32; /* Symbol table index */
	long addend; /* Constant part of relocation expression */
} Elf64_Rela;</code></pre><ul id="52879b89-58a7-47eb-a340-394e14029254" class="bulleted-list"><li style="list-style-type:disc"><code>offset</code> : the <strong>section offset</strong> of the reference that needs to be modified.</li></ul><ul id="341a9695-00c7-4875-b278-b6d1cf01395a" class="bulleted-list"><li style="list-style-type:disc"><code>type</code> : <strong>how </strong>the linker modify the new reference - ELF defines 32 different relocation types. Two most basic relocation types are :<ul id="5bccd062-3df6-4204-a333-4fd30d0f8644" class="bulleted-list"><li style="list-style-type:circle"><code>R_X86_64_PC32</code> : Relocate a reference that uses a 32-bit <strong>PC-relative address</strong>.</li></ul><ul id="17ffdacd-78f6-4054-bf06-260e0cace483" class="bulleted-list"><li style="list-style-type:circle"><code>R_X86_64_32</code> : Relocate a reference that uses a 32-bit <strong>absolute address</strong>.</li></ul></li></ul><ul id="009d3f82-2d3f-4fe8-a0a0-2aca5741cb5f" class="bulleted-list"><li style="list-style-type:disc"><code>symbol</code> : <strong>identifies the symbol</strong> that the modified reference should point to.</li></ul><ul id="d58c5d9d-2e4e-42e5-9a9c-e32a4f9f892e" class="bulleted-list"><li style="list-style-type:disc"><code>addend</code> : a signed <strong>constant </strong>that is used by some types of relocations to <strong>bias </strong>the value of the modified reference.</li></ul></details></li></ul><ul id="0af38599-6c98-45ef-8c73-f7636bba4498" class="toggle"><li><details open=""><summary><strong>Relocating Symbol References</strong></summary><p id="584f6d6b-1335-4a85-825e-1a73a204279a" class="">The pseudo-code for the linker’s <strong>relocation algorithm</strong> :</p><pre id="6e79fcff-ae95-4c82-b47e-70107ba884b5" class="code"><code>foreach section s {
	foreach relocation entry r {
		refptr = s + r.offset; /* ptr to reference to be relocated */

		/* Relocate a PC-relative reference */
		if (r.type == R_X86_64_PC32) {
			refaddr = ADDR(s) + r.offset; /* ref&#x27;s run-time address */
			*refptr = (unsigned) (ADDR(r.symbol) + r.addend - refaddr);
		}

		/* Relocate an absolute reference */
		if (r.type == R_X86_64_32)
			*refptr = (unsigned) (ADDR(r.symbol) + r.addend);
	}
}</code></pre><p id="a22bf23a-5a79-4437-ae6e-28cf3e5541a1" class="">This code assumes that the linker has already chosen run-time addresses for each section (<code>ADDR(s)</code>) and each symbol (<code>ADDR(r.symbol)</code>).</p><ul id="d338695e-a63e-45c7-aafa-cb7227bbdd95" class="bulleted-list"><li style="list-style-type:disc"><strong>Example of Relocating Symbol References : </strong><strong><code>main.o</code></strong><strong> for the C code in Section </strong><strong><mark class="highlight-blue">7.1</mark></strong><strong> </strong><p id="d0867444-9515-46e4-8d0e-8fb243a87a7e" class="">(<em>This code is generated by the GNU OBJDUMP tool - </em><strong><em>relocation entries and instructions are actually stored in different sections</em></strong><em>.</em>)</p></li></ul><pre id="022b88b8-7805-4498-b829-d8c7fc95de0b" class="code"><code>0000000000000000 &lt;main&gt;:
	0: 48 83 ec 08            sub $0x8,%rsp
  4: be 02 00 00 00         mov $0x2,%esi
	9: bf 00 00 00 00         mov $0x0,%edi            // %edi = &amp;array. &#x27;00 00 00 00&#x27; is the reference to array that needs to be modified.
										a: R_X86_64_32 array           // Relocation entry
	e: e8 00 00 00 00         callq 13 &lt;main+0x13&gt;     // sum(). &#x27;00 00 00 00&#x27; is the reference to array that needs to be modified.
                    f: R_X86_64_PC32 sum-0x4
 13: 48 83 c4 08            add $0x8,%rsp
 17: c3                     retq</code></pre><ul id="0d7ae2e4-6b65-4f3f-bea7-b08a7595588e" class="bulleted-list"><li style="list-style-type:disc"><strong>Relocating PC-Relative References</strong><ol type="1" id="184677ae-ee03-4a25-abde-bb5843bbf1fa" class="numbered-list" start="1"><li>At section offset <code>0xe</code>, the <code>call</code> instruction begins, followed by a <strong>placeholder </strong>for the <strong>4 byte PC-relative reference</strong> to the target <code>sum</code>. The corresponding relocation entry <code>r</code> consists of 4 fields :<p id="78fc54d1-e36a-40b3-ab86-ff8a489b8e8b" class=""><code>r.offset = 0xf</code> : the reference part starts from the section offset <code>0xf</code>.</p><p id="bb860610-3440-4760-824a-9f37a6ab5833" class=""><code>r.symbol = sum</code></p><p id="37d9cad6-04e4-4d17-9ea7-6089c6006266" class=""><code>r.type = R_X86_64_PC32</code></p><p id="67ab0ace-09bb-438a-aed3-320f51a6b811" class=""><code>r.append = -4</code> : the placeholder is 4 byte long.</p></li></ol><ol type="1" id="ad4d86b4-1ccc-481b-9415-87482a05e599" class="numbered-list" start="2"><li>Suppose that the linker has determined that <code>ADDR(s) = ADDR(.text) = 0x4004d0</code>, and <code>ADDR(r.symbol) = ADDR(sum) = 0x4004e8</code>.</li></ol><ol type="1" id="fcd61853-d371-4d7e-8241-063a6e4cf474" class="numbered-list" start="3"><li>Using the relocation algorithm, the linker first computes <strong>the run-time address of the reference</strong> :<p id="53bdd40d-4dc4-477c-8963-267ce09f894a" class=""><code>refaddr = ADDR(s) + r.offset = 0x4004d0 + 0xf = 0x4004df</code></p></li></ol><ol type="1" id="e52c4133-7acb-442f-a48a-202f3a2155f4" class="numbered-list" start="4"><li>Then the linker <strong>updates the reference</strong> so that it will point to the <code>sum</code> at the run time :<p id="805207e5-bda6-4997-a79d-70690dac8ea5" class=""><code>*refptr = (unsigned) (ADDR(r.symbol) + r.addend - refaddr) = 0x4004e8 + (-4) - 0x4004df = 0x5</code></p></li></ol><ol type="1" id="84e94c96-53a2-4abc-ada6-0bc4e9a5f804" class="numbered-list" start="5"><li>In the resulting executable object file, the <code>call</code> instruction has the following relocated form : <code>4004de: e8 05 00 00 00    callq 4004e8 &lt;sum&gt;</code>.</li></ol><ol type="1" id="a6fcd789-a04b-4882-82e0-142270ffdbc7" class="numbered-list" start="6"><li>At run time, when the CPU executes the <code>call</code>, the <strong>PC has a value of </strong><strong><code>0x4004e3</code></strong>. To execute the <code>call</code>, the CPU performs the following steps :<ol type="a" id="8a2b3efb-2e2d-4125-8b93-78fedb23d918" class="numbered-list" start="1"><li>Push PC onto stack</li></ol><ol type="a" id="0d81d290-0224-4c58-959b-071470fffa38" class="numbered-list" start="2"><li>PC ← <strong>PC + </strong><strong><code>0x5</code></strong> = <code>0x4004e3</code> + <code>0x5</code> = <code>0x4004e8</code> = <strong><code>sum</code></strong><strong>&#x27;s address!</strong></li></ol></li></ol></li></ul><ul id="ee8fff07-f3fe-4abc-920a-4f2dc3759471" class="bulleted-list"><li style="list-style-type:disc"><strong>Relocating Absolute References</strong><ol type="1" id="3ac8ed07-669b-476a-b9dc-c9b604dabf9a" class="numbered-list" start="1"><li>At section offset <code>0x9</code>, the <code>mov</code> instruction begins, followed by a <strong>placeholder </strong>for the <strong>4 byte absolute reference</strong> to <code>array</code>. The corresponding relocation entry <code>r</code> consists of 4 fields :<p id="64438b53-c848-48c2-b900-7029fe24ff4d" class=""><code>r.offset = 0xa</code> : the reference part starts from the section offset <code>0xa</code>.</p><p id="c8fcd06b-e4e7-411c-ab6e-a53cd1b5c996" class=""><code>r.symbol = array</code></p><p id="676dd67c-f8ec-4a49-9bee-297aaf78f0b0" class=""><code>r.type = R_X86_64_32</code></p><p id="5b2fbaac-5c2a-4b2e-a4fd-9f9ee4f58711" class=""><code>r.append = 0</code></p></li></ol><ol type="1" id="1d882f85-a816-4855-a72d-41f7ecdf60e4" class="numbered-list" start="2"><li>Suppose that the linker has determined that <code>ADDR(r.symbol) = ADDR(array) = 0x601018</code>.</li></ol><ol type="1" id="06f52fd7-eac2-4a50-a7a1-86d6a94c4569" class="numbered-list" start="3"><li>Using the relocation algorithm, the linker updates the reference :<p id="d518a7d4-9c5e-416f-b6bc-563393fa3d65" class=""><code>*refptr = (unsigned) (ADDR(r.symbol) + r.addend) = 0x601018 + 0 = 0x601018</code></p></li></ol><p id="238182fa-ac4c-4553-b06b-0f35fa7c8519" class="">In the resulting executable object file, the reference has the following relocated form : <code>4004d9: bf 18 10 60 00    mov $0x601018,%edi</code>.</p></li></ul></details></li></ul></div><h2 id="b1a1712f-493a-46d4-8bdb-057e17ec92cd" class=""><details open=""><summary><mark class="highlight-blue">7.8</mark> Executable Object Files</summary></details></h2><div class="indented"><figure id="57bf13bb-c9da-493e-94a3-5cdf7c61b6ca" class="image"><a href="/assets/images/CSAPP-7/Untitled%203.png"><img style="width:528px" src="/assets/images/CSAPP-7/Untitled%203.png"/></a></figure><ul id="8abcf629-b55d-40a9-8226-989704176200" class="bulleted-list"><li style="list-style-type:disc"><strong>ELF header</strong> : describes the <strong>overall format</strong> of the file &amp; includes program’s <strong>entry point</strong>(the address of the first instruction to execute).</li></ul><ul id="186aa0a2-302d-4719-b701-ff447e287059" class="bulleted-list"><li style="list-style-type:disc"><strong>Segment header table</strong><p id="4f0f1f88-307d-456f-b976-adbb9e6d2808" class="">In ELF executable, contiguous chunks of the <strong>executable file</strong> are <strong>mapped </strong>to contiguous <strong>memory segments</strong>. This mapping is described by <strong>segment header table</strong> (= <strong>program header table</strong>).</p><figure id="ff1b2068-0e99-4bc0-891e-b5ff9c5089cc" class="image"><a href="/assets/images/CSAPP-7/Untitled%204.png"><img style="width:720px" src="/assets/images/CSAPP-7/Untitled%204.png"/></a></figure><ul id="d26ef707-e3e6-4da7-b8d0-b91c71e2dcd8" class="bulleted-list"><li style="list-style-type:circle"><strong><code>off</code></strong><strong> </strong>: the <strong>offset </strong>of the segment’s first section in the object file</li></ul><ul id="ebb9edec-050c-4d4b-9fd1-02b05e4da548" class="bulleted-list"><li style="list-style-type:circle"><strong><code>vaddr/paddr</code></strong> : the <strong>starting address</strong> of the segment in the memory<p id="4891ae9a-78e6-41b5-8eb6-be4b168887d9" class="">The linker must choose <code>vaddr</code> such that<strong> </strong><strong><em><code>vaddr</code></em></strong><strong><em> mod </em></strong><strong><em><code>align</code></em></strong><strong><em> = </em></strong><strong><em><code>off</code></em></strong><strong><em> mod </em></strong><strong><em><code>align</code></em></strong><em>. </em>This alignment requirement is an optimization that <strong>enables efficient transfer</strong> of segments in the object files to memory.</p></li></ul><ul id="c8ea02f3-a62f-49a3-b60b-d5bd3cb71af0" class="bulleted-list"><li style="list-style-type:circle"><strong><code>align</code></strong><strong> </strong>: alignment requirement (2**21 = <code>0x200000</code>)</li></ul><ul id="dd4d5aa3-84ef-413f-9014-9d201f2756fc" class="bulleted-list"><li style="list-style-type:circle"><strong><code>filesz</code></strong><strong> </strong>: segment <strong>size </strong>in <strong>object file</strong></li></ul><ul id="7406070b-563c-45da-86cf-7ec3ac4ae6e9" class="bulleted-list"><li style="list-style-type:circle"><strong><code>memsz</code></strong><strong> </strong>: segment <strong>size </strong>in <strong>memory</strong></li></ul><ul id="3a0e92b8-921c-475e-83c9-e9e742f062f8" class="bulleted-list"><li style="list-style-type:circle"><strong><code>flags</code></strong><strong> </strong>: <strong>run-time permissions</strong> (<code>r-x</code> = read/execute permissions, <code>rw-</code> = read/write permissions)</li></ul><p id="0b65be85-f259-428a-ad85-a0ac151347bf" class="">For example, there are 2 segments in the program header table in Figure 7.14 - <strong>code segment</strong>(ELF header, program header table, <code>.init</code>, <code>.text</code>, <code>.rodata</code>) in Line 1, 2, and <strong>data segment</strong>(<code>.data</code>, <code>.bss</code>) in Line 3, 4.</p><p id="c97cb822-6bd7-4748-ac9b-b40f613e4d35" class=""><strong>Data segment</strong> has a total memory size of <code>0x230</code> bytes, and initialized with the <code>0x228</code> bytes in the <code>.data</code> section starting at offset <code>0xdf8</code> in the object file. The <strong>remaining 8 bytes</strong> correspond to <strong><code>.bss</code></strong><strong> data</strong> that will be initialized to 0 at run time. (<code>.bss</code> occupies <strong>no actual space</strong> in object file!)</p></li></ul><ul id="b8e440a4-9046-4375-b81c-d66bf1796266" class="bulleted-list"><li style="list-style-type:disc"><strong><code>.init</code></strong> : defines a function <strong><code>_init</code></strong>, that will be called by the <strong>program’s initialization code</strong>.</li></ul><ul id="dde7a811-112e-4e75-bb96-be1a9e25dcb4" class="bulleted-list"><li style="list-style-type:disc"><strong><code>.text</code></strong><strong>, </strong><strong><code>.rodata</code></strong><strong>, </strong><strong><code>.data</code></strong> : similar to those in a relocatable object file, except that these sections have been <strong>relocated to their run-time memory addresses</strong>.</li></ul><ul id="36d1810c-a398-46e4-b7b1-d8ff37013f49" class="bulleted-list"><li style="list-style-type:disc">Executable is <strong>fully linked</strong> → There are <strong>no </strong><strong><code>.rel.</code></strong><strong> sections</strong>. </li></ul></div><h2 id="34dc92a8-df49-4248-93b3-0c08991db5ca" class=""><details open=""><summary><mark class="highlight-blue">7.9</mark> Loading Executable Object Files</summary></details></h2><div class="indented"><p id="772a2683-6a1c-4aa4-ad1b-3be4fb2bae0b" class="">When we type <strong>executable object file’s name</strong> to the Linux shell’s command line, the shell runs the file by invoking <strong>loader </strong>- memory resident operating system code. </p><p id="c3afb33e-f76a-43dd-a459-b4b75f3944d0" class="">The <strong>loader </strong>copies <strong>the code &amp; data</strong> in the executable object file from disk into memory, and runs the program by <strong>jumping to its entry point</strong>. The loader can be invoked by calling the <strong><code>execve</code></strong><strong> </strong>function.</p><ul id="2c0f5854-4792-42ce-99d8-41ec0747893f" class="toggle"><li><details open=""><summary><strong>Run-time Memory</strong></summary><figure id="bb4bf9a7-8958-4e23-a53d-2e19f534d297" class="image"><a href="/assets/images/CSAPP-7/Untitled%205.png"><img style="width:336px" src="/assets/images/CSAPP-7/Untitled%205.png"/></a></figure><ul id="75a01a94-7b13-4e86-8056-4c6228133f50" class="bulleted-list"><li style="list-style-type:disc">On Linux x86-64 systems, the <strong>code segment</strong>(<code>.init</code>, <code>.text</code>, <code>.rodata</code>) starts at address <code>0x400000</code>, followed by the <strong>data segments</strong>(<code>.data</code>, <code>.bss</code>).</li></ul><ul id="1afeea7a-4e95-4f62-8a34-a9e120b1dd1c" class="bulleted-list"><li style="list-style-type:disc">The <strong>run-time heap</strong> follows the data segment, and grows <strong>upward </strong>via calls to the <code>malloc</code> library.</li></ul><ul id="69f0c1e9-2462-42bd-9544-246bd3151bb0" class="bulleted-list"><li style="list-style-type:disc">The region for <strong>shared modules</strong> follows the run-time heap.</li></ul><ul id="71b1d1ca-9857-46d7-aba5-faa9983f9946" class="bulleted-list"><li style="list-style-type:disc">The <strong>user stack</strong> starts below the <strong>largest legal user address</strong> <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>48</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{48}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">48</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></span><span>﻿</span></span>, and grows <strong>down</strong>.</li></ul><ul id="b50a16e1-e0a0-4b4b-b38c-54bf5d1231d7" class="bulleted-list"><li style="list-style-type:disc">The <strong>kernel memory</strong>, which is the memory-resident part of the OS, is above the stack.</li></ul><ul id="79315a4b-fb5d-4e55-bba0-b50ed56e2bed" class="bulleted-list"><li style="list-style-type:disc">In practice, there is a <strong>gap </strong>between the code and data segments due to the <strong>alignment requirement on </strong><strong><code>.data</code></strong><strong> segment</strong>, and the usage of <strong>address-space layout randomization(ASLR</strong>) when the linker assigns run-time addresses to the <strong>stack</strong>, <strong>shared library</strong> and <strong>heap segments.</strong></li></ul></details></li></ul><ul id="2ebb9858-094c-4b2b-b57f-0bd53447e86d" class="toggle"><li><details open=""><summary><strong>Loading Executable Object Files</strong></summary><ol type="1" id="5ab34677-98e2-4b5d-8269-deb49fe0a3e0" class="numbered-list" start="1"><li>The loader <strong>creates a rum-time memory</strong>.</li></ol><ol type="1" id="e8952765-f124-4af0-a28c-87b0c07659f5" class="numbered-list" start="2"><li>The loader <strong>copies </strong>chunks of the <strong>executable object file</strong> into the <strong>code &amp; data segments</strong>.</li></ol><ol type="1" id="54cc8d52-d635-454e-a155-7fe4c7adba2a" class="numbered-list" start="3"><li>The loader <strong>jumps to the programs’ entry point</strong>, which is always the <strong>address of the </strong><strong><code>_start</code></strong> function.<p id="5ae8011f-6307-474c-ae6d-0e3b1f832f2e" class=""> <code>_start</code> is defined in the system object file <code>crt1.o</code>, and is the same for all C programs. <code>_start</code> <strong>calls the</strong> <strong>system startup function, </strong><strong><code>__libc_start_main</code></strong>, which is defined in <code>libc.so</code>.</p><p id="30fcfb11-4f82-4d48-a9b5-5afb751bbbb6" class=""><strong><code>__libc_start_main</code></strong><strong> </strong>initializes the execution environment, calls the user-level <code>main</code> function, handles its return value, and if necessary returns control to the kernel. </p></li></ol></details></li></ul></div><h2 id="7255bbf4-e485-42c1-8d68-dae627fc45c8" class=""><details open=""><summary><mark class="highlight-blue">7.10</mark> Dynamic Linking with Shared Libraries</summary></details></h2><div class="indented"><ul id="7190a793-379a-4aec-af40-38a57754acf3" class="toggle"><li><details open=""><summary><strong>Disadvantages of Static Libraries</strong></summary><ul id="260ccfb9-08f3-4d27-81c4-381cad8c493c" class="bulleted-list"><li style="list-style-type:disc">Static libraries need to be <strong>maintained and updated periodically</strong>. If updated, programmers must explicitly <strong>re-link</strong> their programs against the updated library.</li></ul><ul id="acc25dcb-b6c5-4223-98c6-33ae86193db4" class="bulleted-list"><li style="list-style-type:disc">Almost every C program uses <strong>standard I/O functions</strong>(<code>printf</code>, <code>scanf</code>, ...) → the code for these functions is <strong>duplicated </strong>in the text segment of <strong>each running process</strong>. → Can be a <strong>waste of memory resources</strong> on a system running hundreds of processes. </li></ul></details></li></ul><ul id="d8ffe0f4-32c9-43cb-9ee6-ce99188b9009" class="toggle"><li><details open=""><summary><strong>Shared library</strong></summary><p id="b4cf63fe-27cf-41fe-9a1d-1a0305e83c7e" class="">A <strong>shared library</strong> is an object module that can be loaded at an <strong>arbitrary memory address</strong> and <strong>linked </strong>with a program in memory <strong>at either run time or load time</strong>. → <strong>Dynamic linker</strong> performs this process called <strong>dynamic linking</strong>.</p><p id="b9e01465-055c-44a6-ad45-cd6eff012134" class="">Shared libraries are indicated by the <strong><code>.so</code></strong><strong> suffix</strong>.</p><p id="f343c48a-13d5-4d3c-9f37-332c43a9bec6" class="">Shared libraries are shared in 2 ways :</p><ol type="1" id="f3892641-7240-430c-9b0b-76f47af06ab4" class="numbered-list" start="1"><li>There is <strong>only one </strong><strong><code>.so</code></strong><strong> file </strong>for a particular library. The code &amp; data in this <code>.so</code> file are shared by <strong>all executable object files that reference this library</strong>.<p id="85633f7a-c252-4585-90c8-c94a540c4cd8" class="">↔ Static library’s contents are copied and embedded in each executables that reference them.</p></li></ol><ol type="1" id="f27b62ac-3554-4ac7-8ead-20c6f86d63f9" class="numbered-list" start="2"><li>A single copy of the <strong><code>.text</code></strong><strong> section of a shared library</strong> in memory can be <strong>shared by different running processes</strong>.</li></ol></details></li></ul><ul id="3beae6dd-bd8c-4610-96c1-b2e0e6ca4ebd" class="toggle"><li><details open=""><summary><strong>Dynamic Linking process</strong></summary><figure id="b86dc279-b133-4de9-92d6-5d16448e2f6d" class="image"><a href="/assets/images/CSAPP-7/Untitled%206.png"><img style="width:384px" src="/assets/images/CSAPP-7/Untitled%206.png"/></a></figure><p id="1c594821-e8ed-4af5-9bec-561c44f9a75e" class="">This process is for the case in which the dynamic linker loads and links shared libraries <strong>when an application is loaded</strong>.</p><p id="d9b34323-1923-4781-b5a8-d5efc82aa1f9" class="">The basic idea is to do some of the linking<strong> statically when the executable file is created</strong>, and then complete the linking process<strong> dynamically when the program is loaded</strong>.</p><ol type="1" id="68779864-8231-488b-9b10-5e81d80840bb" class="numbered-list" start="1"><li>To <strong>create the library</strong>, invoke the compiler driver with some special directives to the compiler and linker : <code>linux&gt; gcc -shared -fpic -o libvector.so addvec.c multvec.c</code><p id="45185035-d6c8-40ce-8812-5122e14ab191" class=""><code>-fpic</code> : directs the compiler to generate position-independent code.</p><p id="48f98e95-d580-4f5b-87b5-a755b5c06d68" class=""><code>-shared</code> : directs the linker to create a shared object file.</p></li></ol><ol type="1" id="f77ab14d-4fd4-4a36-8d06-2c2fca6d7fc4" class="numbered-list" start="2"><li><strong>Link </strong>it into different object files : <code>linux&gt; gcc -o prog21 main2.c ./libvector.so</code><p id="688a48a7-c026-4f4c-b083-3c59a24f48fe" class="">→ An executable object file <code>prog21</code> is created in a form that <strong>can be linked with </strong><strong><code>libvector.so</code></strong><strong> at run time</strong>.</p><p id="0a5041df-749e-4b97-90b4-d5c00ac6d601" class="">※ <strong>None </strong>of the code or data sections from <code>libvector.so</code> are copied into the <code>prog21</code>. Instead, the linker copies some <strong>relocation &amp; symbol table information</strong> that will allow references to code and data in <code>libvector.so</code> to be resolved at <strong>load time</strong>.</p></li></ol><ol type="1" id="460e36dc-4074-4ee3-b707-aeb0f7d9710c" class="numbered-list" start="3"><li>When the loader <strong>loads &amp; run </strong><strong><code>prog21</code></strong>, the loader loads the <strong>partially linked</strong> executable <code>prog21</code>.</li></ol><ol type="1" id="693de89a-5efa-4e7f-bfa0-00a8cb563149" class="numbered-list" start="4"><li>The loader notices that <code>prog21</code> contains a <strong><code>.interp</code></strong><strong> section</strong>, which contains the path name of the <strong>dynamic linker</strong>. </li></ol><ol type="1" id="2ccc8a06-0f37-439f-9b09-82abf6574e9c" class="numbered-list" start="5"><li>The loader loads &amp; runs the <strong>dynamic linker</strong>.</li></ol><ol type="1" id="80bba7dc-f45b-4961-83f6-3a357dd67af8" class="numbered-list" start="6"><li>The <strong>dynamic linker</strong> finishes the linking task by performing following <strong>relocations </strong>:<ul id="800736e8-4e62-49c8-b4a5-b4cd8f1d6f9d" class="bulleted-list"><li style="list-style-type:disc">Relocating the text and data of <code>libc.so</code> into some memory segment</li></ul><ul id="1d9a5743-3143-4e90-a720-cc8c68e33c17" class="bulleted-list"><li style="list-style-type:disc">Relocating the text and data of <code>libvector.so</code> into some another memory segment</li></ul><ul id="edd20400-cbb2-4679-ae3a-88676096db69" class="bulleted-list"><li style="list-style-type:disc">Relocating any <strong>references in </strong><strong><code>prog21</code></strong><strong> </strong>to symbols defined by <code>libc.so</code> and <code>libvector.so</code></li></ul></li></ol><ol type="1" id="87877a11-aef8-49fc-84ed-e7feabf334ee" class="numbered-list" start="7"><li>The dynamic linker <strong>passes control</strong> to the application.</li></ol></details></li></ul></div><h2 id="cfffd29c-60c6-4eac-b79e-b73062fdced5" class=""><details open=""><summary><mark class="highlight-blue">7.11</mark> Loading and Linking Shared Libraries from Applications</summary></details></h2><div class="indented"><p id="e59d466e-bc41-4b1c-902d-9a98a59a35c4" class="">It is also possible for an application to request the dynamic linker to load and link arbitrary shared libraries while the application is running.</p><p id="76d44789-5f1a-4798-b0b4-70696087c69b" class="">Linux system provide a simple interface to the dynamic linker that allows application programs to load and link shared libraries at run time :</p><pre id="ae41f2c4-82d1-45a1-87f5-3ba2c499f134" class="code"><code>#include &lt;dlfcn.h&gt;

// dlopen function loads and links the shared library &#x27;filename&#x27;. returns pointer to handle if OK, NULL on error.
void *dlopen(const char *filename, int flag);

// dlsym takes a handle to a previously opened shared library and a symbol name, and returns the address of the symbol if it exists. returns NULL otherwise.
void *dlsym(void *handle, char *symbol);

// dlclose unloads the shared library if no other shared libraries are still using it. returns 0 if OK, -1 on error.
int dlclose (void *handle);

// dlerror returns a string describing the most recent error that occured, or NULL if no error occured.
cost char *dlerror(void);</code></pre></div><h2 id="b6ff3fe0-8bc3-4f98-b417-00c9c2afd70e" class=""><details open=""><summary><mark class="highlight-blue">7.12</mark> Position-Independent Code (PIC)</summary></details></h2><div class="indented"><p id="f376e2a9-99fd-4301-8b6d-9cbe17af079f" class="">Modern systems compile the <strong>code segments of shared modules</strong> so that they can be <strong>loaded anywhere in memory</strong> without having to be modified by the linker. → A single copy of shared module’s code segment can be <strong>shared by several processes</strong>. </p><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="644e5279-239c-43b8-aed8-966ea576ba62"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%">Each process still get its own copy of the <strong>read/write data segment</strong>.</div></figure><p id="70ebbde5-5d62-4636-b9bc-413536600550" class=""><strong>Position-independent code (PIC)</strong> is the code that can be loaded <strong>without any relocations</strong>.</p><p id="5e103ba7-b644-4a7f-b8af-21c2facdf57c" class="">References to external procedures and global variables that are defined by shared modules require some special techniques :</p><ul id="d0e9c025-b2b2-4930-8bcf-1b2717921026" class="toggle"><li><details open=""><summary><strong>PIC Data Reference</strong></summary><p id="585b0e7d-8ba0-4164-946c-69ad133c4c0b" class="">The distance between any instruction in the code segment and any variable in the data segment is a run-time constant. → Compilers that want to generate PIC references to global variables exploit this fact by creating a table called the global offset table (GOT) at the beginning of the data segment.</p><ul id="f294770b-7c74-425c-87a5-b0cb64b1ad52" class="bulleted-list"><li style="list-style-type:disc">The <strong>GOT</strong> contains an <strong>8-byte entry </strong>for each global procedure or variable that is referenced by the object module. </li></ul><ul id="87fe6786-6c05-4ce8-9fe3-4d4dbc0505ef" class="bulleted-list"><li style="list-style-type:disc">The compiler also generates a <strong>relocation record</strong> for each entry in the GOT.</li></ul><ul id="698dc6f6-64ce-4d8f-87cb-25eb53c971b3" class="bulleted-list"><li style="list-style-type:disc">At <strong>load time</strong>, the <strong>dynamic linker</strong> relocates each GOT entry so that it <strong>contains the absolute address of the object</strong>. </li></ul><ul id="1dedd763-bb84-4500-b58c-7d588eec7367" class="bulleted-list"><li style="list-style-type:disc"><strong>Using GOT to reference a global variable</strong><figure id="6c2b643a-6035-45cd-8e3b-689f181b44a8" class="image"><a href="/assets/images/CSAPP-7/Untitled%207.png"><img style="width:480px" src="/assets/images/CSAPP-7/Untitled%207.png"/></a></figure><p id="64169509-d2d2-41dd-81b6-c82559e188c6" class=""><code>addvec</code> in code segment loads the address of the global variable <code>addcnt</code> <strong>indirectly via </strong><strong><code>GOT[3]</code></strong> : <code>mov 0x2008b9(%rip), %rax</code></p><p id="c655c96f-f1c4-4d01-83a3-fbda769f72f0" class=""><code>%rip</code> at this moment is the address of the instruction <code>addl $0x1, (%rax)</code>, and <code>0x2008b9</code> is the <strong>distance between </strong><strong><code>GOT[3]</code></strong><strong> and </strong><strong><code>%rip</code></strong>. </p></li></ul><p id="c19b5d99-d59a-4877-afd3-c88ed1c34596" class="">
</p></details></li></ul><ul id="03af7ebe-f61c-45b6-a4f7-5487e022fa18" class="toggle"><li><details open=""><summary><strong>PIC Function Calls</strong></summary><p id="75b8ffa8-205b-4da7-89e7-c4b3046558ce" class=""><strong>GNU compilation system</strong> uses an technique called <strong>lazy binding</strong> that <strong>defers </strong>the binding of each procedure address until the <strong>first time</strong> the procedure is called.</p><p id="806efc7e-1368-4697-92bd-972aad6f5368" class="">→ By deferring the resolution of a function’s address <strong>until it is actually called</strong>, the dynamic linker can <strong>avoid </strong>hundreds or thousands of <strong>unnecessary relocations at load time</strong>.</p><p id="6e8dd14a-31da-40b6-84ac-30e4daccca4e" class=""><strong>Lazy binding</strong> is implemented with a interaction between the <strong>GOT </strong>and <strong>the procedure linkage table (PLT).</strong></p><ul id="23a233bd-a77c-44bf-ab19-ba636a3b54fd" class="bulleted-list"><li style="list-style-type:disc"><strong>The contents of PLT</strong><ul id="d8ebd5e7-2645-493e-9edd-74ac7b38b548" class="bulleted-list"><li style="list-style-type:circle">The PLT is part of the <strong>code segment</strong>.</li></ul><ul id="3b82ae37-570c-43ea-aefb-0d9f1e5d09c3" class="bulleted-list"><li style="list-style-type:circle">The PLT is an array of 16-byte <strong>code </strong>entries. Each <strong>shared library function</strong> called by the executable has its <strong>own PLT entry</strong>. Each of these entries is responsible for <strong>invoking a specific function</strong>.</li></ul><ul id="6727e7ec-a8eb-4d5b-9d52-7681e0605b27" class="bulleted-list"><li style="list-style-type:circle"><code>PLT[0]</code> is a special entry that jumps into the <strong>dynamic linker</strong>.</li></ul><ul id="e555fa65-8e49-4e35-965b-bcb9cca65c68" class="bulleted-list"><li style="list-style-type:circle"><code>PLT[1]</code> invokes the <strong>system startup function</strong> <code>__libc_start_main</code> (appeared in <strong>section </strong><strong><mark class="highlight-blue">7.9</mark></strong>).</li></ul><ul id="6dc48035-adf1-4be9-951f-b60d1767f4e3" class="bulleted-list"><li style="list-style-type:circle">Entries starting at <code>PLT[2]</code> invoke <strong>functions called by the user code</strong>.</li></ul><ul id="6edbbe39-4d48-452d-a189-fda3d04f0c9a" class="bulleted-list"><li style="list-style-type:circle">In the figure, <code>PLT[2]</code> invokes <code>addvec</code> and <code>PLT[3]</code> (not shown) invokes <code>printf</code>.</li></ul><ul id="92fdccad-2d9d-4741-b92e-a29bf63ae969" class="bulleted-list"><li style="list-style-type:circle">Instructions of PLT entry (except for <code>PLT[0]</code>)<ol type="1" id="63e7cbc9-d54f-42b1-963d-c353773234c0" class="numbered-list" start="1"><li>Jump to corresponding GOT entry</li></ol><ol type="1" id="ee3d7c74-3358-4b9d-9ba7-486d618cdc9b" class="numbered-list" start="2"><li>Push ID for function onto the stack</li></ol><ol type="1" id="edf0bed8-4010-4360-8eac-f58514cdfe37" class="numbered-list" start="3"><li>Jump to PLT[0]</li></ol></li></ul></li></ul><ul id="1a859fa2-b1cf-41ee-8b3b-2082879757cf" class="bulleted-list"><li style="list-style-type:disc"><strong>The contents of GOT</strong><ul id="791a4620-0f0e-4cb4-af9d-99db57dcf8df" class="bulleted-list"><li style="list-style-type:circle">The GOT is part of the <strong>data segment</strong>.</li></ul><ul id="e794a87e-df83-46ce-84c9-5a05895c7648" class="bulleted-list"><li style="list-style-type:circle">The GOT is an array of 8-byte <strong>address </strong>entries.</li></ul><ul id="432a507b-25d0-4b2f-8abd-4c6cd9c1a38d" class="bulleted-list"><li style="list-style-type:circle">When used in conjunction with the PLT, <code>GOT[0]</code> and <code>GOT[1]</code> contain information that the dynamic linker uses when it resolves function addresses. </li></ul><ul id="81ec3e17-b426-4e3b-aa02-4f707dbf9a15" class="bulleted-list"><li style="list-style-type:circle"><code>GOT[2]</code> is the <strong>entry point</strong> <strong>for the dynamic linker</strong>.</li></ul><ul id="5fddef7b-f432-4ebd-aef8-e57875a14584" class="bulleted-list"><li style="list-style-type:circle">Each of the remaining entries <strong>corresponds to a called function</strong> whose address needs to be resolved at run time.</li></ul><ul id="ccf71668-b9a4-4897-bb82-5cae3dd8947c" class="bulleted-list"><li style="list-style-type:circle"><strong>Each entries has a</strong> <strong>matching PLT entry</strong>. Initially, each GOT entry <strong>points to the second instruction in the corresponding PLT entry</strong>.</li></ul><ul id="99dd3c19-9a9a-4dbd-b13d-52c48f922cf0" class="bulleted-list"><li style="list-style-type:circle">In the figure, <code>GOT[4]</code> and <code>PLT[2]</code> correspond to <code>addvec</code>.</li></ul></li></ul><figure id="a21bcf02-8d4d-42de-bb09-d45bddc50039" class="image"><a href="Chapter%207%20Linking%205cb404a26598447b8a88d8986b4e4cc2/Untitled%208.png"><img style="width:576px" src="/assets/images/CSAPP-7/Untitled%208.png"/></a></figure><ul id="2bac6c3e-bfbf-4f27-ba14-beb0affcaa77" class="bulleted-list"><li style="list-style-type:disc"><strong>Lazy binding - First invocation of </strong><strong><code>addvec</code></strong><ol type="1" id="03e37d81-7838-4cd9-a39d-ab09569593b4" class="numbered-list" start="1"><li>The program calls into <code>PLT[2]</code> - the PLT entry for <code>addvec</code>.</li></ol><ol type="1" id="4c79bb7f-67b6-4b00-9796-0a3d4a4b9532" class="numbered-list" start="2"><li>The first PLT instruction does an indirect jump through <code>GOT[4]</code> : <code>jmpq *GOT[4]</code><p id="8f5e1836-c485-4914-8ff4-d35666d2dad4" class="">The <strong>initial GOT entries point to the second instruction</strong> (<code>0x4005c6</code>) in its corresponding PLT entry → The indirect jump <strong>transfers control back to the next instruction</strong> in <code>PLT[2]</code>.</p></li></ol><ol type="1" id="7597ee83-ae91-46a3-8080-48e83478755b" class="numbered-list" start="3"><li>After <strong>pushing an</strong> <strong>ID for </strong><strong><code>addvec</code></strong> (<code>0x1</code>) onto the stack, <code>PLT[2]</code> jumps to <code>PLT[0]</code> : <code>pushq $0x1</code>, <code>jmpq 4005a0</code></li></ol><ol type="1" id="89121491-f479-4bc2-b776-0472967d6968" class="numbered-list" start="4"><li><code>PLT[0]</code> <strong>pushes an argument for the dynamic linker</strong> indirectly through <code>GOT[1]</code> (<strong>address of relocation entries</strong>) : <code>pushq *GOT[1]</code><p id="a154d55a-827b-4214-ab40-64dffde9b200" class="">and then jumps into the dynamic linker indirectly through <code>GOT[2]</code> : <code>jmpq *GOT[2]</code></p></li></ol><ol type="1" id="16f93708-47c7-4984-ab5d-bf7896b6ad0a" class="numbered-list" start="5"><li>The <strong>dynamic linker</strong> uses the <strong>two stack entries</strong> (<code>0x1</code>, <code>*GOT[1]</code>) to <strong>determine the run-time location of </strong><strong><code>addvec</code></strong>, <strong>overwrites </strong><strong><code>GOT[4]</code></strong> with this address, and passes control to <code>addvec</code>.</li></ol></li></ul><ul id="f2fe5af2-9a4a-48ab-a295-a00b76e5a8de" class="bulleted-list"><li style="list-style-type:disc"><strong>Lazy binding - Subsequent invocations of </strong><strong><code>addvec</code></strong><ol type="1" id="1b20c30d-59e2-4155-b1cc-af0671907111" class="numbered-list" start="1"><li>Control passes to <code>PLT[2]</code>.</li></ol><ol type="1" id="a603a66c-f7fa-4362-8355-68f13039a4d3" class="numbered-list" start="2"><li><strong>The indirect jump through </strong><strong><code>GOT[4]</code></strong><strong> transfers control directly to </strong><strong><code>addvec</code></strong> : <code>jmpq *GOT[4]</code></li></ol></li></ul></details></li></ul></div><h2 id="b2d5df2f-04bd-4b62-bf7a-580f6d420684" class=""><details open=""><summary><mark class="highlight-blue">7.13</mark> Library Interpositioning</summary></details></h2><div class="indented"><ul id="d1985dda-2de0-4f37-a5aa-1ac1fd2f80b6" class="toggle"><li><details open=""><summary><strong>Library Interpositioning</strong></summary><p id="7fd719d1-8d86-4265-b58d-6b04bac9ae61" class="">Linux linkers support a <strong>library interpositioning</strong> that allows you to <strong>intercept calls to shared library functions and execute your own code</strong>. → You can trace the number of times a particular library function is called, validate and trace its input and output values, or replace it with a completely different implementation.</p></details></li></ul><ul id="6398d372-7c5a-49c5-bb91-0e001dd2b6cd" class="toggle"><li><details open=""><summary><strong>The basic idea of library interpositioning</strong></summary><ul id="35271c9f-81ee-4058-a5af-2526e57d701a" class="bulleted-list"><li style="list-style-type:disc">Given some <strong>target function</strong> to be interposed on, create a <strong>wrapper function</strong> whose prototype is identical to the target function, which typically <strong>executes its own logic</strong>, then <strong>calls the target function</strong> and <strong>passes its return value</strong> back to the caller.</li></ul><ul id="8e18d0ef-8cee-428e-baa4-e78558531cea" class="bulleted-list"><li style="list-style-type:disc">Using some particular interpositioning mechanism, we can <strong>trick the system</strong> into <strong>calling the wrapper function</strong> instead of the target function..</li></ul><ul id="4db0a713-88a5-4e17-af4b-14af70f42d1e" class="bulleted-list"><li style="list-style-type:disc">Interpositioning can occur at <strong>compile time</strong>, <strong>link time</strong>, or<strong> run time</strong> as the program is being loaded and executed.</li></ul></details></li></ul></div><p id="a2159216-5505-4e0b-9b2d-e99e444720d6" class="">
</p></div></article></body></html>