---
title:  "CS:APP Chapter 8 Summary ⚠"
excerpt: "Chatper 8 - Exceptional Control Flow"
toc: true
classes: wide

categories:
  - CSAPP

---
Recently, I've been studying CS:APP - I'm posting my own summary of chapter 8 that I wrote up using [Notion](https://cw00h.notion.site/CS-APP-6d3c5c01e6e1456ca51f594a80b5c1f0).
<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Chapter 8 : Exceptional Control Flow</title><style>
/* cspell:disable-file */
/* webkit printing magic: print all background colors */

.Notion strong {
    font-weight: 600;
}

.Notion a,
.Notion a.visited {
	color: inherit;
	text-decoration: underline;
}

.pdf-relative-link-path {
	font-size: 80%;
	color: #444;
}

.Notion h1,
.Notion h2,
.Notion h3 {
	letter-spacing: -0.01em;
	line-height: 1.2;
	font-weight: 600;
	margin-bottom: 0;
    display: flex;
}

.page-title {
	font-size: 2.5rem;
	font-weight: 700;
	margin-top: 0;
	margin-bottom: 0.75em;
}

.Notion h1 {
	font-size: 1.875rem;
	margin-top: 1.875rem;
}

.Notion h2 {
	font-size: 1.5rem;
	margin-top: 1.5rem;
}

.Notion h3 {
	font-size: 1.25rem;
	margin-top: 1.25rem;
}

.Notion .source {
	border: 1px solid #ddd;
	border-radius: 3px;
	padding: 1.5em;
	word-break: break-all;
}

.Notion .callout {
	border-radius: 3px;
	padding: 1rem;
}

.Notion figure {
	margin: 1.25em 0;
	page-break-inside: avoid;
}

.Notion figcaption {
	opacity: 0.5;
	font-size: 85%;
	margin-top: 0.5em;
}

.Notion mark {
	background-color: transparent;
}

.Notion .indented {
	padding-left: 1.5em;
}

.Notion hr {
	background: transparent;
	display: block;
	width: 100%;
	height: 1px;
	visibility: visible;
	border: none;
	border-bottom: 1px solid rgba(55, 53, 47, 0.09);
}

.Notion img {
	max-width: 100%;
}

@media only print {
	.Notion img {
		max-height: 100vh;
		object-fit: contain;
	}
}

@page {
	margin: 1in;
}

.Notion .collection-content {
	font-size: 0.875rem;
}

.Notion .column-list {
	display: flex;
	justify-content: space-between;
}

.Notion .column {
	padding: 0 1em;
}

.Notion .column:first-child {
	padding-left: 0;
}

.Notion .column:last-child {
	padding-right: 0;
}

.Notion .table_of_contents-item {
	display: block;
	font-size: 0.875rem;
	line-height: 1.3;
	padding: 0.125rem;
}

.Notion .table_of_contents-indent-1 {
	margin-left: 1.5rem;
}

.Notion .table_of_contents-indent-2 {
	margin-left: 3rem;
}

.Notion .table_of_contents-indent-3 {
	margin-left: 4.5rem;
}

.Notion .table_of_contents-link {
	text-decoration: none;
	opacity: 0.7;
	border-bottom: 1px solid rgba(55, 53, 47, 0.18);
}

.Notion table,
.Notion th,
.Notion td {
	border: 1px solid rgba(55, 53, 47, 0.09);
	border-collapse: collapse;
}

.Notion table {
	border-left: none;
	border-right: none;
}

.Notion th,
.Notion td {
	font-weight: normal;
	padding: 0.25em 0.5em;
	line-height: 1.5;
	min-height: 1.5em;
	text-align: left;
}

.Notion th {
	color: rgba(55, 53, 47, 0.6);
}

.Notion ol,
.Notion ul {
	margin: 0;
	margin-block-start: 0.6em;
	margin-block-end: 0.6em;
}

.Notion li > ol:first-child,
.Notion li > ul:first-child {
	margin-block-start: 0.6em;
}

.Notion ul > li {
	list-style: disc;
}

.Notion ul.to-do-list {
	text-indent: -1.7em;
}

.Notion ul.to-do-list > li {
	list-style: none;
}

.Notion .to-do-children-checked {
	text-decoration: line-through;
	opacity: 0.375;
}

.Notion ul.toggle > li {
	list-style: none;
}

.Notion ul {
	padding-inline-start: 1.7em;
}

.Notion ul > li {
	padding-left: 0.1em;
}

.Notion ol {
	padding-inline-start: 1.6em;
}

.Notion ol > li {
	padding-left: 0.2em;
}

.mono ol {
	padding-inline-start: 2em;
}

.mono ol > li {
	text-indent: -0.4em;
}

.toggle {
	padding-inline-start: 0em;
	list-style-type: none;
}

/* Indent toggle children */
.toggle > li > details {
	padding-left: 1.7em;
}

.toggle > li > details > summary {
	margin-left: -1.1em;
}

.selected-value {
	display: inline-block;
	padding: 0 0.5em;
	background: rgba(206, 205, 202, 0.5);
	border-radius: 3px;
	margin-right: 0.5em;
	margin-top: 0.3em;
	margin-bottom: 0.3em;
	white-space: nowrap;
}

.collection-title {
	display: inline-block;
	margin-right: 1em;
}

.simple-table {
	margin-top: 1em;
	font-size: 0.875rem;
	empty-cells: show;
}
.simple-table td {
	height: 29px;
	min-width: 120px;
}

.simple-table th {
	height: 29px;
	min-width: 120px;
}

.simple-table-header-color {
	background: rgb(247, 246, 243);
	color: black;
}
.simple-table-header {
	font-weight: 500;
}

.Notion time {
	opacity: 0.5;
}

.icon {
	display: inline-block;
	max-width: 1.2em;
	max-height: 1.2em;
	text-decoration: none;
	vertical-align: text-bottom;
	margin-right: 0.5em;
}

.Notion img.icon {
	border-radius: 3px;
}

.user-icon {
	width: 1.5em;
	height: 1.5em;
	border-radius: 100%;
	margin-right: 0.5rem;
}

.user-icon-inner {
	font-size: 0.8em;
}

.text-icon {
	border: 1px solid #000;
	text-align: center;
}

.page-cover-image {
	display: block;
	object-fit: cover;
	width: 100%;
	max-height: 30vh;
}

.page-header-icon {
	font-size: 3rem;
	margin-bottom: 1rem;
}

.page-header-icon-with-cover {
	margin-top: -0.72em;
	margin-left: 0.07em;
}

.page-header-icon img {
	border-radius: 3px;
}

.link-to-page {
	margin: 1em 0;
	padding: 0;
	border: none;
	font-weight: 500;
}

.Notion p > .user {
	opacity: 0.5;
}

.Notion td > .user,
.Notion td > time {
	white-space: nowrap;
}

input[type="checkbox"] {
	transform: scale(1.5);
	margin-right: 0.6em;
	vertical-align: middle;
}

.Notion p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
}

.image {
	border: none;
	margin: 1.5em 0;
	padding: 0;
	border-radius: 0;
	text-align: center;
}

.code,
.Notion code {
	background: rgba(135, 131, 120, 0.15);
	border-radius: 3px;
	padding: 0.2em 0.4em;
	border-radius: 3px;
	font-size: 85%;
	tab-size: 2;
}

.Notion code {
	color: #eb5757;
}

.Notion .code {
	padding: 1.5em 1em;
}

.Notion .code-wrap {
	white-space: pre-wrap;
	word-break: break-all;
}

.Notion .code > code {
	background: none;
	padding: 0;
	font-size: 100%;
	color: inherit;
}

.Notion blockquote {
	font-size: 1.25em;
	margin: 1em 0;
	padding-left: 1em;
	border-left: 3px solid rgb(55, 53, 47);
}

.bookmark {
	text-decoration: none;
	max-height: 8em;
	padding: 0;
	display: flex;
	width: 100%;
	align-items: stretch;
}

.bookmark-title {
	font-size: 0.85em;
	overflow: hidden;
	text-overflow: ellipsis;
	height: 1.75em;
	white-space: nowrap;
}

.bookmark-text {
	display: flex;
	flex-direction: column;
}

.bookmark-info {
	flex: 4 1 180px;
	padding: 12px 14px 14px;
	display: flex;
	flex-direction: column;
	justify-content: space-between;
}

.bookmark-image {
	width: 33%;
	flex: 1 1 180px;
	display: block;
	position: relative;
	object-fit: cover;
	border-radius: 1px;
}

.bookmark-description {
	color: rgba(55, 53, 47, 0.6);
	font-size: 0.75em;
	overflow: hidden;
	max-height: 4.5em;
	word-break: break-word;
}

.bookmark-href {
	font-size: 0.75em;
	margin-top: 0.25em;
}

.sans { font-family: ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
.code { font-family: "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace; }
.serif { font-family: Lyon-Text, Georgia, ui-serif, serif; }
.mono { font-family: iawriter-mono, Nitti, Menlo, Courier, monospace; }
.pdf .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK JP'; }
.pdf:lang(zh-CN) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC'; }
.pdf:lang(zh-TW) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK TC'; }
.pdf:lang(ko-KR) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK KR'; }
.pdf .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK JP'; }
.pdf:lang(zh-CN) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK SC'; }
.pdf:lang(zh-TW) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK TC'; }
.pdf:lang(ko-KR) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK KR'; }
.pdf .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.highlight-default {
	color: rgba(55, 53, 47, 1);
}
.highlight-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.highlight-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.highlight-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.highlight-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.highlight-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.highlight-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.highlight-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.highlight-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.highlight-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.highlight-gray_background {
	background: rgba(241, 241, 239, 1);
}
.highlight-brown_background {
	background: rgba(244, 238, 238, 1);
}
.highlight-orange_background {
	background: rgba(251, 236, 221, 1);
}
.highlight-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.highlight-teal_background {
	background: rgba(237, 243, 236, 1);
}
.highlight-blue_background {
	background: rgba(231, 243, 248, 1);
}
.highlight-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.highlight-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.highlight-red_background {
	background: rgba(253, 235, 236, 1);
}
.block-color-default {
	color: inherit;
	fill: inherit;
}
.block-color-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.block-color-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.block-color-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.block-color-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.block-color-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.block-color-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.block-color-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.block-color-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.block-color-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.block-color-gray_background {
	background: rgba(241, 241, 239, 1);
}
.block-color-brown_background {
	background: rgba(244, 238, 238, 1);
}
.block-color-orange_background {
	background: rgba(251, 236, 221, 1);
}
.block-color-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.block-color-teal_background {
	background: rgba(237, 243, 236, 1);
}
.block-color-blue_background {
	background: rgba(231, 243, 248, 1);
}
.block-color-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.block-color-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.block-color-red_background {
	background: rgba(253, 235, 236, 1);
}
.select-value-color-pink { background-color: rgba(245, 224, 233, 1); }
.select-value-color-purple { background-color: rgba(232, 222, 238, 1); }
.select-value-color-green { background-color: rgba(219, 237, 219, 1); }
.select-value-color-gray { background-color: rgba(227, 226, 224, 1); }
.select-value-color-opaquegray { background-color: rgba(255, 255, 255, 0.0375); }
.select-value-color-orange { background-color: rgba(250, 222, 201, 1); }
.select-value-color-brown { background-color: rgba(238, 224, 218, 1); }
.select-value-color-red { background-color: rgba(255, 226, 221, 1); }
.select-value-color-yellow { background-color: rgba(253, 236, 200, 1); }
.select-value-color-blue { background-color: rgba(211, 229, 239, 1); }

.checkbox {
	display: inline-flex;
	vertical-align: text-bottom;
	width: 16;
	height: 16;
	background-size: 16px;
	margin-left: 2px;
	margin-right: 5px;
}

.checkbox-on {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
}

.checkbox-off {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
}
	
</style></head><body><article id="e8710fd4-0e89-4aca-baed-a3cfb2b96e47" class="page sans Notion" style="width: 100%; padding: 0px;"><div class="page-body"><h2 id="ee804954-3c1c-4287-ac60-212b9256dc77" class=""><details open=""><summary><mark class="highlight-blue">8.1</mark> Exceptions</summary></details></h2><div class="indented"><ul id="c401b7f9-bad7-4b78-9d2c-7aa1dfbec09c" class="toggle"><li><details open=""><summary><strong>Exception &amp; Exception handler</strong></summary><p id="71f104c6-4d7d-442e-9b7f-927b185e46ac" class="">An <strong>exception </strong>is an <strong>abrupt change in the control flow</strong> in response to some change in the processor’s state.</p><p id="0e38e601-4e4d-4691-b46b-e5b7486128e9" class="">The <strong>state </strong>is encoded in various bits and signals inside the processor. </p><p id="d659382b-18b1-4755-8973-e20b45d59200" class="">The <strong>event </strong>is the <strong>change in state</strong>. </p><p id="d78293d4-1565-4b84-9b7d-da343f4ac035" class="">Processor detects that the event has occurred → Processor makes an <strong>indirect procedure call</strong> through an <strong>exception table</strong> to an OS subroutine (<strong>exception handler</strong>). </p><p id="7785ffc8-6c29-4851-833f-b98334695193" class="">When the <strong>exception handler</strong> finishes processing, one of 3 things happens depending on the type of event :</p><ol type="1" id="e3465356-137a-4d45-8180-723f56d8d16d" class="numbered-list" start="1"><li>The handler returns control to the <strong>current instruction</strong>, the instruction that was executing when the event occurred.</li></ol><ol type="1" id="ee47d672-02ee-472d-95a6-9e1928f8d348" class="numbered-list" start="2"><li>The handler returns control to the <strong>next instruction</strong>, the instruction that would have executed next had not the exception not occurred.</li></ol><ol type="1" id="54f78dc0-7e58-4bb2-bfc8-9bafef6ecd60" class="numbered-list" start="3"><li> The handler <strong>aborts </strong>the interrupted program.</li></ol></details></li></ul><ul id="04ec2e3d-8aa2-40d1-9259-2bd337025c3f" class="toggle"><li><details open=""><summary><strong>Exception Handling</strong></summary><p id="dbf13233-cf0c-4115-9a73-6cf928307de0" class="">Each type of possible exception in a system is assigned a unique nonnegative integer <strong>exception number</strong>. </p><p id="550c3a7d-e150-4bbc-96d5-b3f6e6068ad9" class="">The<strong> exception table’s entry </strong><strong><em>k</em></strong><strong> </strong>contains the <strong>address of the handler</strong> for exception<strong> </strong><strong><em>k</em></strong>.</p><ul id="c911ceb1-8533-4d2e-b69c-89484559cde0" class="bulleted-list"><li style="list-style-type:disc"><strong>Exception handling</strong></li></ul><figure id="c2b90632-6d89-4467-b371-ad104e6cc464" class="image"><a href="/assets/images/CSAPP-8/Untitled.png"><img style="width:576px" src="/assets/images/CSAPP-8/Untitled.png"/></a></figure><ol type="1" id="0587a880-d7a4-4494-8fb8-c59de308f8dd" class="numbered-list" start="1"><li>The processor detects that an event has occurred</li></ol><ol type="1" id="636de53f-9b4e-4f14-adbc-b8ee2fffc26c" class="numbered-list" start="2"><li>The processor determines the corresponding exception number <em>k</em>.</li></ol><ol type="1" id="fd60cd37-84f6-4fa0-bbdf-6a970ee1a9fc" class="numbered-list" start="3"><li>The processor triggers the exception by making an <strong>indirect procedure call</strong> to the corresponding handler <strong>through entry </strong><strong><em>k</em></strong><strong> of the exception table</strong>.<p id="f123d859-2882-4c55-9b85-34351d611136" class="">The <strong>starting address of exception table</strong> is contained a special CPU register called the <strong>exception table base register</strong>.</p></li></ol><ul id="02d33ec9-2419-4e3c-9f0f-7003715e0c9f" class="bulleted-list"><li style="list-style-type:disc"><strong>Exception’s differences to a procedure call</strong><ul id="d045bf7b-753c-4a5d-9a57-94b088ec6781" class="bulleted-list"><li style="list-style-type:circle">For both exception &amp; procedure call, the processor pushes a return address on the stack before jumping to the handler. However, the <strong>exception’s return address</strong> is either <strong>the current instruction</strong> or <strong>the next instruction</strong> depending on the class of exception.</li></ul><ul id="48d71c7e-93ba-4a4a-a1b1-7d876a5c48ab" class="bulleted-list"><li style="list-style-type:circle">The processor also pushes some <strong>additional processor state</strong> onto the stack that will be necessary to restart the interrupted program.</li></ul><ul id="8debef64-7507-43fc-9390-2451bc61b3ec" class="bulleted-list"><li style="list-style-type:circle">When control is being transferred from a user program to the kernel, the return address &amp; processor states are pushed onto the <strong>kernel’s stack</strong>.</li></ul><ul id="443d03cb-185b-4dc9-a3ec-a7ea3e40f414" class="bulleted-list"><li style="list-style-type:circle">Exception handlers run in <strong>kernel mode</strong> - they have complete access to all system resources.</li></ul></li></ul></details></li></ul><ul id="6a938407-a790-4fa0-88e3-17bf39596de3" class="toggle"><li><details open=""><summary><strong>Classes of Exceptions</strong></summary><ul id="90ac2733-ae5e-4811-8271-32fc3661610e" class="bulleted-list"><li style="list-style-type:disc"><strong>Interrupts</strong><figure id="3ef8b0bf-3995-4a4e-9ba8-2415118ae4b7" class="image"><a href="/assets/images/CSAPP-8/Untitled%201.png"><img style="width:384px" src="/assets/images/CSAPP-8/Untitled%201.png"/></a></figure><ul id="422680c8-3354-4fd2-9fd3-974032f1b056" class="bulleted-list"><li style="list-style-type:circle"><strong>Interrupts </strong>occur <strong>asynchronously </strong>as a result of <strong>signals from I/O devices</strong> that are external to the processor. (<em>example : network adapters, disk controllers, &amp; timer chips</em>) </li></ul><ol type="1" id="3af8f8cc-b83f-489e-89c9-e024033b01ff" class="numbered-list" start="1"><li><strong>I/O devices</strong> interrupts by <strong>signaling a pin</strong> on the processor chip and placing the <strong>exception number</strong> onto the system bus.</li></ol><ol type="1" id="90611d38-121a-4f20-b8ee-c5eed815020a" class="numbered-list" start="2"><li><strong>After the current instruction finishes executing</strong>, the processor notices that the interrupt pin has gone high.</li></ol><ol type="1" id="326c5a24-c388-4780-9d03-d612e8562756" class="numbered-list" start="3"><li>The processor reads the <strong>exception number</strong> from the system bus, and then calls the appropriate <strong>interrupt handler</strong>.</li></ol><ol type="1" id="7e7aa6d1-9f90-4b4e-9c4d-96c23814348c" class="numbered-list" start="4"><li>When the handler returns, it returns control to the <strong>next instruction</strong>. - The program continues executing as if the interrupt had never happened.</li></ol></li></ul><ul id="877edf2e-be68-49fa-ba78-afd6ec8af9a4" class="bulleted-list"><li style="list-style-type:disc"><strong>Traps &amp; System Calls</strong><figure id="06d087a3-ced0-4d54-b582-ac6138963f60" class="image"><a href="/assets/images/CSAPP-8/Untitled%202.png"><img style="width:384px" src="/assets/images/CSAPP-8/Untitled%202.png"/></a></figure><ul id="458ea28e-62f2-43ae-bb62-24b6b773f1db" class="bulleted-list"><li style="list-style-type:circle"><strong>Traps </strong>are <strong>intentional exceptions</strong> that occur as a result of executing an instruction.</li></ul><ul id="b86d0d95-60ad-421b-97d2-e481183d0a5a" class="bulleted-list"><li style="list-style-type:circle">Traps return control to the <strong>next instruction</strong>.</li></ul><ul id="89adcd48-eea2-4db3-8213-a2d240d96f9c" class="bulleted-list"><li style="list-style-type:circle">The most important use of traps is to provide a procedure-like interface between user programs and the kernel, known as a <strong>system call</strong>.</li></ul><ul id="742ddaa6-3d6c-4c98-8330-a0b2e41db7d6" class="bulleted-list"><li style="list-style-type:circle">Processors provide a <code>syscall n</code> instruction that user programs can execute when they want to request service <em>n</em>. → <strong>Controlled access to kernel services</strong> is available.</li></ul><ul id="95776f71-16e7-4a27-8ae0-b500d2657158" class="bulleted-list"><li style="list-style-type:circle">Executing the <strong><code>syscall</code></strong><strong> instruction</strong> causes a <strong>trap </strong>to an exception handler that decodes the argument and calls the appropriate kernel routine.</li></ul><ul id="86c42e93-7304-4c4e-b2a5-5c02f271c8f0" class="bulleted-list"><li style="list-style-type:circle">A system call runs in <strong>kernel mode</strong> - it can execute privileged instructions &amp; access a stack defined in the kernel.</li></ul></li></ul><ul id="6b1fcc28-61ad-410e-a172-3b76d26f63bc" class="bulleted-list"><li style="list-style-type:disc"><strong>Faults</strong><figure id="8f1cd978-f52f-4624-bdaf-7824ddb6332a" class="image"><a href="/assets/images/CSAPP-8/Untitled%203.png"><img style="width:384px" src="/assets/images/CSAPP-8/Untitled%203.png"/></a></figure><ul id="c185bb22-f17a-4c3f-8bcf-83b518252407" class="bulleted-list"><li style="list-style-type:circle"><strong>Faults </strong>result from <strong>error conditions</strong> that a handler <strong>might be able to correct</strong>.</li></ul><ul id="567037cb-5dfe-4173-86ca-f273ef3014b4" class="bulleted-list"><li style="list-style-type:circle">If the handler is <strong>able to correct</strong> the error condition, it returns control to the <strong>faulting instruction</strong>. <strong>Otherwise</strong>, the handler returns to an <strong><code>abort</code></strong><strong> routine</strong> in the kernel that terminates the application program.</li></ul><ul id="1a764e98-9f7c-46ee-ac93-3a636695c8a0" class="bulleted-list"><li style="list-style-type:circle"><em>Example : Page fault exception</em></li></ul></li></ul><ul id="a8d74212-317f-4c75-80ad-1b852a5ba0b6" class="bulleted-list"><li style="list-style-type:disc"><strong>Aborts</strong><figure id="1b3b1990-b0a3-4472-a4a7-7aa97ff0bf4b" class="image"><a href="/assets/images/CSAPP-8/Untitled%204.png"><img style="width:384px" src="/assets/images/CSAPP-8/Untitled%204.png"/></a></figure><ul id="ad0c05be-8bf3-4b2b-9933-117b4ef86505" class="bulleted-list"><li style="list-style-type:circle"><strong>Aborts </strong>result from <strong>unrecoverable fatal errors</strong>, typically hardware errors.</li></ul><ul id="daa0ec87-8fdd-4b02-b6e4-c590b8df3bac" class="bulleted-list"><li style="list-style-type:circle">Abort handlers never return control to the application program - The handler returns control to an <strong><code>abort</code></strong><strong> routine</strong> that terminates the application program.</li></ul></li></ul></details></li></ul><ul id="019b3dc4-ce2f-442b-b67e-d7159bc454ab" class="toggle"><li><details open=""><summary><strong>Exceptions in Linux/x86-64 Systems</strong></summary><p id="c5f0f45e-d7dc-402c-b1ff-b88f849524ea" class="">There are up to <strong>256 different exceptions</strong> defined for x86-64 systems - Numbers from<strong> 0 to 31 </strong>correspond to exceptions defined by the <strong>Intel architects</strong>, and numbers <strong>32 to 255</strong> correspond to interrupts &amp; traps defined by <strong>OS</strong>.</p><ul id="2411c380-88e3-474a-9d63-8e2003d94d57" class="bulleted-list"><li style="list-style-type:disc"><strong>Linux/x86-64 Faults and Aborts</strong><ul id="2a257e32-ecb3-41f1-8900-bec5482c5571" class="bulleted-list"><li style="list-style-type:circle"><strong>Divde error</strong> : occurs when an application attempts to <strong>divide by 0 </strong>or when the <strong>result of a divide instruction is too big</strong> for the destination operand. → <strong>Abort</strong></li></ul><ul id="b634fed6-8748-4829-b26b-d4e5f77a0595" class="bulleted-list"><li style="list-style-type:circle"><strong>General protection fault </strong>: occurs for many reasons, usually because a program <strong>references an undefined area of VM</strong> or because the program attempts to <strong>write to a read-only text segment</strong>. → <strong>Abort</strong></li></ul><ul id="375498ba-c4ca-4a0c-9fd0-3ae69acce19e" class="bulleted-list"><li style="list-style-type:circle"><strong>Page fault</strong> : occurs when an instruction references a virtual address whose <strong>corresponding page is not resident in memory</strong> and must be retrieved from disk. → The handler <strong>maps the appropriate page of VM on disk into a page of physical memory</strong>, and then restarts the faulting instruction. → <strong>Fault</strong></li></ul><ul id="f2520c3a-6540-45bf-8f2c-76bbf4f51c8d" class="bulleted-list"><li style="list-style-type:circle"><strong>Machine check</strong> : occurs as a result of a <strong>fatal hardware error</strong> that is detected during the execution of the faulting instruction. → <strong>Abort</strong></li></ul></li></ul><ul id="2105adae-0c9c-43be-9584-e4ea09425466" class="bulleted-list"><li style="list-style-type:disc"><strong>Linux/x86-64 System Calls</strong><p id="0fe38158-3ac0-4917-8d56-09f8c0fe9b0e" class="">Each system call has a <strong>unique integer number</strong> that corresponds to an <strong>offset in a jump table</strong> in the kernel. (This jump table ≠ Exception table)</p><p id="7ec0cc1a-11dd-4594-91a4-dbbe3a8e16de" class="">C programs can invoke any system call directly by using the <code>syscall</code> function, but C standard library provides a <strong>wrapper functions</strong> for most system calls.</p><p id="ce6058d9-7c58-461f-b12d-47f88dd3a528" class="">All <strong>arguments </strong>to Linux system calls are passed through <strong>general-purpose registers</strong> rather than the stack. - <code>%rax</code> contains the syscall number, <code>%rdi</code>, <code>%rsi</code>, <code>%rdx</code>, <code>%r10</code>, <code>%r8</code>, and <code>%r9</code> contains up to six arguments. On return from the system call, <code>%rcx</code> and <code>r11</code> are destroyed, and <code>%rax</code> contains the <strong>return value</strong>. A <strong>negative return value</strong> (-4095 ~ -1) indicates an <strong>error </strong>corresponding to negative <code>errno</code>.</p><p id="3cb79769-5485-4a6d-921d-39c179524201" class="">
</p></li></ul></details></li></ul></div><h2 id="079cd3b1-0b4d-4111-8527-7cdb8f2f6ea6" class=""><details open=""><summary><mark class="highlight-blue">8.2</mark> Processes</summary></details></h2><div class="indented"><p id="9e0d946e-e76a-45d0-ba3f-9865d813184a" class=""><strong>Process </strong>is an instance of a program in execution.</p><p id="cb0dc2b0-bd53-4015-9851-4a94d0d3c14f" class="">Key abstractions that a process provides to the application :</p><ul id="873ff197-ef54-4ae0-81f4-a2301723ff7b" class="bulleted-list"><li style="list-style-type:disc">An <strong>independent logical control flow</strong> that provides the illusion that our program has exclusive use of the processor.</li></ul><ul id="012034b5-c363-486c-ad97-d9d2c030b2c8" class="bulleted-list"><li style="list-style-type:disc">A <strong>private address space</strong> that provides the illusion that our program has exclusive use of the memory system.</li></ul><ul id="5a6efb04-b57b-4f8b-945f-55ad7413088e" class="toggle"><li><details open=""><summary><strong>Logical Control Flow</strong></summary><p id="ebabbef7-d6aa-471f-b5db-b302330d598b" class="">The <strong>sequence of PC values</strong> is known as a<strong> logical control flow</strong>.</p><figure id="918ffe39-aa43-490c-9489-b658be284269" class="image"><a href="/assets/images/CSAPP-8/Untitled%205.png"><img style="width:288px" src="/assets/images/CSAPP-8/Untitled%205.png"/></a></figure><p id="f9e5ce6f-9f0b-4a45-ac93-1d88e7a04ca6" class="">Processes <strong>take turns </strong>using the processor - Each process executes a portion of its flow and then is <strong>preempted (temporarily suspended)</strong> while other processes take their turns. </p><p id="9fddb7d0-bb22-4cc1-bbc3-807d5acf6976" class=""><strong>Logical flows</strong> take many different forms in computer systems - Exception handlers, processes, signal handlers, threads, and Java processes.</p><p id="d921a201-feaf-4595-ae06-40523427d6c3" class="">Flows X and Y are <strong>concurrent </strong>with respect to each other ↔ X begins after Y begins and before Y finishes, or Y begins after X begins and before X finishes. (<em>example : process A &amp; B in the figure are concurrent.)</em></p><p id="165746da-99df-4d42-b3e3-19373031ac91" class=""><strong>Parallel flows</strong> refers to flows running concurrently <strong>on different processor cores or computers</strong>.</p></details></li></ul><ul id="017f5594-0d74-4f82-b07f-60f7d332efef" class="toggle"><li><details open=""><summary><strong>Private Address Space</strong></summary><figure id="f7e6d1b1-6361-4237-9dc7-50ab518aa478" class="image"><a href="/assets/images/CSAPP-8/Untitled%206.png"><img style="width:288px" src="/assets/images/CSAPP-8/Untitled%206.png"/></a></figure><p id="f53bad31-c3cf-453f-87bc-c8b478af4f52" class="">On a machine with <strong><em>n</em></strong><strong>-bit addresses</strong>, the <strong>address space</strong> is the set of <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span></span><span>﻿</span></span> possible addresses, 0, 1, ... , <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.747722em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></span><span>﻿</span></span>.</p><p id="4530c889-ba8f-4628-be85-12b1dc279fdd" class="">A process provides each program with its own <strong>private address space</strong> - a byte of memory associated with a particular address in the space <strong>can’t be read or written by any other process</strong> in general.</p><p id="fb8d209d-a013-466c-a300-8db872944ec0" class="">Each address space has the <strong>same general organization</strong>.</p><p id="07fccaeb-eb51-4254-8391-bfa21a32f2a8" class="">
</p></details></li></ul><ul id="461de016-f45f-49f8-a3d3-4d64bcb4f54f" class="toggle"><li><details open=""><summary><strong>User and Kernel Modes</strong></summary><p id="f709e825-4c12-40a6-a94d-8a26029fe9b7" class="">In typical processor, there is a <strong>mode bit</strong> in some control register that characterizes the <strong>privileges </strong>that the process currently enjoys.</p><ul id="0c1dce18-deef-4787-aa57-52db02674d57" class="bulleted-list"><li style="list-style-type:disc"><strong>Kernel mode</strong><ul id="9123834d-4475-45ad-9d62-2c21b2f72a0c" class="bulleted-list"><li style="list-style-type:circle">When the mode bit is <strong>set</strong>, the process is running in <strong>kernel mode</strong>.</li></ul><ul id="4710040f-3f04-4e7b-b549-3d4f0b9e6a10" class="bulleted-list"><li style="list-style-type:circle">The process in kernel mode can <strong>execute any instruction</strong> in the instruction set &amp; <strong>access any memory location</strong> in the system.</li></ul></li></ul><ul id="19acc43c-dac5-4946-a4d3-9096fad10b24" class="bulleted-list"><li style="list-style-type:disc"><strong>User mode</strong><ul id="56ba2f35-45d8-476c-9a0f-c9cd01adecb6" class="bulleted-list"><li style="list-style-type:circle">When the mode bit is <strong>not set</strong>, the process is running in <strong>user mode</strong>.</li></ul><ul id="3260e3e2-ea89-4991-ab64-ba82c6036dc5" class="bulleted-list"><li style="list-style-type:circle">The process in user mode is <strong>not </strong>allowed to execute <strong>privileged instructions</strong>, change the <strong>mode bit</strong>, initiate an I/O operation, or <strong>reference code or data in the kernel area</strong>. Any such attempt results in a <strong>fatal protection fault</strong>. </li></ul><ul id="997d2731-b522-44dc-97cf-2f9ea24bab0c" class="bulleted-list"><li style="list-style-type:circle">User programs must access kernel code &amp; data via the <strong>system call</strong> interface.</li></ul><ul id="eef1a80d-ed76-4392-a852-a475a21b95a6" class="bulleted-list"><li style="list-style-type:circle">The only way for the process to change from user mode to kernel mode is via an <strong>exception </strong>such as <strong>interrupt, a fault, or a trapping system call</strong>. - When the handler is called, <strong>the handler runs in the kernel mode</strong>. When it returns to the application code, the processor’s mode changes back to user mode.</li></ul><ul id="53d888d8-899f-429b-9211-2e5e4609d9a6" class="bulleted-list"><li style="list-style-type:circle">Linux provides <strong><code>/proc</code></strong><strong> filesystem</strong>, that allows user mode processes to <strong>access the contents of kernel data structures</strong>. The <code>/proc</code> filesystem exports the contents of many kernel data structures as a text files that can be read by user programs.  </li></ul><p id="f2f97e90-4b24-431d-846b-52ee33ad58f3" class="">
</p></li></ul></details></li></ul><ul id="b491e679-0225-425a-8501-96628327615d" class="toggle"><li><details open=""><summary><strong>Context Switches</strong></summary><ul id="08511cbc-e9d4-4369-9bd9-291577801265" class="bulleted-list"><li style="list-style-type:disc"><strong>Context</strong><ul id="176e087f-21c5-44a8-97de-0c3e5152cf22" class="bulleted-list"><li style="list-style-type:circle">The <strong>context </strong>is the state that the kernel needs to <strong>restart a preempted process</strong>.</li></ul><ul id="6848f4a1-596d-457c-8cae-4f1bd1fcf2a9" class="bulleted-list"><li style="list-style-type:circle">The context consists of the values of the objects such as :<ul id="9599ba87-948d-4a64-81f4-7def2f5a9a04" class="bulleted-list"><li style="list-style-type:square">General-purpose registers</li></ul><ul id="46938b62-b3de-4eea-8922-065d8ce92093" class="bulleted-list"><li style="list-style-type:square">The floating-point registers</li></ul><ul id="66b6b0b8-e8c5-4fcb-bb60-9acbb2b6adef" class="bulleted-list"><li style="list-style-type:square">The PC</li></ul><ul id="7b8bc638-3a7d-4c6e-ac21-0fbe22779561" class="bulleted-list"><li style="list-style-type:square">User’s stack</li></ul><ul id="ef39dbaf-cea5-47ac-a59e-565c0a443fd3" class="bulleted-list"><li style="list-style-type:square">Status registers</li></ul><ul id="56c8c0a2-c7f4-4abf-9b6d-900332c57e2e" class="bulleted-list"><li style="list-style-type:square">Kernel’s stack</li></ul><ul id="18ea3fb9-0564-40d3-8e84-908f6846287c" class="bulleted-list"><li style="list-style-type:square">A <strong>page table</strong> that characterizes the address space</li></ul><ul id="7d74d3d7-be7d-468b-9946-d60980d2bcfb" class="bulleted-list"><li style="list-style-type:square">A <strong>process table</strong> that contains information about the current process</li></ul><ul id="89b1c104-e7f6-4095-bf87-85e961f528cf" class="bulleted-list"><li style="list-style-type:square">A <strong>file table</strong> that contains information about the files that the process has opened.</li></ul></li></ul></li></ul><ul id="ab5c09d7-e79d-41b5-b1f5-f9a7bafaf4c6" class="bulleted-list"><li style="list-style-type:disc"><strong>Context Switch</strong><ul id="62f3e877-1a14-4856-be88-d9362179253c" class="bulleted-list"><li style="list-style-type:circle">The kernel can decide to <strong>preempt the current process</strong> and <strong>restart a previously preempted process</strong> → <strong>Scheduling</strong></li></ul><ul id="7924273c-981a-4861-9a28-ab0e8f44db3b" class="bulleted-list"><li style="list-style-type:circle">The kernel <strong>transfers control</strong> to the new process using a <strong>context switch</strong> :<ol type="1" id="11c521ea-20ce-48c4-97d8-13f60b22a0c2" class="numbered-list" start="1"><li><strong>Saves </strong>the context of the <strong>current process</strong></li></ol><ol type="1" id="54441626-22e2-4317-8b92-49cd0055249a" class="numbered-list" start="2"><li><strong>Restores </strong>the saved context of some <strong>previously preempted process</strong></li></ol><ol type="1" id="5d7bf9dc-1836-40e6-9b7a-42e0cb3b5c77" class="numbered-list" start="3"><li><strong>Passes control </strong>to this newly restored process</li></ol></li></ul><ul id="98fc9a0d-c4b8-4135-9762-609eafa189f3" class="bulleted-list"><li style="list-style-type:circle">A context switch can occur if the <strong>system call blocks</strong> because it is waiting for some event to occur.</li></ul><ul id="abe8c5a5-62f5-4640-964a-9be9f7029920" class="bulleted-list"><li style="list-style-type:circle">A context switch can occur as a result of an <strong>interrupt</strong>. (<em>example : Periodic timer interrupts</em>)</li></ul></li></ul><ul id="fda7a839-ac75-40dd-82d8-97b9381d87ed" class="bulleted-list"><li style="list-style-type:disc"><strong>Example of Context Switch</strong><figure id="06f9ec57-a235-412a-b791-3ffda5c5af9e" class="image"><a href="/assets/images/CSAPP-8/Untitled%207.png"><img style="width:480px" src="/assets/images/CSAPP-8/Untitled%207.png"/></a></figure><ul id="39ea899b-e72e-4414-b5ef-31c42a563cc5" class="bulleted-list"><li style="list-style-type:circle">Process A traps to the kernel by executing a <code>read</code> <strong>system call</strong>.</li></ul><ul id="d145fd64-af63-42bf-b1ec-d69d97b24d26" class="bulleted-list"><li style="list-style-type:circle">The DMA transfer will <strong>take a relatively long time</strong> → The kernel performs a <strong>context switch</strong> from process A to B.</li></ul><ul id="f9163405-4e1f-4dd1-ba64-a2df2f248074" class="bulleted-list"><li style="list-style-type:circle">During the <strong>context switching</strong>, the kernel is executing instructions <strong>in kernel mode</strong> on behalf of process A. Then at some point it begins executing instructions on behalf of process B still <strong>in kernel mode</strong>.</li></ul><ul id="a6b8e41b-ca99-4d51-95a4-e35f3c4ebf1c" class="bulleted-list"><li style="list-style-type:circle">After the switch, the kernel is executing instructions <strong>in user mode</strong> on behalf of process B.</li></ul><ul id="68ca6275-852c-4a2d-8e67-7a3566f0c19d" class="bulleted-list"><li style="list-style-type:circle">The disk sends an <strong>interrupt </strong>to signal that data have been transferred from disk to memory. → The kernel performs a <strong>context switch</strong> from process B to A.</li></ul><p id="36a7039b-aa01-4384-9266-45b5e7a768f9" class="">
</p></li></ul></details></li></ul></div><h2 id="ccfdf6ef-0332-458c-933f-609865b50baf" class=""><details open=""><summary><mark class="highlight-blue">8.3</mark> System Call Error Handling</summary></details></h2><div class="indented"><p id="c8a0076d-ab9c-4455-a309-1963928b210f" class=""><strong>Unix system-level functions</strong> return<strong> -1 on error</strong>, and set the global integer variable <strong><code>errno</code></strong><strong> </strong>to indicate what went wrong.</p><ul id="3f9d8222-ccd8-4d55-9d53-dcd19ad39916" class="bulleted-list"><li style="list-style-type:disc">Example of checking error when calling <code>fork</code> function :</li></ul><pre id="005b85e5-5c79-42aa-a917-d34202af0eef" class="code"><code>if ((pid = fork()) &lt; 0) {
	fprintf(stderr, &quot;fork error:  %s\n&quot;, strerror(errno));
	exit(0);
}</code></pre><p id="83516286-00a5-4fc1-ac56-f4dd88b0f49d" class=""><strong><code>strerror</code></strong><strong> </strong>returns a text string that describes the error associated with a value of <code>errno</code>.</p><p id="c3c07245-8f3e-4fe3-981d-66a978827581" class="">We can define <strong>error-reporting function</strong> to simplify the code :</p><pre id="e965608d-a949-4c55-99da-efa1a93aea23" class="code"><code>void unix_error(char *msg){
	fprintf(stderr, &quot;%s: %s\n&quot;, msg, strerror(errno));
	exit(0);
}</code></pre><p id="7d838c7a-25ee-41f5-a62e-d23fd1413531" class="">We can simplify the code further by using <strong>error-handling wrappers</strong> :</p><pre id="0f492b2c-d8f7-4db5-8080-bcb0dae6c49d" class="code"><code>pid_t Fork(void){
	pid_t pid;
	if ((pid = fork()) &lt; 0)
		unix_error(&quot;Fork error&quot;);
	return pid;
}

pid = Fork();</code></pre></div><h2 id="81f85871-ea97-4fb1-9446-0381318b0250" class=""><details open=""><summary><mark class="highlight-blue">8.4</mark> Process Control</summary></details></h2><div class="indented"><ul id="1a9aa58a-6717-4597-994f-fa3cd16d932f" class="toggle"><li><details open=""><summary><strong>Obtaining Process IDs - </strong><strong><code>getpid</code></strong><strong>, </strong><strong><code>getppid</code></strong></summary><pre id="09361e24-121a-4c5c-a9a8-e14aabff70ed" class="code"><code>#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;

pid_t getpid(void);
pid_t getppid(void);</code></pre><p id="00cc2e31-ae36-4ccf-a149-f3d7ee2b1565" class="">Each process has a unique positive process ID (<strong>PID</strong>). </p><p id="daefb1e2-8d9a-4540-9d7b-61b6ba2c9b60" class=""><code>getpid</code> returns the PID of the <strong>calling process</strong>. <code>getppid</code> returns the PID of its <strong>parent</strong>.</p><p id="49d9bdc4-9a23-4a2d-b914-a5c93bfcaed5" class="">Type <code>pid_t</code> is defined in <code>types.h</code> as an <strong>int</strong>.</p></details></li></ul><ul id="c5500d95-84ad-4c9e-b119-bcd9308a76cd" class="toggle"><li><details open=""><summary><strong>Creating and Terminating Processes - </strong><strong><code>fork</code></strong><strong>, </strong><strong><code>exit</code></strong></summary><ul id="2b55db6e-d234-4390-a07b-d66a1295f624" class="bulleted-list"><li style="list-style-type:disc">States of process<p id="5381e637-7604-4aa3-a45b-1aedfaa23d33" class="">A process can be in one of three states :</p><ul id="b1f62189-29b2-4471-8bba-5fe477e44075" class="bulleted-list"><li style="list-style-type:circle">Running : The process is either executing on the CPU or waiting to be executed and will eventually be scheduled by kernel.</li></ul><ul id="650d7d25-4419-4987-95df-c2c0832a8607" class="bulleted-list"><li style="list-style-type:circle">Stopped : The execution of the process is suspended &amp; won’t be scheduled.</li></ul><ul id="bdf5087e-fc72-494e-9e8a-340a5ff0b104" class="bulleted-list"><li style="list-style-type:circle">Terminated : The process is stopped permanently. A process becomes terminated for one of three reasons :<ul id="895a6d81-615a-4e6d-826b-8246e25443c8" class="bulleted-list"><li style="list-style-type:square">receiving a signal whose default action is to terminate the process</li></ul><ul id="d70d810b-a322-42b0-a034-f7ed79eb2932" class="bulleted-list"><li style="list-style-type:square">returning from the main routine</li></ul><ul id="bfab1c83-dcca-4f98-b5bb-9778ce9822ac" class="bulleted-list"><li style="list-style-type:square">calling the <code>exit</code> function</li></ul></li></ul></li></ul><ul id="f0eba163-e49b-4313-9574-a8410c097029" class="bulleted-list"><li style="list-style-type:disc"><strong><code>exit</code></strong><strong> - Terminating Process</strong><pre id="b02a5795-c303-44dd-b406-21585d1ea40b" class="code"><code>#include &lt;stdlib.h&gt;

void exit(int status);</code></pre><p id="5c450dfd-75db-4741-963a-f746784dbef2" class=""><code>exit</code> terminates the process with an exit status of <code>status</code>.</p></li></ul><ul id="b2939096-f9f3-405f-8ec3-0160599b6119" class="bulleted-list"><li style="list-style-type:disc"><strong><code>fork</code></strong><strong> - Creating Process</strong><p id="6d13c369-2c39-4cb3-a941-5095cda08124" class="">A parent process <strong>creates a new running child process</strong> by calling the <strong><code>fork</code></strong>.</p><pre id="3e715bab-03cf-490c-922c-5cb3eed5c68d" class="code"><code>#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;

pid_t fork(void);</code></pre><ul id="2025e3bc-4271-4059-8291-a26f26c311ed" class="bulleted-list"><li style="list-style-type:circle">The child gets an <strong>identical copy of parent’s user-level virtual address space</strong> including the code &amp; data segments, heap, shared libraries, and user stack.</li></ul><ul id="a5cb2ed3-3870-4eb3-b455-2f56d4d6c067" class="bulleted-list"><li style="list-style-type:circle">The child gets an <strong>identical copies of the parent’s</strong> <strong>open file descriptors</strong> - the child can <strong>read and write any files that were open in the parent</strong> when it called <code>fork</code>.</li></ul><ul id="604a8910-2b7e-4854-ad13-cb19b644f683" class="bulleted-list"><li style="list-style-type:circle">The child and parent have <strong>different PIDs</strong>.</li></ul><ul id="b48f2038-eca5-4434-a32d-1033bd644fe9" class="bulleted-list"><li style="list-style-type:circle"><code>fork</code> is <strong>called once</strong> but it <strong>returns twice</strong>.<ul id="91734625-a120-4630-8fbe-8b7919f31e57" class="bulleted-list"><li style="list-style-type:square">In the <strong>parent</strong>, <code>fork</code> returns <strong>the PID of the child</strong>.</li></ul><ul id="12264453-9bbf-4906-8ed6-7bee2c968461" class="bulleted-list"><li style="list-style-type:square">In the <strong>child</strong>, <code>fork</code> returns a value of<strong> 0</strong>.</li></ul></li></ul><ul id="1436308b-06f9-4753-9931-fcdcbaba0020" class="bulleted-list"><li style="list-style-type:circle">Example code of <code>fork</code><pre id="fd0240c6-64cb-49d9-b921-e43118576a46" class="code"><code>int main(){
	pid_t pid;
	int x = 1;
	
	pid = Fork();
	if (pid == 0) { /* Child */
		printf(&quot;child : x=%d\n&quot;, ++x);
		exit(0);
	}
	
	/* Parent */
	printf(&quot;parent : x=%d\n&quot;, --x);
	exit(0);
}</code></pre><hr id="7df4a478-cbd6-47ac-9dac-cbe6e0e9b480"/><p id="7f939ef3-b7b7-45ee-8e43-1a6c2d2245ef" class=""><strong>Result : </strong></p><p id="8b3cbe10-415b-41fc-a484-295b3c66d6ae" class=""><code>parent : x = 0</code></p><p id="31f21fcf-91df-4b84-acb8-c09ef3b796ed" class=""><code>child : x = 2</code></p><hr id="8611f311-6043-4bbc-a441-2513bebe189e"/><ul id="608b0790-db80-4d43-9f67-d71127461688" class="bulleted-list"><li style="list-style-type:square">The instructions in the parent &amp; child’s logical control flows can be <strong>interleaved</strong> by the kernel in an arbitrary way → We can <strong>never make assumptions about the interleaving of the instructions</strong> in different processes.</li></ul><ul id="ccde362b-4b12-4fa9-b2a5-8bf2b244019c" class="bulleted-list"><li style="list-style-type:square">At the point <strong>immediately after the </strong><strong><code>fork</code></strong> returned in each process, the address space of each process is <strong>identical</strong>. </li></ul><ul id="15ec7d1e-1d4f-4e0f-9e76-c3992fcc16c8" class="bulleted-list"><li style="list-style-type:square">Since the parent and the child are separate processes, they each have their own <strong>private address spaces</strong> → Any <strong>subsequent changes</strong> the processes make to <code>x</code> are <strong>private </strong>and are<strong> not reflected in the memory of each other</strong>.</li></ul><ul id="1caf0d6a-4d66-4f5b-975c-99acd6120564" class="bulleted-list"><li style="list-style-type:square">Both parent and child print their output on the screen - <strong>The child inherits all of the parent’s open files</strong>.</li></ul><ul id="a1a513bb-28d7-4cea-b2a5-b2d0d805c159" class="bulleted-list"><li style="list-style-type:square">We can use <strong>process graph</strong> to understand the behavior of the processes :<figure id="beb6d8bb-07d1-44ef-b378-d33d730a3ca7" class="image"><a href="/assets/images/CSAPP-8/Untitled%208.png"><img style="width:384px" src="/assets/images/CSAPP-8/Untitled%208.png"/></a></figure><ul id="6cca8512-d9cd-42c8-8e5a-8e5c613acead" class="bulleted-list"><li style="list-style-type:disc">Any <strong>topological sort</strong> of the vertices in the process graph represents a <strong>feasible total ordering of the statements</strong> in the program.</li></ul></li></ul></li></ul></li></ul></details></li></ul><ul id="0836a970-a2c1-4643-bca7-c4ae92f2c198" class="toggle"><li><details open=""><summary><strong>Reaping Child Processes - </strong><strong><code>waitpid</code></strong><strong>, </strong><strong><code>wait</code></strong></summary><ul id="d3af10d0-c2cc-4d09-90eb-338e9bc0cd1c" class="bulleted-list"><li style="list-style-type:disc"><strong>Reaping Child Processes</strong><ul id="62d34ece-a19b-438b-9b01-987bf96529ec" class="bulleted-list"><li style="list-style-type:circle">When a process <strong>terminates</strong>, the process is <strong>not removed</strong> from the system <strong>immediately </strong>(<strong>zombie</strong>) - the process is kept around in a terminated state until it is <strong>reaped </strong>by its parent. </li></ul><ul id="70d34be3-686e-4ce7-bcdf-1d82f7b3c908" class="bulleted-list"><li style="list-style-type:circle">The parent <strong>reaps </strong>the terminated child → the kernel passes the <strong>child’s exit status</strong> to the parent &amp; <strong>discards the terminated process</strong>.</li></ul><ul id="b375a891-ee82-46d8-813a-a1133d16ba02" class="bulleted-list"><li style="list-style-type:circle">When a <strong>parent process terminates</strong>, the kernel arranges for the <strong><code>init</code></strong><strong> process</strong> to become the <strong>adopted parent</strong> for any orphaned children.<ul id="440941b6-a1cd-45fe-b398-dfa513aee1f8" class="bulleted-list"><li style="list-style-type:square"><strong><code>init</code></strong><strong> process</strong> is created by the kernel during system start-up, never terminates.</li></ul><ul id="0dc4891c-4d1b-4d8f-a930-64103c154da3" class="bulleted-list"><li style="list-style-type:square"><strong><code>init</code></strong><strong> process</strong> is the <strong>ancestor of every process</strong>.</li></ul><ul id="ebc84ff9-c066-47c3-9117-2a73acec1cd1" class="bulleted-list"><li style="list-style-type:square"><strong><code>init</code></strong> <strong>process </strong>has a <strong>PID of 1.</strong></li></ul><ul id="1aa306ac-e26a-4730-89d0-fb1f1ee275c6" class="bulleted-list"><li style="list-style-type:square">If a parent process <strong>terminates without reaping</strong> its zombie children, <strong><code>init</code></strong><strong> process reaps them</strong>.</li></ul></li></ul><ul id="33e97b04-6074-4410-a15c-9cd012928174" class="bulleted-list"><li style="list-style-type:circle">Long-running programs (servers or shells) should always reap their zombie children - or <strong>zombies will consume system memory resources</strong>.</li></ul></li></ul><ul id="b998ce3d-8add-439b-ae81-9d79e81a4f1f" class="bulleted-list"><li style="list-style-type:disc"><code>waitpid</code> - <strong>Waiting </strong>for children process to terminate or stop, then <strong>Reaping </strong>it<pre id="b0c9055a-9f34-4ab9-a2c1-39f3cb716145" class="code"><code>#include &lt;sys/types.h&gt;
#include &lt;sys/wait.h&gt;

pid_t waitpid(pid_t pid, int *statusp, int options);</code></pre><ul id="fd3194d9-50e2-4b0a-a353-58cfd711cd9b" class="bulleted-list"><li style="list-style-type:circle">When <strong><code>options</code></strong><strong> = 0,</strong> <code>waitpid</code> <strong>suspends execution of the calling process</strong> until a <strong>child process</strong> in its <strong>wait set</strong> <strong>terminates</strong>. If a process in the wait set has <strong>already terminated</strong>, then <code>waitpid</code> <strong>returns immediately</strong>.</li></ul><ul id="fbf7a384-282a-4e99-bec8-a759428c0078" class="bulleted-list"><li style="list-style-type:circle">When <strong><code>options</code></strong><strong> = 0,</strong> <code>waitpid</code> <strong>returns PID of the terminated child</strong> that cause <code>waitpid</code> to return. Then, the terminate child has been <strong>reaped </strong>&amp; the kernel removes the process.</li></ul><ul id="c3187a13-a91d-4a4e-8291-6603bd0b8738" class="bulleted-list"><li style="list-style-type:circle">Determining the Members of the <strong>Wait Set </strong>- determined by <strong><code>pid</code></strong><strong> argument</strong><ul id="454a84b7-530e-4bea-801b-14b5798aa8ef" class="bulleted-list"><li style="list-style-type:square"><strong><code>pid</code></strong><strong> &gt; 0 </strong>→ the wait set is a <strong>single child process</strong> whose PID is <code>pid</code>.</li></ul><ul id="0249f501-2f4c-4313-974e-d35246a1bdab" class="bulleted-list"><li style="list-style-type:square"><strong><code>pid</code></strong><strong> = -1</strong> → the wait set consists of <strong>all of the child processes</strong>.</li></ul></li></ul><ul id="73647f68-4974-4055-b632-a9d252307119" class="bulleted-list"><li style="list-style-type:circle"><strong>Modifying the Default Behavior</strong> - setting <strong><code>options</code></strong><strong> </strong>to combinations of <code>WNOHANG</code>, <code>WUNTRACED</code>, <code>WCONTINUED</code><ul id="d9f46db0-fe46-4987-b7af-2a526dc54686" class="bulleted-list"><li style="list-style-type:square"><strong><code>WNOHANG</code></strong><strong> </strong>: <strong>Return immediately</strong> with a<strong> return value of 0 </strong>if none of the child processes in the wait set has terminated yet. </li></ul><ul id="b040b8bf-6164-45e0-83c4-9d4e5f62a16e" class="bulleted-list"><li style="list-style-type:square"><strong><code>WUNTRACED</code></strong><strong> </strong>: Suspend execution of the calling process until a process in the wait set becomes either terminated or <strong>stopped</strong>. Return the PID of the terminated or <strong>stopped </strong>child.</li></ul><ul id="f76437a1-cbfb-40ab-8066-b44cb9db463c" class="bulleted-list"><li style="list-style-type:square"><strong><code>WCONTINUED</code></strong><strong> </strong>: Suspend execution of the calling process until a running process in the wait set is termianted or <strong>until a stopped process in the wait set has been resumed by the receipt of a </strong><strong><code>SIGCONT</code></strong><strong> signal</strong>.</li></ul><ul id="55ef3ebd-6911-4505-91bd-60ff1fe21376" class="bulleted-list"><li style="list-style-type:square">Can combine options -  <code>WNOHANG | WUNTRACED</code> : <strong>Return immediately</strong> with a <strong>return value of 0</strong> if none of the children in the wait set has <strong>stopped </strong>or terminated, or with a return value of PID of one of the <strong>stopped </strong>or terminated children. </li></ul></li></ul><ul id="b0fae027-504f-4259-ae90-8efafc06ff5e" class="bulleted-list"><li style="list-style-type:circle"><strong>Checking the Exit Status of a Reaped Child</strong><ul id="e3b5f025-4c4a-452b-b739-8667899cce68" class="bulleted-list"><li style="list-style-type:square">If <code>stautsp</code> is not NULL, <code>waitpid</code> encodes <strong>status information</strong> about the child in <strong><code>status</code></strong><strong> (=</strong><strong><code>*statusp</code></strong><strong>). </strong></li></ul><ul id="40a2be9c-b864-4c6a-b1d3-28ad93731b42" class="bulleted-list"><li style="list-style-type:square"><code>wait.h</code> defines macros for interpreting the <code>status</code> argument :<ul id="ea9f1837-9a0f-43a3-ac78-320095236061" class="bulleted-list"><li style="list-style-type:disc"><code>WIFEXITED(status)</code> : Returns true if the children terminated via a call to <code>exit</code> or a return.</li></ul><ul id="69fba4bf-1bdc-4639-994c-82704a444a00" class="bulleted-list"><li style="list-style-type:disc"><code>WEXITSTATUS(status)</code> : Returns the exit status of a normally terminated child. Only defined if <code>WIFEXITED</code> returned true.</li></ul><ul id="1d9cbd13-4937-4071-b3c5-be6cea6d0ef7" class="bulleted-list"><li style="list-style-type:disc"><code>WIFSIGNALED(status)</code> : Returns true if the child process terminated because of a signal that wasn’t caught.</li></ul><ul id="57c98cf9-01d2-40eb-a8f2-db6dd742da86" class="bulleted-list"><li style="list-style-type:disc"><code>WTERMSIG(status)</code> : Returns the number of the signal that caused the process to terminate. Only defined if <code>WIFSIGNALED</code> returned true.</li></ul><ul id="33312e11-0883-4bbf-b4c8-dc20f86d1725" class="bulleted-list"><li style="list-style-type:disc"><code>WIFSTOPPED(status)</code> : Returns true if the child that caused the return is currently stopped.</li></ul><ul id="ed425b0a-8afb-4a9e-81f4-0f1c2224b051" class="bulleted-list"><li style="list-style-type:disc"><code>WSTOPSIG(status)</code> : Returns the number of the signal that caused the child to stop. Only defined if <code>WIFSTOPPED</code> returned true.</li></ul><ul id="e1341146-6f83-43c9-9f13-9782c00b394f" class="bulleted-list"><li style="list-style-type:disc"><code>WIFCONTINUED(status)</code> : Returns true if the child process was restarted by receipt of a <code>SIGCONT</code> signal. </li></ul></li></ul></li></ul><ul id="8a5f361b-0b4c-4948-9d1c-db76f0ad9837" class="bulleted-list"><li style="list-style-type:circle">If the calling process has <strong>no children</strong>, <code>waitpid</code> returns <strong>-1</strong>, and sets <code>errno</code> to <strong><code>ECHILD</code></strong>.</li></ul><ul id="54aeebb1-5bd3-4d53-93d4-64fe056ce4ee" class="bulleted-list"><li style="list-style-type:circle">If the <code>waitpid</code> function was <strong>interrupted by a signal</strong>, it returns <strong>-1 </strong>and sets <code>errno</code> to <strong><code>EINTR</code></strong>. </li></ul></li></ul><ul id="c8ca5eb6-cfed-4a11-b7a7-c0c0fc59ef7b" class="bulleted-list"><li style="list-style-type:disc"><strong><code>wait</code></strong><strong> - Simpler version of </strong><strong><code>waitpid</code></strong><pre id="e3ec23b1-618a-4c3d-9777-861cd2ea3f6d" class="code"><code>#include &lt;sys/types.h&gt;
#include &lt;sys/wait.h&gt;

pid_t wait(int *statusp);</code></pre><p id="9303d352-1061-4992-8aec-cd21d7f6148e" class=""><code>wait(&amp;status)</code> is equivalent to <code>waitpid(-1, &amp;status, 0)</code>.</p></li></ul><ul id="c5b83eca-d4f9-4b2c-8eb7-963af14f28dd" class="bulleted-list"><li style="list-style-type:disc"><strong>Example code : Using </strong><strong><code>waitpid</code></strong><strong> to reap zombie children in no particular order</strong><pre id="2e1e47b3-ed53-4b20-a53f-46996617904e" class="code"><code>#include &quot;csapp.h&quot;
#define N 2

int main() {
	int status, i;
	pid_t pid;

	/* Parent creates N children */
	for (i = 0; i &lt; N; i++)
		if ((pid = Fork()) == 0) /* Child */ /* Line 11 */
			exit(100+i);

	/* Parent reaps N children in no particular order */
	while ((pid = waitpid(-1, &amp;status, 0)) &gt; 0) { /* Line 16 */
		if (WIFEXITED(status)) printf(&quot;child %d terminated normally with exit status=%d\n&quot;, pid, WEXITSTATUS(status)); 
		else printf(&quot;child %d terminated abnormally\n&quot;, pid);
	}

	/* The only normal termination is if there are no more children */
	if (errno != ECHILD) unix_error(&quot;waitpid error&quot;);

	exit(0);
}</code></pre><ul id="f62c96d4-3e0d-44dd-901b-9b14719c6083" class="bulleted-list"><li style="list-style-type:circle">The program reaps its children<strong> in no particular order</strong> → An example of <strong>nondeterministic </strong>behavior.</li></ul><ul id="a71e5047-dc48-4b5a-8753-f9cd8a9bc14f" class="bulleted-list"><li style="list-style-type:circle">To <strong>eliminate the nondeterminism</strong>, store the PIDs of its children in order, then wait for each child in the same order by <strong>calling </strong><strong><code>waitpid</code></strong><strong> with the appropriate PID</strong> in the first argument.<ul id="ae50a649-b317-467e-8312-d1b9dda47a4f" class="bulleted-list"><li style="list-style-type:square">line 11 → <code>if ((pid[i]  = Fork()) == 0)</code></li></ul><ul id="055084b3-cb25-4ed3-a801-2a45d24cfbe7" class="bulleted-list"><li style="list-style-type:square">line 16 → <code>while ((retpid = waitpid(pid[i++], &amp;status, 0)) &gt; 0) {</code></li></ul></li></ul></li></ul></details></li></ul><ul id="5bd90f8b-7ec7-4937-ac58-a9d98c976eda" class="toggle"><li><details open=""><summary><strong>Putting Processes to Sleep - </strong><strong><code>sleep</code></strong><strong>, </strong><code><strong>pause</strong></code></summary><ul id="4b66f548-e09c-4f97-b7e8-2b55da689e0c" class="bulleted-list"><li style="list-style-type:disc"><strong><code>sleep</code></strong><strong> - Suspending a process for a specified period of time</strong><pre id="dffdc2ad-0e5b-491c-84b7-f388817d33f7" class="code"><code>#include &lt;unistd.h&gt;

usigned int sleep(unsigned int secs);</code></pre><p id="24d6358f-f967-46ab-a119-ac8fd2e67665" class=""><strong><code>sleep</code></strong><strong> </strong>returns<strong> 0 </strong>if the requested time has <strong>elapsed</strong>.</p><p id="a7470a09-fc23-4b5e-bd98-d7018e33e8c3" class=""><strong><code>sleep</code></strong><strong> </strong>returns <strong>the number of seconds still left</strong> <strong>to sleep</strong> if <code>sleep</code> returns <strong>prematurely </strong>being interrupted by a <strong>signal</strong>.</p></li></ul><ul id="802c09cb-4d5d-4c8b-bff3-e971374c5994" class="bulleted-list"><li style="list-style-type:disc"><strong><code>pause</code></strong><strong> - Putting the calling function to sleep until a signal is received by the process.</strong><pre id="6d89961d-5a37-4127-901e-def67e7043ae" class="code"><code>#include &lt;unistd.h&gt;

int pause(void);</code></pre><p id="98ef4502-bc5a-42ef-8b3e-94b9a932f751" class=""><code>pause</code> always return<strong> -1</strong>.</p></li></ul></details></li></ul><ul id="b89f9e93-ab8d-45cb-92ee-5f1bd19a6c2b" class="toggle"><li><details open=""><summary><strong>Loading &amp; Running Programs - </strong><strong><code>execve</code></strong></summary><ul id="fd4da2e5-44da-4c83-9dbd-593e29527192" class="bulleted-list"><li style="list-style-type:disc"><strong><code>excve</code></strong><strong> - Loading &amp; Running a new program in the context of the current process</strong><pre id="e1238cd8-a6ad-4e7f-a2d9-10fbe0c65421" class="code"><code>#include &lt;unistd.h&gt;

int execve(const char *filename, const char *argv[], const char *envp[]);</code></pre><ul id="befe8cc4-248d-4d4b-9310-13f5a66d56d7" class="bulleted-list"><li style="list-style-type:circle"><code>execve</code> <strong>loads &amp; runs the executable object file </strong><strong><code>filename</code></strong> with the <strong>argument list</strong> <code>argv</code> and the <strong>environment list</strong> <code>envp</code>.</li></ul><ul id="9ba1568a-e26b-429c-a0e2-e00313c3fb4b" class="bulleted-list"><li style="list-style-type:circle"><code>execve</code> returns only if there is an error - In normal operation, <code>execve</code> <strong>never returns</strong>.</li></ul><ul id="5edd2853-37b9-46e2-a3ec-34377f5501f2" class="bulleted-list"><li style="list-style-type:circle"><strong>Argument list </strong><strong><code>argv</code></strong><figure id="d92bed2f-b6ad-4590-bc70-c1fa25b0fc15" class="image"><a href="/assets/images/CSAPP-8/Untitled%209.png"><img style="width:384px" src="/assets/images/CSAPP-8/Untitled%209.png"/></a></figure><ul id="d7b65f06-c2c5-4659-92b0-e8617abe3eb9" class="bulleted-list"><li style="list-style-type:square"><code>argv</code> points to a null-terminated <strong>array of pointers</strong>, each of which points to an <strong>argument string</strong>.</li></ul><ul id="593cff38-8b1f-45c5-a12d-c554a35a4a68" class="bulleted-list"><li style="list-style-type:square"><code>argv[0]</code> is the <strong>name </strong>of the <strong>executable object file</strong>.</li></ul></li></ul><ul id="7de9c0a8-c0ae-4b4f-be0c-2df462f357bf" class="bulleted-list"><li style="list-style-type:circle"><strong>Environment variable list </strong><strong><code>envp</code></strong><figure id="28b90bf9-6e81-4ffc-8d44-35e99f5b9fef" class="image"><a href="/assets/images/CSAPP-8/Untitled%2010.png"><img style="width:384px" src="/assets/images/CSAPP-8/Untitled%2010.png"/></a></figure><ul id="4d504b58-d3f4-4226-a944-f1e45b8569a1" class="bulleted-list"><li style="list-style-type:square"><code>envp</code> points to a null-terminated <strong>array of pointers</strong> to <strong>environment variable strings</strong>, each of which is a name-value pair of the form <strong>‘name = value’</strong>.</li></ul></li></ul></li></ul><ul id="cd7fef96-07eb-4335-a54a-dbe71572d2e9" class="bulleted-list"><li style="list-style-type:disc"><strong>Executing </strong><strong><code>main</code></strong><strong> after </strong><strong><code>execve</code></strong><strong> loads </strong><strong><code>filename</code></strong><ul id="bb9a0614-b712-4528-8bcd-329fcf383939" class="bulleted-list"><li style="list-style-type:circle">After <code>execve</code> loads <code>filename</code>, <code>execve</code> calls the <strong>start-up code</strong> that sets up the stack &amp; passes control to the <strong>main routine</strong> of the new program.</li></ul><ul id="5d8ea1b5-664e-4768-8b48-1c72c4731720" class="bulleted-list"><li style="list-style-type:circle">The <strong>main routine</strong> has a form <code>int main(int argc, char **argv, char **envp);</code>, or equivalently <code>int main(int argc, char *argv[], char *envp[]);</code>.</li></ul><figure id="a0624e50-e154-457a-8db2-df6e8d8ff9c4" class="image"><a href="/assets/images/CSAPP-8/Untitled%2011.png"><img style="width:384px" src="/assets/images/CSAPP-8/Untitled%2011.png"/></a></figure><ul id="a5f8e501-f6b6-447d-b891-6fd5faa8dc58" class="bulleted-list"><li style="list-style-type:circle">The organization of <strong>user stack</strong> when a new program starts (From bottom to top)<ol type="1" id="e46fe72a-0c0e-4d94-90ba-2001a2d2db6b" class="numbered-list" start="1"><li>The <strong>argument &amp; environment strings</strong> are at the bottom of the stack (the highest address).</li></ol><ol type="1" id="9a3e4150-4fbf-4fe1-8eef-78da9b146aa4" class="numbered-list" start="2"><li><strong>Environment array</strong> <code>envp[]</code>. The global variable <strong><code>environ</code></strong><strong> </strong>points to the first of these pointers, <code>envp[0]</code>.</li></ol><ol type="1" id="1b4bbf56-1a25-43a2-900f-58ac411f6485" class="numbered-list" start="3"><li><strong>Argument array </strong><code>argv[]</code>.</li></ol><ol type="1" id="3d19a438-1f8b-4b28-b311-d6d2c6f42a77" class="numbered-list" start="4"><li>Stack frame for the <strong>system start-up function</strong>, <code>libc_start_main</code>.</li></ol></li></ul><ul id="885f13a7-9bb4-40fa-ba4a-6438773ce9a4" class="bulleted-list"><li style="list-style-type:circle">There are 3 arguments to <code>main</code>, each stored in a register :<ul id="82d99926-5ff0-485a-86d8-bff77e6d626a" class="bulleted-list"><li style="list-style-type:square"><strong><code>argc</code></strong> gives <strong>the number of non-null pointers</strong> in the <code>argv[]</code> array.</li></ul><ul id="446d15fa-530c-4871-98aa-b61bfa3f2635" class="bulleted-list"><li style="list-style-type:square"><strong><code>argv</code></strong><strong> </strong>points to the first entry in the <code>argv[]</code> array.</li></ul><ul id="11ac8ccf-e39e-4459-bbb3-d08ade538a30" class="bulleted-list"><li style="list-style-type:square"><strong><code>envp</code></strong><strong> </strong>points to the first entry in the <code>envp[]</code> array.</li></ul></li></ul></li></ul><ul id="5d651378-10f6-4000-b4d8-5b55407baaec" class="bulleted-list"><li style="list-style-type:disc"><strong><code>getenv</code></strong><strong>, </strong><strong><code>setenv</code></strong><strong>, </strong><strong><code>unsetenv</code></strong><strong> - Manipulating the environment array</strong><pre id="8d346bb0-4266-4022-a1b5-6427e88b62b7" class="code"><code>#include &lt;stdlib.h&gt;

char *getenv(const char *name);

int setenv(const char *name, const char *newvalue, int overwrite);

void unsetenv(const char *name);</code></pre><ul id="34038fd3-27c5-4c3b-b08d-0254603784d2" class="bulleted-list"><li style="list-style-type:circle"><strong><code>getenv</code></strong><strong> searches </strong>the <code>envp[]</code> for a string ‘<code>name</code>=value’. If found, it returns a pointer to <code>value</code>; otherwise, it returns <code>NULL</code>.</li></ul><ul id="1f325955-526f-4be8-b593-6f858f4b536c" class="bulleted-list"><li style="list-style-type:circle"><strong><code>unsetenv</code></strong> <strong>deletes </strong>the string of the form ‘<code>name</code>=oldvalue’.</li></ul><ul id="c58b319b-d5b7-42b2-8299-8b4a8bd042e6" class="bulleted-list"><li style="list-style-type:circle"><strong><code>setenv</code></strong><strong> replaces </strong>oldvalue with <code>newvalue</code>, only if <code>overwrite</code> is nonzero. If <code>name</code> doesn’t exist, <code>setenv</code> <strong>adds </strong>‘<code>name</code>=newvalue’ to the array.</li></ul></li></ul></details></li></ul><ul id="548441b2-349d-4139-bd92-751994fe8d82" class="toggle"><li><details open=""><summary><strong>Using </strong><strong><code>fork</code></strong><strong> &amp; </strong><strong><code>execve</code></strong><strong> to Run Programs</strong></summary><p id="212d9085-9c59-477a-a98b-537e1b914573" class="">A <strong>shell </strong>is an interactive application-level program that <strong>runs other programs</strong> on behalf of the user. A shell performs a sequence of <strong>read/evaluate steps</strong> and then terminates :</p><pre id="89a865bd-345c-453c-b415-c082f9af7207" class="code"><code>#include &quot;csapp.h&quot;
#define MAXARGS 128

/* Function prototypes */
void eval(char *cmdline);
int parseline(char *buf, char **argv);
int builtin_command(char **argv);

int main(){
	char cmdline[MAXLINE]; /* Command line */
	
	while (1) {
		/* Read */
		printf(&quot;&gt; &quot;);
		Fgets(cmdline, MAXLINE, stdin);
		if (feof(stdin)) exit(0);
		
		/* Evaluate */
		eval(cmdline);
	}
}</code></pre><ul id="ba674e5e-1a61-485c-a84b-85c2e7091d58" class="bulleted-list"><li style="list-style-type:disc">The shell prints a <strong>command-line prompt</strong>, waits for the user to type a command line on <code>stdin</code>, and then <strong>evaluates the command line</strong>.</li></ul><pre id="fbb60ac2-d4c8-46bc-a320-5033d667d04f" class="code"><code>/* eval - Evaluate a command line */
void eval(char *cmdline){
	char *argv[MAXARGS]; /* Argument list execve() */
	char buf[MAXLINE]; /* Holds modified command line */
	int bg; /* Should the job run in background or foreground? */
	pid_t pid; /* Process ID */

	strcpy(buf, cmdline);
	bg = parseline(buf, argv);
	if (argv[0] == NULL) return; /* Ignore empty lines */
 
	if (!builtin_command(argv)) {
		if ((pid = Fork()) == 0) { /*Child runs user job */
			if (execve(argv[0], argv, environ) &lt; 0) {
				printf(&quot;%s: Command not found.\n&quot;, argv[0]);
				exit(0);
			}
		}
		
		/* Parent waits for foreground job to terminate */
		if (!bg) {
			int status;
			if (waitpid(pid, &amp;status, 0) &lt; 0) unix_error(&quot;waitfg: waitpid error&quot;);
		}
		else printf(&quot;%d %s&quot;, pid, cmdline);
	}
	return;
}</code></pre><ul id="73f71d79-a06d-4dfd-a1ff-56bf6b61c27c" class="bulleted-list"><li style="list-style-type:disc"><strong><code>eval</code></strong><strong> </strong>evaluates the command line.</li></ul><ul id="3bb57e4e-d215-4406-b8f6-b5683e143ee8" class="bulleted-list"><li style="list-style-type:disc">It first call the <strong><code>parseline</code></strong> function which <strong>parses the space-separated command-line arguments </strong>and <strong>builds the </strong><strong><code>argv</code></strong><strong> vector</strong> that will be passed to <code>execve</code>.<pre id="25ebff6e-1458-4b1f-82d5-f03c7178c1d3" class="code"><code>/* parseline - Parse the command line and build the argv array */
int parseline(char * buf, char **argv){
	char *delim; /* Points to first space delimiter */
	int argc; /* Number of args */
	int bg; /* Background job? */

	buf[strlen(buf)-1] = &#x27; &#x27;; /* Replace trailing &#x27;\n&#x27; with space */
	while (*buf &amp;&amp; (*buf == &#x27; &#x27;)) buf++; /* Ignore leading spaces */
	
	/* Build the argv list */
	argc = 0;
	while ((delim = strchr(buf, &#x27; &#x27;))) {
		argv[argc++] = buf;
		*delim = &#x27;\0&#x27;;
		buf = delim + 1;
		while (*buf &amp;&amp; (*buf == &#x27; &#x27;)) buf++; /* Ignore spaces */
	}
	argv[argc] = NULL;
	
	if(argc == 0) return 1; /* Ignore blank line */
	
	/* Should the job run in the background? */
	if ((bg = (*argv[agrc-1] == &#x27;&amp;&#x27;)) != 0) argv[--argc] = NULL;
	
	return bg;
}</code></pre><ul id="467e307a-e8b4-4962-a74a-5af32b3146f5" class="bulleted-list"><li style="list-style-type:circle">The <strong>first argument</strong> is assumed to be either the <strong>name of a built-in shell command</strong>, or an <strong>executable object file</strong> that will be loaded &amp; run in the context of a new child process.</li></ul><ul id="335510a0-8096-408c-a4d1-80d36c7ccd16" class="bulleted-list"><li style="list-style-type:circle">If the last argument is an<strong> ‘&amp;’ </strong>character, then <code>parseline</code> returns<strong> 1</strong>, indicating that the program should be executed in the <strong>background </strong>(the shell doesn’t wait for it to complete).</li></ul><ul id="e98fe0d2-58a5-460f-aec7-24f6f30742ca" class="bulleted-list"><li style="list-style-type:circle">Otherwise, it returns <strong>0</strong>, indicating that the program should be run in the <strong>foreground </strong>(the shell waits for it to complete).</li></ul></li></ul><ul id="aeac3f3e-4acc-4aff-ac6c-097ba52ec3d6" class="bulleted-list"><li style="list-style-type:disc">After parsing, the <code>eval</code> calls <strong><code>builtin_command</code></strong><strong> </strong>which checks <strong>whether the first command-line argument is a built-in shell command</strong>.<pre id="05afb467-2e90-42ad-b875-9417acbd64c0" class="code"><code>/* If first arg is a builtin command, run it and return true */
int builtin_command(char **argv){
	if(!strcmp(argv[0], &quot;quit&quot;)) exit(0); /* quit command */
	if(!strcmp(argv[0], &quot;&amp;&quot;)) return 1; /* Ignore singleton &amp; */
	return 0; /* Not a builtin command */
}</code></pre><ul id="e705eb95-31c8-44c1-bf3e-a370e368f80a" class="bulleted-list"><li style="list-style-type:circle">If first argument is a<strong> built-in command</strong>, <code>builtin_command</code> <strong>immediately interprets the command</strong> and returns <strong>1</strong>.</li></ul><ul id="1eee2b92-5630-4dfe-bec7-111d66b870c9" class="bulleted-list"><li style="list-style-type:circle">Otherwise, it returns <strong>0</strong>.</li></ul><ul id="422d76b8-86ed-4b49-927f-70d5031be05a" class="bulleted-list"><li style="list-style-type:circle">In this example, the shell has just one built-in command, <strong><code>quit</code></strong>.</li></ul></li></ul><ul id="09b474c1-0132-4045-afa4-597e8ee5ee55" class="bulleted-list"><li style="list-style-type:disc">If <code>builtin_command</code> returns <strong>0</strong>, the shell <strong>creates a child process</strong> and <strong>executes the requested program inside the child</strong>.</li></ul><ul id="d43a9f02-ce9d-4c3e-8fc1-4956d8a36a37" class="bulleted-list"><li style="list-style-type:disc">If asked to run in the <strong>background</strong>, the shell then returns to the top of the loop and <strong>waits for the next command line</strong>.</li></ul><ul id="58a63c02-16f9-49d0-92db-c7dae9163fdb" class="bulleted-list"><li style="list-style-type:disc">Otherwise, the shell uses the <strong><code>waitpid</code></strong><strong> </strong>function to <strong>wait for the job to terminate</strong>.</li></ul><ul id="d38c8a53-bcd6-41a6-b3b1-d51d9775fd5e" class="bulleted-list"><li style="list-style-type:disc">This shell is <strong>flawed </strong>- <strong>it doesn’t reap any of its background children</strong>. Correcting this flaw requires the use of <strong>signals</strong>.</li></ul><p id="41801d37-08b9-4d5e-87d1-217dca67fd7b" class="">
</p></details></li></ul></div><h2 id="43e6d1c7-263d-4b78-b3fb-a7885fa8b5bd" class=""><details open=""><summary><mark class="highlight-blue">8.5</mark> Signals</summary></details></h2><div class="indented"><p id="bad5f718-d518-47fb-9e1e-2e33e60d7ccf" class="">A <strong>signal </strong>is a small message that <strong>notifies </strong>a process that <strong>an event of some type has occurred</strong> in the system. </p><p id="b9ad09dc-0ad6-4629-bfe0-6f4a76ee01d6" class=""><strong>Low-level hardware exceptions</strong> are processed by the <strong>kernel’s exception handlers</strong>, and <strong>wouldn’t be visible to user processes</strong>. → <strong>Signals </strong>provide a mechanism for <strong>exposing the occurrence of such exceptions</strong> to user processes.</p><figure id="019722da-8fb7-498e-a0c6-b6c8a3fa3ad6" class="image"><a href="/assets/images/CSAPP-8/Untitled%2012.png"><img style="width:480px" src="/assets/images/CSAPP-8/Untitled%2012.png"/></a></figure><ul id="e65f9095-3574-42dd-957f-539de917bc48" class="toggle"><li><details open=""><summary><strong>Signal Terminology</strong></summary><ul id="df072363-9193-47d5-adce-4ce41555dc74" class="bulleted-list"><li style="list-style-type:disc"><strong>Transfer of a signal</strong><p id="543860ce-4e4d-41b7-8fa3-2fb03c24e40e" class="">The <strong>transfer of a signal</strong> occurs in two distinct steps:</p><ol type="1" id="13326ecb-d124-48d5-919d-e448684d8617" class="numbered-list" start="1"><li><strong>Sending (Delivering) a signal</strong><p id="934855ab-e64e-4c1c-844a-33810f6cea35" class="">The kernel sends (delivers) a signal to a destination process by <strong>updating some state in the context of the destination process.</strong></p><p id="2f2457cf-e8b7-496f-887c-0c84e0dce5fc" class="">The signal is delivered for one of two reasons:</p><ul id="cf7eb3e1-0530-44d2-b4fa-09f024b9f6c6" class="bulleted-list"><li style="list-style-type:disc">The <strong>kernel </strong>has <strong>detected </strong>a system event. (<em>example : divide-by-zero error or the termination of a child process</em>)</li></ul><ul id="cb01b572-c73e-4040-a06c-003704a60740" class="bulleted-list"><li style="list-style-type:disc">A process has <strong>invoked </strong>the <strong><code>kill</code></strong><strong> function</strong> to explicitly <strong>request the kernel to send a signal</strong> to the destination process.</li></ul></li></ol><ol type="1" id="d94fb2d2-c8be-4dbf-9ae6-68d5dcd45f6e" class="numbered-list" start="2"><li><strong>Receiving a signal</strong><p id="f22d3d16-2597-419c-a410-ec402a069838" class="">A destination process receives a signal when it is <strong>forced by the kernel to react to the delivery of the signal</strong>.</p><p id="997fbb24-4eca-49b0-b998-b7fb62a790d5" class="">The process can react in three different ways:</p><ul id="d0828c8c-7bd9-4c79-90f0-b7b48c8d3557" class="bulleted-list"><li style="list-style-type:disc">The process can <strong>ignore </strong>the signal.</li></ul><ul id="5fdc55f2-9a0f-4f1b-9e8f-0b81caae165e" class="bulleted-list"><li style="list-style-type:disc">The process can <strong>terminate</strong>.</li></ul><ul id="6f7b765b-2b66-4084-aa50-805d09bdc182" class="bulleted-list"><li style="list-style-type:disc">The process can <strong>catch </strong>the signal by executing a user-level function called a <strong>signal handler</strong>. - The signal handler returns to <strong>next instruction</strong> after handling the signal.</li></ul><figure id="6bad7abc-69cc-4d78-8791-779f188eb272" class="image"><a href="/assets/images/CSAPP-8/Untitled%2013.png"><img style="width:336px" src="/assets/images/CSAPP-8/Untitled%2013.png"/></a></figure></li></ol></li></ul><ul id="26326cae-fb14-4b8a-96af-90d014903f79" class="bulleted-list"><li style="list-style-type:disc"><strong>A pending signal</strong><ul id="e78ff5be-7394-4924-a346-df4df74e7e68" class="bulleted-list"><li style="list-style-type:circle">A <strong>pending signal</strong> is a signal that has been <strong>sent but not yet received</strong>. </li></ul><ul id="cdd24acd-879c-44da-8311-f2047d333d72" class="bulleted-list"><li style="list-style-type:circle">If a process has a pending signal of type <em>k</em>, then any <strong>subsequent signals of type </strong><strong><em>k</em></strong> sent to that process are <strong>not queued</strong> - they are simply <strong>discarded</strong>.</li></ul><ul id="a9974688-4adf-4113-a09b-4e47198a1efd" class="bulleted-list"><li style="list-style-type:circle">A process can <strong>block </strong>the receipt of certain signals - When a signal is blocked, it <strong>can be delivered</strong>, but the resulting <strong>pending signal</strong> <strong>won’t be received</strong> until the process unblocks the signal.</li></ul><ul id="11346958-c058-4ca9-8d19-ecdcddce9fa2" class="bulleted-list"><li style="list-style-type:circle">For each process, the kernel maintains<strong> the set of pending signals</strong> in the <strong><code>pending</code></strong><strong> bit vector</strong>, and <strong>the set of blocked signals</strong> in the <strong><code>blocked</code></strong><strong> bit vector</strong>. <p id="d5536a70-f8c0-4133-8546-7e882ad3c219" class="">The kernel <strong>sets </strong>bit <em>k</em> in <code>pending</code> when a signal of type <em>k</em> is <strong>delivered</strong>, and <strong>clears </strong>bit <em>k</em> in <code>pending</code> whenever a signal of type <em>k</em> is <strong>received</strong>.</p></li></ul></li></ul></details></li></ul><ul id="088ddca6-f750-456b-a5aa-e85b44f776dd" class="toggle"><li><details open=""><summary><strong>Sending Signals - </strong><code><strong>getpgrp</strong></code><strong>, </strong><code><strong>setpgid</strong></code><strong>, </strong><code><strong>/bin/kill</strong></code><strong>, </strong><code><strong>kill</strong></code><strong>, </strong><code><strong>alarm</strong></code></summary><ul id="18ddcb8c-61ca-43de-a96d-42f024d41ce3" class="bulleted-list"><li style="list-style-type:disc"><strong>Process Groups - </strong><code><strong>getpgrp</strong></code><strong>, </strong><code><strong>setpgid</strong></code><p id="e6c69059-1d6f-47e3-8f85-3b496ed465d2" class="">Every process belongs to exactly one <strong>process group</strong>, which is identified by a positive integer <strong>process group ID</strong>.</p><pre id="f7dd9ef5-6846-4ee2-a30d-e22d33d5aff8" class="code"><code>#include &lt;unistd.h&gt;

pid_t getpgrp(void);
int setpgid(pid_t pid, pid_t pgid);</code></pre><p id="fe3205ed-f6a6-4779-afa8-414de7b3a3f4" class=""><code>getpgrp</code> <strong>returns </strong>the <strong>process group ID</strong> for the current process.</p><p id="17baa996-ba9b-4f85-962c-9a4b6da3aa7b" class=""><code>setpgid</code> <strong>changes </strong>the process group of process <code>pid</code> to <code>pgid</code>. If <code>pid</code> is zero, the PID of the current process is used. If <code>pgid</code> is zero, <code>pid</code> is used for the process group ID. </p><p id="a8148bd6-b940-4059-bab5-df458518948f" class="">(<em>example : if process 15213 is the calling process, </em><code><em>setpgid(0, 0);</em></code><em> creates a new process group whose process group ID is 15213, and adds process 15213 to this new group.)</em></p></li></ul><ul id="07b89d36-bd74-40b8-9a48-b7c5052d2b8d" class="bulleted-list"><li style="list-style-type:disc"><strong>Sending Signals with the </strong><strong><code>/bin/kill</code></strong><strong> Program</strong><p id="00286958-9497-4699-97e9-d7b608a5f678" class=""><code>/bin/kill</code> program <strong>sends an arbitrary signal</strong> to another process.</p><p id="db5810ef-7dd3-48d5-b711-b9699d2ab6cb" class="">(<em>example : </em><code>linux&gt; /bin/kill -9 15213</code><em> → sends signal 9 (</em><em><code>SIGKILL</code></em><em>) to process 15213.</em>)</p><p id="3326249f-cc84-4a36-b1fc-4abbd6587efa" class="">A <strong>negative PID</strong> causes the signal to be sent to <strong>every process in process group PID</strong>.</p><p id="afbb3165-f8b1-4aca-a079-a4c49f0e1235" class="">(<em>example : </em><code><em>linux&gt; /bin/kill -9 -15213</em></code><em> → sends signal 9 (</em><code><em>SIGKILL</em></code><em>) to every process in processs group 15213.</em>)</p></li></ul><ul id="a9a88aa1-25e4-4600-87b7-21be890935c8" class="bulleted-list"><li style="list-style-type:disc"><strong>Sending Signals from the Keyboard</strong><ul id="144cdc49-daa6-402c-9241-759b7d4cd5af" class="bulleted-list"><li style="list-style-type:circle">A <strong>job </strong>is the abstraction of the <strong>processes </strong>that are created as a result of evaluating a single command line. </li></ul><figure id="855ae86b-c82e-43e5-b6ee-5d742f9bce26" class="image"><a href="/assets/images/CSAPP-8/Untitled%2014.png"><img style="width:384px" src="/assets/images/CSAPP-8/Untitled%2014.png"/></a></figure><ul id="ac352498-ffbd-48e6-9fa5-b55514b03a66" class="bulleted-list"><li style="list-style-type:circle">At any point in time, there is<strong> at most one foreground job</strong> and <strong>zero or more background jobs</strong>.</li></ul><ul id="cb1d5c35-a6b9-4d48-b7d1-242941849452" class="bulleted-list"><li style="list-style-type:circle">The shell creates a <strong>separate process group for each job</strong>. - The <strong>process group ID </strong>is taken from one of the <strong>parent processes</strong> in the job.</li></ul><ul id="cafebeae-a8cc-43a0-80a1-40609960d9ba" class="bulleted-list"><li style="list-style-type:circle">Typing <strong>Ctrl + C </strong>causes the kernel to send a <strong><code>SIGINT</code></strong><strong> signal</strong> to every process in the <strong>foreground</strong> process group. In the default case, this signal <strong>terminates</strong> the foreground job.</li></ul><ul id="f14860cd-e9dc-468f-90cd-008266425c5d" class="bulleted-list"><li style="list-style-type:circle">Typing <strong>Ctrl + Z</strong> causes the kernel to send a <strong><code>SIGTSTP</code></strong><strong> signal</strong> to every process in the <strong>foreground </strong>process group. In the default case, this signal <strong>stops (suspends)</strong> the foreground job.</li></ul></li></ul><ul id="33b0b2b1-7730-42c3-b305-cb163c44fbc1" class="bulleted-list"><li style="list-style-type:disc"><strong>Sending Signals with the </strong><strong><code>kill</code></strong><strong> function - </strong><strong><code>kill</code></strong><pre id="9acd71f4-ea03-4d3f-8b5f-77df9f4e120c" class="code"><code>#include &lt;sys/types.h&gt;
#include &lt;signal.h&gt;

int kill(pid_t pid, int sig);</code></pre><p id="4bfdcb2b-5218-4505-9952-2d35cf94b45b" class="">Processes send signals to other processes by calling the <code>kill</code> function.</p><ul id="15ae4d22-51c3-4622-8dbb-7483935c5959" class="bulleted-list"><li style="list-style-type:circle"><code>pid</code> &gt; 0 → <code>kill</code> sends signal <code>sig</code> to process <code>pid</code>.</li></ul><ul id="3815de23-6826-4568-b495-6e5d8d01c15a" class="bulleted-list"><li style="list-style-type:circle"><code>pid</code> = 0 → <code>kill</code> sends signal <code>sig</code> to every process in the process group of the calling process, including the calling process itself.</li></ul><ul id="9f21a012-31bc-4ab3-981a-fc3c5b2b0dd6" class="bulleted-list"><li style="list-style-type:circle"><code>pid</code> &lt; 0 → <code>kill</code> sends signal <code>sig</code> to every process in process group <code>|pid|</code>.</li></ul><ul id="114c2588-c3cc-4c43-b408-6c53ce330cf9" class="bulleted-list"><li style="list-style-type:circle">Example Code : Using <code>kill</code> to send a <code>SIGKILL</code> to a child</li></ul><pre id="6f68386f-52e5-461b-a587-0b36ff504227" class="code"><code>#include &quot;csapp.h&quot;

int main(){
	pid_t pid;
	
	/* Child sleeps until SIGKILL signal received, then dies */
	if ((pid == FOrk()) == 0) {
		Pause(); /* Wait for a signal to arrive */
		printf(&quot;Control should never reach here!\n&quot;);
		exit(0);
	}

	/* Parent sends a SIGKILL signal to a child */
	Kill(pid, SIGKILL);
	exit(0);
}	</code></pre></li></ul><ul id="cb80956f-4b6d-4cd7-9bec-27e941d5d513" class="bulleted-list"><li style="list-style-type:disc">Sending Signals with the <code>alarm</code> Function - <code>alarm</code><pre id="42b31e72-5a44-40ee-9f53-b0a8bebc2f49" class="code"><code>#include &lt;unistd.h&gt;

unsigned int alarm(unsigned int secs);</code></pre><p id="7eb6385a-836e-4f1d-baaf-10c837d58e02" class=""><code>alarm</code> arranges for the kernel to <strong>send a </strong><strong><code>SIGALRM</code></strong><strong> signal</strong> to the calling process <strong>in </strong><strong><code>secs</code></strong><strong> seconds</strong>.</p><ul id="3352aade-f4c2-4548-bbce-3a2bbaf2c14b" class="bulleted-list"><li style="list-style-type:circle"><code>secs</code> = 0 → no new alarm is scheduled.</li></ul><ul id="386c69fb-bdd7-48cd-a97f-a1cd05091ff5" class="bulleted-list"><li style="list-style-type:circle">The call to <code>alarm</code> <strong>cancels any pending alarms</strong> and returns the <strong>number of seconds remaining</strong> until any pending alarm was due to be delivered, or 0 if there were no pending alarms.</li></ul><p id="fea344ff-1267-4ad5-b166-89f911f45981" class="">
</p></li></ul></details></li></ul><ul id="fb4dd096-baa7-482f-b62d-0f309b4b0aee" class="toggle"><li><details open=""><summary><strong>Receiving Signals - </strong><strong><code>signal</code></strong></summary><ul id="757eda57-0f5c-48f1-9c87-a3ab1398fda2" class="bulleted-list"><li style="list-style-type:disc"><strong>Receiving Signals</strong><p id="6306cb5b-9091-4c20-860d-967d4606ff36" class="">When the <strong>kernel </strong>switches a process <em>p</em> from kernel mode to user mode, it checks the set of <strong>unblocked pending signals</strong> (<code>pending &amp; ~blocked</code>) for <em>p</em>. </p><p id="d24a6fcb-08c4-4292-a478-acbcbc976403" class="">If the set is <strong>empty, </strong>The kernel passes control to the <strong>next instruction</strong> in the logical control flow of <em>p</em>.</p><p id="8bc6dec5-40d2-4278-be10-91a8a4dfe2cc" class="">If the set is <strong>nonempty:</strong><div class="indented"><ol type="1" id="13cb5814-ece0-4ceb-b095-abd22d3faa76" class="numbered-list" start="1"><li>The kernel chooses some signal <em>k</em> in the set &amp; <strong>forces </strong><strong><em>p</em></strong><strong> to receive signal </strong><strong><em>k</em></strong>. </li></ol><ol type="1" id="c55d37a3-c777-4063-b99c-d73031e7bfa5" class="numbered-list" start="2"><li>The receipt of the signal triggers some <strong>action </strong>by the process. </li></ol><ol type="1" id="26230812-d90c-4c11-bead-bba6e3a7a175" class="numbered-list" start="3"><li>After the action, control passes <strong>back to the next instruction</strong> in the logical control flow of <em>p</em>.</li></ol></div></p></li></ul><ul id="3bb69696-c491-42d4-a4e8-934add03a7a0" class="bulleted-list"><li style="list-style-type:disc"><strong>Default Action for the Signal</strong><p id="93d5a068-36da-451b-9548-6b52c3bcabec" class="">Each signal type has a predefined default action, which is one of the following:</p><ul id="4861414b-629d-40a0-8213-312fb8341ab9" class="bulleted-list"><li style="list-style-type:circle">The process terminates</li></ul><ul id="fe6a7604-dd59-4f01-9a4f-eb26467e6231" class="bulleted-list"><li style="list-style-type:circle">The process terminates and dumps core. (= writing an image of the code &amp; data memory segments to disk.)</li></ul><ul id="310739a0-df02-4009-b6f9-a61843e7c094" class="bulleted-list"><li style="list-style-type:circle">The process stops(suspends) until restarted by a <code>SIGCONT</code> signal.</li></ul><ul id="e00f5707-f0d6-4298-9a4a-afe6220b01d2" class="bulleted-list"><li style="list-style-type:circle">The process ignores the signal.</li></ul></li></ul><ul id="8c4bef10-57b9-4164-9a40-2b07cec93e94" class="bulleted-list"><li style="list-style-type:disc"><strong>Modifying the Default Action for the Signal - </strong><strong><code>signal</code></strong><pre id="5b34a767-d2ff-4d88-a93d-303e53eb1e79" class="code"><code>#include &lt;signal.h&gt;
typedef void (*sighandler_t)(int);

sighandler_t signal(int signum, sighandler_t handler);</code></pre><p id="8671db7e-937c-491c-a84a-82b4a72ba9d2" class="">The <code>signal</code> can <strong>change the action</strong> associated with a signal <code>signum</code> in one of three ways:</p><ul id="133a7b95-b07b-4eb3-b3fb-b2fd3748e090" class="bulleted-list"><li style="list-style-type:circle"><code>hander</code> is <code>SIG_IGN</code> → signals of type <code>signum</code> are <strong>ignored</strong>.</li></ul><ul id="b46da30d-931d-4431-b6dc-b4e82b48bc41" class="bulleted-list"><li style="list-style-type:circle"><code>handler</code> is <code>SIG_DFL</code> → the action for signals of type <code>signum</code> <strong>reverts to the default action</strong>.</li></ul><ul id="3d637721-6160-47bb-aef4-d3d9abd245d7" class="bulleted-list"><li style="list-style-type:circle"><code>handler</code> is the address of a user-defined function (<strong>signal handler</strong>) → Signal handler will be called whenever the process receives a signal of type <code>signum</code>.<p id="5e70f75b-2059-4f64-93e3-f50516bc50d5" class="">When a process catches a signal of type <em>k</em>, the handler is invoked <strong>with a single integer argument set to </strong><strong><em>k</em></strong>.</p></li></ul></li></ul><ul id="2016eef1-de00-4fd1-8cfe-820813e46b0c" class="bulleted-list"><li style="list-style-type:disc"><strong>Example Code : Using a signal handler to catch a </strong><strong><code>SIGINT</code></strong><strong> signal.</strong><pre id="50db67d4-7a97-4ac7-8fae-a7da35d2cc9e" class="code"><code>#include &quot;csapp.h&quot;

void sigint_handler(int sig){ /* SIGINT handler */
	printf(&quot;Caught SIGINT!\n&quot;);
	exit(0);
}

int main(){
	/* Install the SIGINT handler */
	if (signal(SIGINT, sigint_handler) == SIG_ERR) unix_error(&quot;signal error&quot;);
	
	pause(); /* Wait for the receipt of a signal */

	return 0;
}</code></pre><p id="1ec203bb-ceb1-4bb6-805f-d4fb337434af" class=""><code>SIGINT</code> is sent whenever the user types Ctrl+C at the keyboard. The default action for <code>SIGINT</code> is to terminate the process. We modify the default behavior to catch the signal, print a message, and then terminate the process.</p></li></ul><ul id="c2901ea3-2bb9-40fc-829f-0b50d7075cf9" class="bulleted-list"><li style="list-style-type:disc"><strong>Interrupting Signal Handlers</strong><figure id="ad8495af-0a76-42a5-b40c-ca58bf7d9089" class="image"><a href="/assets/images/CSAPP-8/Untitled%2015.png"><img style="width:528px" src="/assets/images/CSAPP-8/Untitled%2015.png"/></a></figure><p id="02b30d83-c7bd-436f-9cf4-2af45797ff3f" class="">Signal handlers can be interrupted by other handlers.  </p></li></ul></details></li></ul><ul id="b0ed8d19-67c6-4c37-bfc2-aff37ca3c8ac" class="toggle"><li><details open=""><summary><strong>Blocking &amp; Unblocking Signals - </strong><code><strong>sigprocmask</strong></code></summary><p id="362c25e7-9641-4453-830c-9ec2717ac18e" class="">Linux provides implicit and explicit mechanisms for blocking signals:</p><ul id="3c0d8b6b-6dbb-47ff-830c-9a857c88a55c" class="bulleted-list"><li style="list-style-type:disc"><strong>Implicit Blocking Mechanism</strong><p id="b3b221c4-e067-4e04-90c1-757082da4714" class="">By <strong>default</strong>, the kernel block any pending signals of the type <strong>currently being processed by a handler</strong>.</p></li></ul><ul id="591864a4-e514-40d6-baf3-f5a49a9c57de" class="bulleted-list"><li style="list-style-type:disc"><strong>Explicit Blocking Mechanism</strong><p id="0e1f2a0d-2c44-4c11-a073-4391a80b3b93" class="">Applications can explicitly <strong>block &amp; unblock selected signals</strong> using the <code>sigprocmask</code> and its helpers.</p><pre id="cf3a2563-eac0-423a-bd99-728db5f5f657" class="code"><code>#include &lt;signal.h&gt;

int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);
int sigemptyset(sigset_t *set);
int sigfillset(sigset_t *set);
int sigaddset(sigset_t *set, int signum);
int sigdelset(sigset_t *set, int signum);
int sigismember(const sigset_t *set, int signum);</code></pre><ul id="bfec68bd-11d6-40b6-9240-2d051fadcaaf" class="bulleted-list"><li style="list-style-type:circle"><code>sigprocmask</code> changes the set of currently blocked signals (The <code>blocked</code> bit vector). The specific behavior depends on <code>how</code> :<ul id="0f5e04fe-b368-49a2-a390-7f5ceb50469a" class="bulleted-list"><li style="list-style-type:square"><code>SIG_BLOCK</code> : <strong>Add </strong>the signals in <code>set</code> to <code>blocked</code> (<code>blocked = blocked | set</code>).</li></ul><ul id="32b5e63a-40c3-417c-9d32-27aa78e3f456" class="bulleted-list"><li style="list-style-type:square"><code>SIG_UNBLOCK</code> : <strong>Remove</strong> the signals in <code>set</code> from <code>blocked</code> (<code>blocked = blocked &amp; ~set</code>).</li></ul><ul id="88c824b2-1788-47c6-b6be-a4d69ea0df49" class="bulleted-list"><li style="list-style-type:square"><code>SIG_SETMASK</code> : <code>blocked = set</code></li></ul><p id="b542c1e9-179c-4eab-8ff4-f7367658c1b3" class="">If <code>oldset</code> is non-NULL, the <strong>previous value</strong> of the <code>blocked</code> bit vector is stored in <code>oldset</code>.</p></li></ul><ul id="e9ddb68f-1d3e-4930-b53d-d0306ab0d9c6" class="bulleted-list"><li style="list-style-type:circle"><code>sigemptyset</code> initializes <code>set</code> to the <strong>empty </strong>set.</li></ul><ul id="fb046108-846f-46a7-bef8-02f2b519d819" class="bulleted-list"><li style="list-style-type:circle"><code>sigfillset</code> adds <strong>every</strong> signal to <code>set</code>.</li></ul><ul id="159d4609-4ab3-4d59-a5e1-bd3759064ca6" class="bulleted-list"><li style="list-style-type:circle"><code>sigaddset</code> <strong>adds </strong><code>signum</code> to <code>set</code>.</li></ul><ul id="eddcc541-5f84-4c2e-a805-22f6eae298d4" class="bulleted-list"><li style="list-style-type:circle"><code>sigdelset</code> <strong>deletes </strong><code>signum</code> from <code>set</code>.</li></ul><ul id="32214f90-e211-478b-bf32-fa34b10a8a71" class="bulleted-list"><li style="list-style-type:circle"><code>sigismember</code> returns 1 if <code>signum</code> is a <strong>member </strong>of <code>set</code>, and 0 if not.</li></ul></li></ul><ul id="170eb307-db18-4a81-8a2f-6a38fc3051c5" class="bulleted-list"><li style="list-style-type:disc"><strong>Example Code : Temporary blocking a signal</strong><pre id="848828f8-91a1-426a-97d2-54744de98ee0" class="code"><code>sigset_t mask, prev_mask;

Sigemptyset(&amp;mask);
Sigaddset(&amp;mask, SIGINT);

/* Block SIGINT and save previous blocked set */
Sigprocmask(SIG_BLOCK, &amp;mask, &amp;prev_mask);

  // Code region that will not be interrupted by SIGINT

/* Restore previous blocked set, unblocking SIGINT */
Sigprocmask(SIG_SETMASK, &amp;prev_mask, NULL); </code></pre></li></ul></details></li></ul><ul id="c5eabd52-6dfc-4791-9d69-1c9bc96271b7" class="toggle"><li><details open=""><summary><strong>Writing Signal Handlers : Safe Signal Handling</strong></summary><p id="2bf1a276-4592-42dd-bd7e-446363eb3511" class=""><strong>Signal handlers</strong> can run <strong>concurrently </strong>with the <strong>main program</strong>. If a handler and the main program <strong>access the same global data structure concurrently</strong>, the results can be <strong>unpredictable</strong>.</p><p id="a306a7ed-d49b-4374-bf54-606e0a4577b6" class="">⇒ We need <strong>conservative guidelines</strong> for writing handlers that are safe to run concurrently.</p><ol type="1" id="36eea927-3b27-4805-bc38-b6052ce80274" class="numbered-list" start="1"><li><strong>Keep handlers as simple as possible.</strong><p id="251a4476-6787-4fe7-9ac7-0d391272b441" class="">For example, define the handler to <strong>simply set a global flag</strong> and return immediately. Then, let all processing associated with the receipt of the signal is performed by the main program, which periodically checks the flag.</p></li></ol><ol type="1" id="061e1b1b-66b9-4ccc-927f-51754181385c" class="numbered-list" start="2"><li><strong>Call only async-signal-safe functions in your handlers.</strong><p id="c6ab62ee-8c17-43ab-9bdb-0396b38f8a42" class="">A function that is <strong>async-signal-safe</strong> can be safely called from a signal handler, either because it is <strong>reentrant </strong>(e.g., accesses only local variables), or because it <strong>can’t be interrupted</strong> by a signal handler.</p><p id="4480d330-7f53-4023-8320-306e8ff4c47c" class="">In page 803, Figure 8.33 lists the system-level functions that Linux guarantees to be safe.</p><p id="21982ecf-9202-4279-a6e0-69a17ed807c8" class=""><strong>SIO package</strong> are some safe functions developed by CSAPP, that can be used to print simple messages from signal handlers.</p><pre id="61f3eb9a-19a5-4ca7-b4db-d71ca678cb3d" class="code"><code>#include &quot;csapp.h&quot;

ssize_t sio_puts(char s[]){ /* Put string */
	return write(STDOUT_FILENO, s, sio_strlen(s));
}

ssize_t sio_putl(long v){ /* Put long */
	char s[128];
	
	sio_ltoa(v, s, 10);
	return sio_puts(s);
}

void sio_error(char s[]){ /* Put error message and exit */
	sio_puts(s);
	_exit(1); /* Safe variant of exit */
}</code></pre></li></ol><ol type="1" id="0359f54a-cf06-405d-bfb4-53bfbbfbe6e9" class="numbered-list" start="3"><li><strong>Save and restore </strong><strong><code>errno</code></strong><strong>.</strong><p id="bd613bfa-aa75-4a44-b4a7-20f0c8dece69" class="">Many Linux async-signal-safe functions set <code>errno</code> when they return with an error. → Calling such functions inside a handler might <strong>interfere </strong>with other parts of the program that<strong> rely on </strong><strong><code>errno</code></strong><strong>.</strong></p><p id="415053bf-fbcc-4c29-86af-915ffcbf07a3" class="">⇒ <strong>Save </strong><strong><code>errno</code></strong><strong> to a local variable</strong> on entry to the handler and <strong>restore </strong>it before the handler returns.</p><p id="1fe9504a-71ab-4df9-be73-665d606dfb30" class="">This is only necessary if the handler <strong>returns</strong>. Not necessary if the handler terminates by calling <code>_exit</code>.</p></li></ol><ol type="1" id="e0c3ca58-6e16-4a20-8a2a-c4b85789c448" class="numbered-list" start="4"><li><strong>Protect accesses to shared global data structures by blocking all signals.</strong><p id="95769963-2097-44de-8a1b-f80161dc6ce1" class="">A handler shares a global data structure with the main program or with other handlers → Handlers &amp; main program should temporarily block all signals while accessing that data structure.</p><p id="14e291b9-e5bc-4fb1-aa8a-8075d8e03f43" class="">If instruction sequence accessing a shared data structure <em>d</em> is interrupted by a handler that accesses <em>d</em>, the handler might find <em>d</em> in an inconsistent state, with unpredictable results.</p></li></ol><ol type="1" id="d8027a5b-48c8-4184-b15a-3faa51ba673a" class="numbered-list" start="5"><li><strong>Declare global variables with </strong><strong><code>volatile</code></strong><strong>.</strong><p id="f381b858-1ed4-4d27-9d5d-99b87451a23e" class="">If the handler updates a global variable <code>g</code>, and <code>main</code> periodically reads <code>g</code>, an <strong>optimizing compiler</strong> may decide that <strong>the value of </strong><strong><code>g</code></strong><strong> never changes</strong> in <code>main</code>, and thus it would be safe to use a copy of <code>g</code> that is <strong>cached in a register</strong>. → <code>main</code> would <strong>never see the updated values</strong> from the handler!</p><p id="ac7c7828-2b49-45a5-8fc6-32bafe2a144c" class="">⇒ Declare a variable with the <strong><code>volatile</code></strong><strong> </strong>type qualifier.</p><pre id="10188b12-4c6b-4d76-ae3d-f266f8ac7b55" class="code"><code>volatile int g;</code></pre><p id="17102dcc-472e-4976-9f4d-9839c4f2ebdb" class=""><code>volatile</code> qualifier forces the compiler to read the value of <code>g</code> <strong>from memory</strong> each time it is referenced in the code. </p><p id="006ad027-8a82-4c53-b44a-c8aed38fb908" class="">As with any shared data structure, each access to a global variable should be protected by temporarily blocking signals.</p></li></ol><ol type="1" id="2e3cc31d-5801-4183-8fc9-2764b58b820e" class="numbered-list" start="6"><li><strong>Declare flags with </strong><strong><code>sig_atomic_t</code></strong><p id="22bc9dfd-b7dd-4d50-a891-a00812a59b1d" class="">One common handler design - The handler records the receipt of the signal by writing to a global <strong>flag</strong>. The main program periodically reads the flag, responds to the flag, and clears the flag.</p><p id="f582dc6d-2188-44c7-a8e4-610528e4bb54" class="">Use an integer data type <strong><code>sig_atomic_t</code></strong><strong> for flags</strong> → Reads &amp; writes for flags are guaranteed to be <strong>atomic(uninterruptible</strong>) because they can be <strong>implemented with a single instruction</strong> :</p><pre id="cdf282db-17a0-4ecb-a680-0c146ef9717e" class="code"><code>volatile sig_atomic_t flag;</code></pre><p id="35e4bcca-9224-4b5e-8fbc-d4e8be3f77cb" class="">The guarantee of atomicity <strong>only applies to individual reads and writes</strong>. - Does not apply to updates such as <code>flag++</code> or <code>flag = flag + 10</code>, which might require multiple instructions.</p></li></ol></details></li></ul><ul id="d79fc70b-df23-4af8-9f0b-15cbf2ab2207" class="toggle"><li><details open=""><summary><strong>Writing Signal Handlers : Correct Signal Handling</strong></summary><p id="81d02c15-1980-43be-8ea4-0618239be3d0" class=""><strong><code>pending</code></strong> bit vector contains <strong>only one bit</strong> for each type of signal → There can be <strong>at most one pending signal</strong> of any particular type.</p><p id="5c6e23ca-faa4-4dc6-a58e-07dec7431623" class="">If <strong>two signals of type </strong><strong><em>k</em></strong> are sent to a destination process while signal <em>k</em> is blocked because the process is <strong>currently executing a handler for signal </strong><strong><em>k</em></strong>, then the <strong>second signal is simply discarded</strong>.</p><ul id="07b57e86-f3a7-4598-a572-e3b320806e6c" class="bulleted-list"><li style="list-style-type:disc"><strong>Example Code : </strong><strong><code>signal1</code></strong><strong>, </strong><code><strong>signal2</strong></code><ol type="1" id="e61e7937-517a-4eb5-ba14-d7fb9ce1081a" class="numbered-list" start="1"><li>The <strong>parent </strong>installs a <strong><code>SIGCHLD</code></strong><strong> handler</strong> and then creates <strong>three children</strong>. In the meantime, the parent waits for a line of input from the terminal and then processes it. (infinite loop)</li></ol><ol type="1" id="49d2a136-8393-4883-93f0-ec5edacfb9f9" class="numbered-list" start="2"><li>When each <strong>child terminates</strong>, the kernel notifies the parent by sending it a <strong><code>SIGCHLD</code></strong><strong> signal</strong>. </li></ol><ol type="1" id="491ad386-efaf-4da9-918a-d2fdf9f63902" class="numbered-list" start="3"><li>The parent <strong>catches the </strong><strong><code>SIGCHLD</code></strong>, <strong>reaps one child</strong>, does some additional clean up work (modeled by the <code>sleep</code>), and then returns. </li></ol><p id="05100da6-7cb9-44d1-a092-e07dc227a0d6" class=""><code>signal1</code> is flawed because it assumes that <strong>signals are queued</strong>.</p><pre id="b337fc83-df47-47e2-9c68-0f9914690d43" class="code"><code>/* WARNING: This code is buggy! */

void handler1(int sig){
	int olderrno = errno;
	
	if ((waitpid(-1, NULL, 0)) &lt; 0) sio_error(&quot;waitpid error&quot;);
	Sio_puts(&quot;Handler reaped child\n&quot;);
	Sleep(1);
	errno = olderrno;
}

int main(){
	int i, n;
	char buf[MAXBUF];

	if (signal(SIGCHLD, handler1) == SIG_ERR) unix_error(&quot;signal error&quot;);
	
	/* Parent creates children */
	for (i = 0; i &lt; 3; i++) {
		if (Fork() == 0) {
			printf(&quot;Hello from child %d\n&quot;, (int)getpid());
			exit(0);
		}
	}

	/* Parent waits for terminal input and then processes it */
	if ((n = read(STDIN_FILENO, buf, sizeof(buf))) &lt; 0) unix_error(&quot;read&quot;);

	printf(&quot;Parent processing input\n&quot;);
	while (1)
		;

	exit(0);
}</code></pre><hr id="4d9196bf-4454-4ec4-8a5c-76087e686714"/><ul id="2eed540a-d57b-4837-91bc-27a81369fe08" class="bulleted-list"><li style="list-style-type:circle"><strong>Output</strong></li></ul><pre id="964c457e-8baa-426b-b7b0-376c9d6b45a0" class="code"><code>linux&gt; ./signal1
Hello from child 14073
Hello from child 14074
Hello from child 14075
Handler reaped child
Handler reaped child
CR
Parent processing input</code></pre><p id="20279666-348c-4c7a-812c-30a02ef1d54c" class=""><strong>child process 14075</strong> was <strong>never reaped</strong> and <strong>remains a zombie</strong>.</p><hr id="48611c84-f93a-448f-bd6d-6720fefc674b"/><p id="d2b9690e-e714-4f54-a493-d46c03c7c626" class=""><strong>What happened ? :</strong></p><ol type="1" id="ff8989bd-1461-4a04-9d02-c639f5ff429a" class="numbered-list" start="1"><li>The <strong>first signal</strong> is received and caught by the parent.</li></ol><ol type="1" id="f37f0ac8-97a4-4a0a-80d0-68a59b9e44f8" class="numbered-list" start="2"><li>While the handler is processing the <strong>first signal</strong>, the <strong>second signal</strong> is delivered &amp; added to the set of pending signals.</li></ol><ol type="1" id="e1c246b2-abad-42c2-8a64-d462b5f035a2" class="numbered-list" start="3"><li>While the handler is processing the first signal, the <strong>third signal</strong> arrives.</li></ol><ol type="1" id="b8f3c20c-3323-48d8-bdd9-eb40a4441fc7" class="numbered-list" start="4"><li>Since there is already a <strong>pending </strong><strong><code>SIGCHLD</code></strong>, the third <code>SIGCHLD</code> is <strong>discarded</strong>.</li></ol><ol type="1" id="51bafd35-5809-4699-b5e9-93298044d2aa" class="numbered-list" start="5"><li>After the handler has returned, the parent receive the second signal. Then, the handler processes the second signal.</li></ol><ol type="1" id="1d5dacee-d50f-4fe5-bfce-903d965da795" class="numbered-list" start="6"><li><strong>There are no more pending </strong><strong><code>SIGCHLD</code></strong><strong> signals → The third </strong><strong><code>SIGCHLD</code></strong><strong> signal has been lost.</strong></li></ol><hr id="2b0cfd30-f85e-4ad5-ac26-0dcc9cef9fc3"/><p id="3716b5c4-948d-4495-8ae5-d4d8b4895a97" class="">To fix <code>signal1</code>, modify the <code>SIGCHLD</code> handler to reap as many zombie as possible each time it is invoked.</p><pre id="63334e46-0877-4974-9c6f-732bbfcebcb1" class="code"><code>void handler2(int sig){
	int olderrno = errno;
	
	while (waitpid(-1, NULL, 0) &gt; 0) { /* Reap as many zombie as possible */
		Sio_puts(&quot;Handler reaped child\n&quot;);
	}
	if(errno != ECHILD) Sio_error(&quot;waitpid error&quot;);
	Sleep(1);
	errno = olderrno;
}</code></pre><hr id="967492bf-f8a9-44d3-bb7a-2b1907bf1ae4"/><ul id="3e25a705-3941-42f8-acf2-ea81a8552739" class="bulleted-list"><li style="list-style-type:circle"><strong>Output</strong></li></ul><pre id="29d30e84-1469-4d0c-90d1-7c4b8fc6d745" class="code"><code>linux&gt; ./signal2
Hello from child 15237
Hello from child 15238
Hello from child 15239
Handler reaped child
Handler reaped child
Handler reaped child
CR
Parent processing input</code></pre></li></ul></details></li></ul><ul id="30f6ecab-be88-4f8e-babf-3bb5f9a7b1d8" class="toggle"><li><details open=""><summary><strong>Writing Signal Handlers : Portable Signal Handling</strong></summary><p id="430f7421-9f41-4544-8c99-1773389ef7f9" class="">Different systems have different signal-handling semantics. </p><p id="c496c7b2-853f-4126-88bd-83c36213e500" class="">To deal with this aspect, the <code>sigaction</code> allows users to clearly specify the signal-handling semantics they want when they install a handler.</p><pre id="65ac9852-8354-44d3-bf37-ecb48ee94fec" class="code"><code>#include &lt;signal.h&gt;

int sigaction(int signum, struct sigaction *act, struct sigaction *oldact);</code></pre><p id="64f728ba-dec7-4c70-9eaa-7c8bc540217f" class="">The <code>Signal</code> wrapper installs a signal handler with the following signal handling semantics:</p><ul id="534559f0-4ae8-4935-ad80-9c9c37f8f3a9" class="bulleted-list"><li style="list-style-type:disc">Only signals of the type currently being processed by the handler are blocked.</li></ul><ul id="f8d283fd-dd46-4c76-a272-095615182ef3" class="bulleted-list"><li style="list-style-type:disc">As with all signal implementations, signals are not queued.</li></ul><ul id="8be5158a-a9d8-45f2-b68c-bd534fb9bfe1" class="bulleted-list"><li style="list-style-type:disc">Interrupted system calls are automatically restarted whenever possible.</li></ul><ul id="fa991b6a-214d-45df-8f8c-9cf342d345c5" class="bulleted-list"><li style="list-style-type:disc">Once the signal handler is installed, it remains installed until <code>Signal</code> is called with a <code>handler</code> argument of either <code>SIG_IGN</code> or <code>SIG_DFL</code>.</li></ul><pre id="ed789f9b-4030-41e8-9e58-205d6e35b8b0" class="code"><code>handler_t *Signal(int signum, handler_t *handler){
	struct sigaction action, old_action;

	action.sa_handler = handler;
	sigemptyset(&amp;action.sa_mask); /* Block sigs of type being handled */
	action.sa_flags = SA_RESTART; /* Restart syscalls if possible */

	if(sigaction(signum, &amp;action, &amp;old_action) &lt; 0) unix_error(&quot;Signal error&quot;);
	return (old_action.sa_handler);</code></pre></details></li></ul><ul id="bf3ee4f3-3a6d-4bbc-9d4f-97b61a75cdb8" class="toggle"><li><details open=""><summary><strong>Synchronizing Flows to Avoid Nasty Concurrency Bugs</strong></summary><p id="832eb3bb-e93b-41de-927c-19e6821e5870" class="">Programming <strong>concurrent flows</strong> that <strong>read &amp; write the same storage locations</strong> can cause a subtle <strong>synchronization error.</strong></p><ul id="6f65aa56-352a-4e5d-b85e-de21350da6e5" class="bulleted-list"><li style="list-style-type:disc"><strong>Example Code</strong><p id="5aea037c-0292-48f8-b343-15e42eff8a62" class="">In this code, the parent keeps track of its current children using entries in a <strong>global job list</strong>, with one entry per job.</p><p id="f4f68696-743f-4d22-a437-4b26d02d0fab" class=""><code>addjob</code> &amp; <code>deletejob</code> add and remove entries from the job list.</p><p id="20c1c073-d0e5-4bc5-8774-426d0e41cde3" class="">Parent creates a new child process → adds the child to the job list → When reaping a zombie child in the <strong><code>SIGCHLD</code></strong><strong> handler</strong>, it deletes the child from the job list.</p><pre id="daecf0d5-2b24-4e95-94ce-ea2192d9218e" class="code"><code>/* WARNING: This code is buggy! */
void handler(int sig){
	int olderrno = errno;
	sigset_t mask_all, prev_all;
	pid_t pid;

	Sigfillset(&amp;mask_all);
	while ((pid = waitpid(-1, NULL, 0)) &gt; 0) { /* Reap a zombie child */
		Sigprocmask(SIG_BLOCK, &amp;mask_all, &amp;prev_all);
		deletejob(pid); /* Delete the child from the job list */
		Sigprocmask(SIG_SETMASK, &amp;prev_all, NULL);
	}
	if (errno != ECHILD) Sio_error(&quot;waitpid error&quot;);
	errno = olderrno;
}


int main(int argc, char **argv){
	int pid;
	sigset_t mask_all, prev_all;
	
	Sigfillset(&amp;mask_all);
	Signal(SIGCHLD, handler);
	initjobs(); /* Initialize the job list */

	while (1) {
		if ((pid = Fork()) == 0) { /* Child process */
			Excve(&quot;/bin/date&quot;, argv, NULL);
		}
		Sigprocmask(SIG_BLOCK, &amp;mask_all, &amp;prev_all); /* Parent process */
		addjob(pid); /* Add the child to the job list */
		Sigprocmask(SIG_SETMASK, &amp;prev_all, NULL);
	}
	exit(0);
}</code></pre><p id="3e508883-e9c3-4610-a242-3f0b82d9a6f0" class="">In this code, there is a <strong>race </strong>between call to <strong><code>addjob</code></strong><strong> in the main routine</strong> and the call to <strong><code>deletejob</code></strong><strong> in the handler.</strong></p><p id="30353611-1882-47fd-96ba-0e1db1965b95" class="">If the child<strong> </strong>process terminates <strong>before </strong>the parent executes <code>addjob</code>, the kernel will deliver a <code>SIGCHLD</code> to parent. → When the parent becomes runnable, the kernel notices the <strong>pending </strong><strong><code>SIGCHLD</code></strong> &amp; causes it  to be received by <strong>running the signal handler</strong> in the parent. → <strong><code>deletejob</code></strong><strong> in the handler is called</strong> before <code>addjob</code>! (<strong>synchronization error</strong>)</p><p id="7cb06952-c19e-4704-9232-59c63f7ba74b" class="">If the child process terminates <strong>after </strong>the parent executes <code>addjob</code>, events occur in the <strong>correct </strong>order.</p></li></ul><ul id="bc911076-5237-4d57-be39-5a7f3b842eeb" class="bulleted-list"><li style="list-style-type:disc"><strong>Using </strong><strong><code>sigprocmask</code></strong><strong> to synchronize processes</strong><p id="f194655e-9eea-408d-8b66-8bd013568e80" class="">To solve the problem, <strong>block </strong><strong><code>SIGCHLD</code></strong><strong> before the call to </strong><strong><code>fork</code></strong> and then <strong>unblock them only after calling </strong><strong><code>addjob</code></strong>. → Then, it is guaranteed that the child will be reaped after it is added to the job list.</p><pre id="1650c615-ce4d-4d93-8e2a-724c4cb75038" class="code"><code>sigset_t mask_one;

Sigaddset(&amp;mask_one, SIGCHLD);

while (1) {
	Sigprocmask(SIG_BLOCK, &amp;mask_one, &amp;prev_one); /* Block SIGCHLD */
	if ((pid = Fork()) == 0) {
		Sigprocmask(SIG_SETMASK, &amp;prev_one, NULL); /* Unblock SIGCHLD */
		Execve(&quot;/bin/date&quot;, argv, NULL);
	}
	Sigprocmask(SIG_BLOCK, &amp;mask_all, NULL); /* Parent process */
	addjob(pid); /* Add the child to the job list */
	Sigprocmask(SIG_SETMASK, &amp;prev_one, NULL); /* Unblock SIGCHLD */
}</code></pre><p id="9c320902-9e8d-4d66-bdc3-72a9c6ab3393" class="">The children <strong>inherit </strong>the <code>blocked</code> set of their parents → We must <strong>unblock the </strong><strong><code>SIGCHLD</code></strong><strong> in the child</strong> before calling <code>execve</code>.</p><p id="ba7642f2-9534-4863-8b8f-9471466969f1" class="">
</p></li></ul></details></li></ul><ul id="c34fae44-2e23-4d23-a415-aa5541e10079" class="toggle"><li><details open=""><summary><strong>Explicitly Waiting for Signals - </strong><code><strong>sigsuspend</strong></code></summary><p id="0566d367-8a0b-415f-966e-091931fe7d2b" class="">When a main program needs to explicitly<strong> wait for a certain signal handler to run</strong>, use <strong><code>sigsuspend</code></strong>.</p><pre id="0a8a58ba-4c0a-420d-9056-a03919022629" class="code"><code>#include &lt;signal.h&gt;
int sigsuspend(const sigset_t *mask);</code></pre><p id="e3a45652-eda0-4cdd-b59f-4211fa31a7b1" class=""><code>sigsuspend</code> temporarily replaces the current blocked set with <code>mask</code>, and then suspend the process until the receipt of a signal whose action is either to run a handler or to terminate the process.</p><p id="7cd90cd0-bca1-49c8-9378-8a7a3859d166" class="">The action is to terminate → The process terminates without returning from <code>sigsuspend</code>.</p><p id="742a0b2d-7237-4582-86fb-4c6d9680d76d" class="">The action is to run a handler → <code>sigsuspend</code> returns after the handler returns, restoring the blocked set to its state when <code>sigsuspend</code> was called.</p><ul id="8a4f9292-4120-4d9f-89fb-1e9038b2f986" class="bulleted-list"><li style="list-style-type:disc"><strong>Example Code</strong></li></ul><p id="695e88dc-ca04-4389-ade1-31016e090cc8" class="">When a Linux shell creates a foreground job, it must wait for the job to terminate and be reaped by the <code>SIGCHLD</code> handler before accepting the next user command.</p><pre id="9b1494ce-7679-4991-9cfb-31c656fa1513" class="code"><code>#include &quot;csapp.h&quot;

volatile sig_atomic_t pid;

void sigchld_handler(int s){
	int olderrno = errno;
	pid = Waitpid(-1, NULL, 0);
	errno = olderrno;
}

void sigint_handler(int s){}

int main(int argc, char **argv){
	sigset_t mask, prev;

	Signal(SIGCHLD, sigchld_handler);
	Signal(SIGINT, sigint_handler);
	Sigemptyset(&amp;mask);
	Sigaddset(&amp;mask, SIGCHLD);
	
	while (1) {
		Sigprocmask(SIG_BLOCK, &amp;mask, &amp;prev); /* Block SIGCHLD */
		if (Fork() == 0) /* Child */
			exit(0);
		
		/* Wait for SIGCHLD to be received */
		pid = 0;
		while (!pid) sigsuspend(&amp;prev);

		/* Optionally unblock SIGCHLD */
		Sigprocmask(SIG_SETMASK, &amp;prev, NULL);
		
		/* Do some work after receiving SIGCHLD */
		printf(&quot;.&quot;);
	}
	exit(0);
}</code></pre></details></li></ul></div><h2 id="e19e1e72-14d0-4422-a6f8-10649a7b4bb5" class=""><details open=""><summary><mark class="highlight-blue">8.6</mark> Nonlocal Jumps</summary></details></h2><div class="indented"><p id="029ecd24-eb6c-40c3-8264-e8f919866405" class=""><strong>Nonlocal jump</strong> <strong>transfers control</strong> directly from one function to another currently executing function without having to go through the normal call-and-return sequence.</p><ul id="8169ba3c-ff9b-48fb-aade-7d01ffa91cb4" class="bulleted-list"><li style="list-style-type:disc"><code>setjmp</code> &amp; <code>longjmp</code><pre id="950e7981-6a74-4d65-8f20-b4eb94fbb8b0" class="code"><code>#include &lt;setjmp.h&gt;
int setjmp(jmp_buf env);
int sigsetjmp(sigjmp_buf env, int savesigs);</code></pre><ul id="56f11cd2-fd52-4d5a-b7af-a139c80a9f07" class="bulleted-list"><li style="list-style-type:circle"><code>setjmp</code> saves the current <strong>calling environment</strong> (PC, stack pointer, general purpose registers, ...) in the <strong><code>env</code></strong><strong> buffer</strong>, for later use by <code>longjmp</code>, and <strong>returns 0</strong>.</li></ul><ul id="e9ba9060-918d-41e3-b7f0-2cd2ec82c98e" class="bulleted-list"><li style="list-style-type:circle">The value of <code>setjmp</code> should <strong>not </strong>be assigned to a <strong>variable</strong>, but can be safely used as a test in a <strong><code>switch</code></strong><strong> </strong>or <strong>conditional statement</strong>.</li></ul><pre id="689f8292-3c8e-4d75-8772-54d993202fee" class="code"><code>#include &lt;setjmp.h&gt;
void longjmp(jmp_buf env, int retval);
void siglongjmp(sigjmp_buf env, int retval);</code></pre><ul id="50406cbd-20fa-487f-b845-0bcade7ada0d" class="bulleted-list"><li style="list-style-type:circle"><code>longjmp</code> <strong>restores</strong> the <strong>calling environment</strong> from the <code>env</code> buffer, and then <strong>triggers a return from the most recent </strong><strong><code>setjmp</code></strong> call that initialized <code>env</code>. → <code>setjmp</code> returns with the nonzero return value <code>retval</code>.</li></ul></li></ul><ul id="3e278fe2-face-4014-87ff-30e37e40c786" class="bulleted-list"><li style="list-style-type:disc"><strong>Example Code - Using nonlocal jumps to recover from error conditions</strong><pre id="7b6494a5-fd52-476f-9b8b-50f2f22cabc2" class="code"><code>#include &quot;csapp.h&quot;

jmp_buf buf;

int error1 = 0;
int error2 = 1;

void foo(void), bar(void);

int main(){
	switch(setjmp(buf)) {
		case 0:
				foo();
				break;
		case 1:
				printf(&quot;Detected an error1 condition in foo\n&quot;);
				break;
		case 2:
				printf(&quot;Detected an error2 condition in foo\n&quot;);
		default:
			printf(&quot;Unknown error condition in foo\n&quot;);
	}
	exit(0);
}

/* Deeply nested function foo */
void foo(void){
	if (error1) longjmp(buf, 1);
	bar();
}

void bar(void){
	if (error2) longjmp(buf, 2);
}</code></pre><p id="c30fa46c-169a-4423-b852-922dedbe5c25" class="">Nonlocal jumps permit an immediate return from a deeply nested function call, usually as a result of detecting some error condition.</p></li></ul><ul id="d0d8c8c3-719a-4a23-986e-74a394ff8f44" class="bulleted-list"><li style="list-style-type:disc"><strong>Example Code - Using nonlocal jumps to branch out of a signal handler to a specific code location</strong><pre id="69f8ac4f-1b91-454e-af08-4150ae0a6682" class="code"><code>#include &quot;csapp.h&quot;

sigjmp_buf buf;

void handler(int sig){
	siglongjmp(buf, 1);
}

int main(){
	if (!sigsetjmp(buf, 1)) {
		Signal(SIGINT, handler);
		Sio_puts(&quot;starting\n&quot;);
	}
	else Sio_puts(&quot;resetarting\n&quot;);

	while(1) {
		Sleep(1);
		Sio_puts(&quot;processing...\n&quot;);
	}
	exit(0); /* Control never reaches here */
}</code></pre><ul id="d32cc89f-4289-4cc1-998c-2142e022f978" class="bulleted-list"><li style="list-style-type:circle"><strong><code>sigsetjmp</code></strong><strong> </strong>and <strong><code>siglongjmp</code></strong><strong> </strong>are versions of <code>setjmp</code> and <code>longjmp</code> that can be used by signal handlers.</li></ul><ul id="92cc33a4-cb16-4622-b822-c0c33fe26ed2" class="bulleted-list"><li style="list-style-type:circle">Each time the user types <strong>Ctrl+C,</strong> the handler performs a <strong>nonlocal jump</strong> back to the <strong>beginning of the </strong><strong><code>main</code></strong>, printing ‘restarting\n’.</li></ul><ul id="ad9851be-bc1f-4f00-8d5a-54dd39a2da8c" class="bulleted-list"><li style="list-style-type:circle">To avoid a <strong>race</strong>, we must <strong>install the handler after we call </strong><strong><code>sigsetjmp</code></strong>. If not, handler can run before the initial call to <code>sigsetjmp</code>.</li></ul><ul id="7b2c88dc-9232-4194-899a-7c37ad3f2d5d" class="bulleted-list"><li style="list-style-type:circle"><code>sigsetjmp</code> and <code>siglongjmp</code> are not on the list of <strong>async-signal-safe functions</strong> → We must <strong>call only safe functions</strong> in any code <strong>reachable from a </strong><strong><code>siglongjmp</code></strong>.</li></ul></li></ul></div><p id="b34b0554-c515-4b15-a2a4-65c395d714a1" class="">
</p></div></article></body></html>