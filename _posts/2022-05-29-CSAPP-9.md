---
title:  "CS:APP Chapter 9 Summary ðŸ’¾"
excerpt: "Chatper 9 - Virtual Memory"
toc: true
classes: wide

categories:
  - CSAPP

---
Recently, I've been studying CS:APP - I'm posting my own summary of chapter 9 that I wrote up using [Notion](https://cw00h.notion.site/CS-APP-6d3c5c01e6e1456ca51f594a80b5c1f0).
<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Chapter 9 : Virtual Memory</title><style>
/* cspell:disable-file */
/* webkit printing magic: print all background colors */

.Notion strong {
    font-weight: 600;
}

.Notion a,
.Notion a.visited {
	color: inherit;
	text-decoration: underline;
}

.Notion .pdf-relative-link-path {
	font-size: 80%;
	color: #444;
}

.Notion h1,
.Notion h2,
.Notion h3 {
	letter-spacing: -0.01em;
	line-height: 1.2;
	font-weight: 600;
	margin-bottom: 0;
    display: flex;
}

.Notion .page-title {
	font-size: 2.5rem;
	font-weight: 700;
	margin-top: 0;
	margin-bottom: 0.75em;
}

.Notion h1 {
	font-size: 1.875rem;
	margin-top: 1.875rem;
}

.Notion h2 {
	font-size: 1.5rem;
	margin-top: 1.5rem;
}

.Notion h3 {
	font-size: 1.25rem;
	margin-top: 1.25rem;
}

.Notion .source {
	border: 1px solid #ddd;
	border-radius: 3px;
	padding: 1.5em;
	word-break: break-all;
}

.Notion .callout {
	border-radius: 3px;
	padding: 1rem;
}

.Notion figure {
	margin: 1.25em 0;
	page-break-inside: avoid;
}

.Notion figcaption {
	opacity: 0.5;
	font-size: 85%;
	margin-top: 0.5em;
}

.Notion mark {
	background-color: transparent;
}

.indented {
	padding-left: 1.5em;
}

.Notion hr {
	background: transparent;
	display: block;
	width: 100%;
	height: 1px;
	visibility: visible;
	border: none;
	border-bottom: 1px solid rgba(55, 53, 47, 0.09);
}

.Notion img {
	max-width: 100%;
}

@media only print {
	.Notion img {
		max-height: 100vh;
		object-fit: contain;
	}
}

@page {
	margin: 1in;
}

.Notion .collection-content {
	font-size: 0.875rem;
}

.Notion .column-list {
	display: flex;
	justify-content: space-between;
}

.Notion .column {
	padding: 0 1em;
}

.Notion .column:first-child {
	padding-left: 0;
}

.Notion .column:last-child {
	padding-right: 0;
}

.Notion .table_of_contents-item {
	display: block;
	font-size: 0.875rem;
	line-height: 1.3;
	padding: 0.125rem;
}

.Notion .table_of_contents-indent-1 {
	margin-left: 1.5rem;
}

.Notion .table_of_contents-indent-2 {
	margin-left: 3rem;
}

.Notion .table_of_contents-indent-3 {
	margin-left: 4.5rem;
}

.Notion .table_of_contents-link {
	text-decoration: none;
	opacity: 0.7;
	border-bottom: 1px solid rgba(55, 53, 47, 0.18);
}

.Notion table,
.Notion th,
.Notion td {
	border: 1px solid rgba(55, 53, 47, 0.09);
	border-collapse: collapse;
}

.Notion table {
	border-left: none;
	border-right: none;
}

.Notion th,
.Notion td {
	font-weight: normal;
	padding: 0.25em 0.5em;
	line-height: 1.5;
	min-height: 1.5em;
	text-align: left;
}

.Notion th {
	color: rgba(55, 53, 47, 0.6);
}

.Notion ol,
.Notion ul {
	margin: 0;
	margin-block-start: 0.6em;
	margin-block-end: 0.6em;
}

.Notion li > ol:first-child,
.Notion li > ul:first-child {
	margin-block-start: 0.6em;
}

.Notion ul > li {
	list-style: disc;
}

.Notion ul.to-do-list {
	text-indent: -1.7em;
}

.Notion ul.to-do-list > li {
	list-style: none;
}

.to-do-children-checked {
	text-decoration: line-through;
	opacity: 0.375;
}

.Notion ul.toggle > li {
	list-style: none;
}

.Notion ul {
	padding-inline-start: 1.7em;
}

.Notion ul > li {
	padding-left: 0.1em;
}

.Notion ol {
	padding-inline-start: 1.6em;
}

.Notion ol > li {
	padding-left: 0.2em;
}

.mono ol {
	padding-inline-start: 2em;
}

.mono ol > li {
	text-indent: -0.4em;
}

.toggle {
	padding-inline-start: 0em;
	list-style-type: none;
}

/* Indent toggle children */
.toggle > li > details {
	padding-left: 1.7em;
}

.toggle > li > details > summary {
	margin-left: -1.1em;
}

.selected-value {
	display: inline-block;
	padding: 0 0.5em;
	background: rgba(206, 205, 202, 0.5);
	border-radius: 3px;
	margin-right: 0.5em;
	margin-top: 0.3em;
	margin-bottom: 0.3em;
	white-space: nowrap;
}

.collection-title {
	display: inline-block;
	margin-right: 1em;
}

.simple-table {
	margin-top: 1em;
	font-size: 0.875rem;
	empty-cells: show;
}
.simple-table td {
	height: 29px;
	min-width: 120px;
}

.simple-table th {
	height: 29px;
	min-width: 120px;
}

.simple-table-header-color {
	background: rgb(247, 246, 243);
	color: black;
}
.simple-table-header {
	font-weight: 500;
}

.Notion time {
	opacity: 0.5;
}

.icon {
	display: inline-block;
	max-width: 1.2em;
	max-height: 1.2em;
	text-decoration: none;
	vertical-align: text-bottom;
	margin-right: 0.5em;
}

.Notion img.icon {
	border-radius: 3px;
}

.user-icon {
	width: 1.5em;
	height: 1.5em;
	border-radius: 100%;
	margin-right: 0.5rem;
}

.user-icon-inner {
	font-size: 0.8em;
}

.text-icon {
	border: 1px solid #000;
	text-align: center;
}

.page-cover-image {
	display: block;
	object-fit: cover;
	width: 100%;
	max-height: 30vh;
}

.page-header-icon {
	font-size: 3rem;
	margin-bottom: 1rem;
}

.page-header-icon-with-cover {
	margin-top: -0.72em;
	margin-left: 0.07em;
}

.page-header-icon img {
	border-radius: 3px;
}

.link-to-page {
	margin: 1em 0;
	padding: 0;
	border: none;
	font-weight: 500;
}

.Notion p > .user {
	opacity: 0.5;
}

.Notion td > .user,
.Notion td > time {
	white-space: nowrap;
}

input[type="checkbox"] {
	transform: scale(1.5);
	margin-right: 0.6em;
	vertical-align: middle;
}

.Notion p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
}

.image {
	border: none;
	margin: 1.5em 0;
	padding: 0;
	border-radius: 0;
	text-align: center;
}

.Notion .code,
.Notion code {
	background: rgba(135, 131, 120, 0.15);
	border-radius: 3px;
	padding: 0.2em 0.4em;
	border-radius: 3px;
	font-size: 85%;
	tab-size: 2;
}

.Notion code {
	color: #eb5757;
}

.Notion .code {
	padding: 1.5em 1em;
}

.Notion .code-wrap {
	white-space: pre-wrap;
	word-break: break-all;
}

.code > code {
	background: none;
	padding: 0;
	font-size: 100%;
	color: inherit;
}

.Notion blockquote {
	font-size: 1.25em;
	margin: 1em 0;
	padding-left: 1em;
	border-left: 3px solid rgb(55, 53, 47);
}

.bookmark {
	text-decoration: none;
	max-height: 8em;
	padding: 0;
	display: flex;
	width: 100%;
	align-items: stretch;
}

.bookmark-title {
	font-size: 0.85em;
	overflow: hidden;
	text-overflow: ellipsis;
	height: 1.75em;
	white-space: nowrap;
}

.bookmark-text {
	display: flex;
	flex-direction: column;
}

.bookmark-info {
	flex: 4 1 180px;
	padding: 12px 14px 14px;
	display: flex;
	flex-direction: column;
	justify-content: space-between;
}

.bookmark-image {
	width: 33%;
	flex: 1 1 180px;
	display: block;
	position: relative;
	object-fit: cover;
	border-radius: 1px;
}

.bookmark-description {
	color: rgba(55, 53, 47, 0.6);
	font-size: 0.75em;
	overflow: hidden;
	max-height: 4.5em;
	word-break: break-word;
}

.bookmark-href {
	font-size: 0.75em;
	margin-top: 0.25em;
}

.sans { font-family: ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
.code { font-family: "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace; }
.serif { font-family: Lyon-Text, Georgia, ui-serif, serif; }
.mono { font-family: iawriter-mono, Nitti, Menlo, Courier, monospace; }
.pdf .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK JP'; }
.pdf:lang(zh-CN) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC'; }
.pdf:lang(zh-TW) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK TC'; }
.pdf:lang(ko-KR) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK KR'; }
.pdf .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK JP'; }
.pdf:lang(zh-CN) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK SC'; }
.pdf:lang(zh-TW) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK TC'; }
.pdf:lang(ko-KR) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK KR'; }
.pdf .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.highlight-default {
	color: rgba(55, 53, 47, 1);
}
.highlight-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.highlight-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.highlight-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.highlight-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.highlight-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.highlight-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.highlight-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.highlight-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.highlight-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.highlight-gray_background {
	background: rgba(241, 241, 239, 1);
}
.highlight-brown_background {
	background: rgba(244, 238, 238, 1);
}
.highlight-orange_background {
	background: rgba(251, 236, 221, 1);
}
.highlight-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.highlight-teal_background {
	background: rgba(237, 243, 236, 1);
}
.highlight-blue_background {
	background: rgba(231, 243, 248, 1);
}
.highlight-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.highlight-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.highlight-red_background {
	background: rgba(253, 235, 236, 1);
}
.block-color-default {
	color: inherit;
	fill: inherit;
}
.block-color-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.block-color-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.block-color-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.block-color-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.block-color-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.block-color-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.block-color-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.block-color-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.block-color-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.block-color-gray_background {
	background: rgba(241, 241, 239, 1);
}
.block-color-brown_background {
	background: rgba(244, 238, 238, 1);
}
.block-color-orange_background {
	background: rgba(251, 236, 221, 1);
}
.block-color-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.block-color-teal_background {
	background: rgba(237, 243, 236, 1);
}
.block-color-blue_background {
	background: rgba(231, 243, 248, 1);
}
.block-color-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.block-color-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.block-color-red_background {
	background: rgba(253, 235, 236, 1);
}
.select-value-color-pink { background-color: rgba(245, 224, 233, 1); }
.select-value-color-purple { background-color: rgba(232, 222, 238, 1); }
.select-value-color-green { background-color: rgba(219, 237, 219, 1); }
.select-value-color-gray { background-color: rgba(227, 226, 224, 1); }
.select-value-color-opaquegray { background-color: rgba(255, 255, 255, 0.0375); }
.select-value-color-orange { background-color: rgba(250, 222, 201, 1); }
.select-value-color-brown { background-color: rgba(238, 224, 218, 1); }
.select-value-color-red { background-color: rgba(255, 226, 221, 1); }
.select-value-color-yellow { background-color: rgba(253, 236, 200, 1); }
.select-value-color-blue { background-color: rgba(211, 229, 239, 1); }

.checkbox {
	display: inline-flex;
	vertical-align: text-bottom;
	width: 16;
	height: 16;
	background-size: 16px;
	margin-left: 2px;
	margin-right: 5px;
}

.checkbox-on {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
}

.checkbox-off {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
}
	
</style></head><body><article id="3c47b53a-1d1c-44ef-be4b-19d7a9c9d09a" class="page sans Notion" style="width: 100%; padding: 0px;"><div class="page-body"><h2 id="38045344-cb66-4db4-b8c9-95b9066d82ab" class=""><details open=""><summary><mark class="highlight-blue">9.1</mark> Physical and Virtual Addressing</summary></details></h2><div class="indented"><ul id="7425fa91-4984-45e5-95d0-06184d8b6d81" class="toggle"><li><details open=""><summary><strong>Physical Addressing</strong></summary><figure id="5a7bd910-5ead-4ffa-8341-c30d54d51fa0" class="image"><a href="/assets/images/CSAPP-9/Untitled.png"><img style="width:192px" src="/assets/images/CSAPP-9/Untitled.png"/></a></figure><p id="eab60a4c-0a96-4c44-897d-0f8573935985" class="">The main memory is organized as an array of <em>M </em>contiguous byte-size cells. Each byte has a unique <strong>physical address(PA)</strong>.</p><p id="3aaabe19-5708-429f-b9dd-80b8e66f784f" class=""><strong>Physical addressing</strong> refers to the approach that <strong>using physical address</strong> for CPU to access memory.</p></details></li></ul><ul id="05060500-eb15-4d48-8b40-2b1292feb587" class="toggle"><li><details open=""><summary><strong>Virtual Addressing</strong></summary><figure id="ffea1e3d-c246-4d8d-82e1-31cb054a50c5" class="image"><a href="/assets/images/CSAPP-9/Untitled%201.png"><img style="width:288px" src="/assets/images/CSAPP-9/Untitled%201.png"/></a></figure><p id="744dada3-277b-4941-9b3b-52ad75a7598e" class="">With <strong>virtual addressing</strong>, the CPU accesses main memory by generating <strong>virtual address(VA).</strong></p><p id="43128444-5d7d-404f-b411-89ca7d414971" class="">Virtual address is <strong>converted </strong>to the appropriate physical address before being sent to main memory - The <strong>memory management unit (MMU)</strong> translates virtual addresses using a lookup table stored in main memory whose contents are managed by the <strong>OS</strong>. </p></details></li></ul></div><h2 id="91dc780a-e9e2-4711-a342-4e646e5f69cf" class=""><details open=""><summary><mark class="highlight-blue">9.2</mark> Address Spaces</summary></details></h2><div class="indented"><p id="c39b4678-12a8-4576-89ed-9ef0f70cd900" class="">The CPU generates virtual addresses from an address space of <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>=</mo><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">N=2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span></span><span>ï»¿</span></span> addresses called the <strong>virtual address space</strong> : {0, 1, 2, ..., <em>N</em> - 1}. â†’ <strong>n-bit address space</strong>.</p><p id="a5878685-1e37-40c9-a299-36fd28e01678" class="">A system also has a <strong>physical address space</strong> that corresponds to the <em>M</em> bytes of physical memory in the space : {0, 1, 2, ..., <em>M</em> - 1}.</p><p id="ea6aa8b2-415d-4889-ae28-cf3a226b6a63" class="">Each <strong>byte </strong>of main memory has a <strong>virtual address</strong> chosen from the virtual address space, and a <strong>physical address</strong> chosen from the physical address space.</p></div><h2 id="622bc012-1888-4c34-9f04-a43393145f41" class=""><details open=""><summary><mark class="highlight-blue">9.3</mark> VM as a Tool for Caching</summary></details></h2><div class="indented"><ul id="ac33c018-d4b3-41e6-8895-2fb470fe36e3" class="toggle"><li><details open=""><summary><strong>Virtual Page</strong></summary><p id="80db086b-21e5-49e8-87c4-7885556c1d11" class=""><strong>Virtual memory</strong> is organized as an array of <em>N</em> contiguous byte-size cells stored on <strong>disk</strong>.</p><p id="ff0dc0b1-8a6b-4b9a-933f-beda290dd786" class=""><strong>Virtual memory</strong> is partitioned into <strong>fixed-size blocks</strong> called <strong>virtual pages</strong> (VPs). Similarly, <strong>physical memory</strong> is partitioned into <strong>physical pages</strong> (PPs). </p><p id="e23641fc-0148-45d7-9b8e-1acc8ee764b3" class="">Each virtual page and physical page is <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo>=</mo><msup><mn>2</mn><mi>p</mi></msup></mrow><annotation encoding="application/x-tex">P=2^p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span></span></span></span></span></span></span></span></span><span>ï»¿</span></span> bytes in size.</p><figure id="d9906809-17cc-4a0c-b5f3-017f8eef6b23" class="image"><a href="/assets/images/CSAPP-9/Untitled%202.png"><img style="width:240px" src="/assets/images/CSAPP-9/Untitled%202.png"/></a></figure><p id="abab9bff-6245-4a75-afb9-1e40ab774607" class="">The set of virtual pages is partitioned into 3 disjoint subsets:</p><ul id="51d07224-28b4-4e48-87d1-01beca724195" class="bulleted-list"><li style="list-style-type:disc"><strong>Unallocated </strong>: Pages that have <strong>not yet been allocated</strong> by the VM system. - donâ€™t occupy any space on disk.</li></ul><ul id="184ffaa3-6098-44af-9274-76ce544d1941" class="bulleted-list"><li style="list-style-type:disc"><strong>Cached </strong>: Allocated pages that are <strong>cached </strong>in physical memory.</li></ul><ul id="af9cf8ca-90f4-480f-ba8a-0bfacfe6d649" class="bulleted-list"><li style="list-style-type:disc"><strong>Uncached </strong>: Allocated pages that are <strong>not cached</strong> in physical memory.</li></ul></details></li></ul><ul id="95eae1c9-d2bf-44d3-ac3f-64c9501ea4f3" class="toggle"><li><details open=""><summary><strong>DRAM Cache Organization</strong></summary><p id="5c153feb-2a68-43b4-afd7-9c95cd89ef06" class="">The term <strong>DRAM cache</strong> denotes the <strong>VM systemâ€™s cache</strong> that <strong>caches virtual pages in main memory</strong>.</p><p id="6bf6ed00-7061-4336-a11e-2520196c1fe9" class="">DRAM cacheâ€™s <strong>large miss penalty</strong> &amp; the <strong>expense of accessing the first byte</strong> <strong>on disk</strong> â†’</p><ul id="cb3e5745-19aa-4840-afe5-3c1ef74adb4e" class="bulleted-list"><li style="list-style-type:disc">Virtual pages tend to be <strong>large</strong>.</li></ul><ul id="bcfe02b9-85cb-4b91-8c0f-31b19230d6a9" class="bulleted-list"><li style="list-style-type:disc">DRAM caches are <strong>fully associative</strong> â†’ Any virtual page <strong>can be placed in any physical page</strong>.</li></ul><ul id="dc182e71-eb8c-4956-8723-20b5cd007186" class="bulleted-list"><li style="list-style-type:disc">OS use much more <strong>sophisticated replacement algorithms </strong>for DRAM caches.</li></ul><ul id="351210ed-3dc3-4811-97bf-eac7fc4e7b9b" class="bulleted-list"><li style="list-style-type:disc">DRAM caches always use <strong>write-back </strong>instead of write-through.</li></ul></details></li></ul><ul id="8fa2f1c1-0434-429f-a5e8-c13256540b82" class="toggle"><li><details open=""><summary><strong>Page Tables</strong></summary><figure id="425939d7-f803-4878-9196-a7b13ea514dd" class="image"><a href="/assets/images/CSAPP-9/Untitled%203.png"><img style="width:336px" src="/assets/images/CSAPP-9/Untitled%203.png"/></a></figure><p id="84889063-583f-46a9-9d70-9f20f9d51003" class=""><strong>Virtual pages</strong> are managed by a combination of <strong>OS software</strong>, <strong>address translation hardware</strong> in the MMU, and a <strong>page table</strong> in physical memory that maps virtual pages to physical pages.</p><p id="b7be535e-522e-4690-a621-25e531006df5" class="">The <strong>address translation hardware</strong> reads the <strong>page table</strong> to convert a virtual address to a physical address. </p><p id="851d0f08-4a08-4d06-ade4-3df8cc6acc64" class="">The <strong>OS </strong>maintains the <strong>page table</strong>, and <strong>transfer pages</strong> back and forth between disk and DRAM.</p><p id="50231e13-d352-45f9-a9a4-c99b51ad0ccf" class="">The <strong>page table</strong> is an array of <strong>page table entries (PTEs).</strong> Each PTE consists of a <strong>valid bit</strong> and an <strong><em>n</em></strong><strong>-bit address field</strong>. </p><p id="ddae0559-8760-41c4-85bf-9febe98d5adb" class="">The <strong>valid bit </strong>indicates whether the virtual page is currently cached in DRAM:</p><ul id="9e12fe02-b1ec-4066-896a-83f352bbbbce" class="bulleted-list"><li style="list-style-type:disc">The valid bit is <strong>set </strong>â†’ the address field = the <strong>start of the corresponding physical page</strong> in DRAM where the virtual page is cached.</li></ul><ul id="09c41888-2289-4552-b3dc-ee2cb394a6bd" class="bulleted-list"><li style="list-style-type:disc">The valid bit is <strong>unset</strong><ul id="2a0e1275-2b61-429c-8f2c-4908aa9da34f" class="bulleted-list"><li style="list-style-type:circle">A <strong>null </strong>address â†’ the virtual page is <strong>unallocated</strong>.</li></ul><ul id="da9f55f4-752c-4af8-8459-5717472b015a" class="bulleted-list"><li style="list-style-type:circle"><strong>Otherwise </strong>â†’ the address points to the <strong>start of the virtual page</strong> on disk.</li></ul></li></ul></details></li></ul><ul id="c5572081-c03d-46b8-b0bf-1175d4ccf03b" class="toggle"><li><details open=""><summary><strong>Page Hits</strong></summary><ol type="1" id="2d90fbe3-d895-44b5-8571-891ce7d03035" class="numbered-list" start="1"><li>The <strong>address translation hardware</strong> uses the <strong>virtual address</strong> as an index to locate <strong>PTE </strong>and read it from memory.</li></ol><ol type="1" id="1b8b558e-4826-4282-832b-be3ebd555a03" class="numbered-list" start="2"><li>The valid bit is <strong>set </strong>â†’ <strong>Page Hit</strong></li></ol><ol type="1" id="47263856-3bdd-4890-a108-d1f17e8ed52c" class="numbered-list" start="3"><li>The <strong>address translation hardware</strong> uses the <strong>physical memory address</strong> in the PTE to construct the physical address of the word.</li></ol></details></li></ul><ul id="c7e7597c-5bbc-46ec-a441-ab134b2fa9d4" class="toggle"><li><details open=""><summary><strong>Page Faults</strong></summary><p id="aee9b042-b3f3-4584-bb50-d303fa65c707" class="">A DRAM cache miss is known as a page fault.</p><ol type="1" id="3c663449-f56f-490a-8b60-103d0e093bd3" class="numbered-list" start="1"><li>The address translation reads PTE from memory.</li></ol><ol type="1" id="c3a1e5a2-5110-4a87-9ee4-3bbc206e59a2" class="numbered-list" start="2"><li>The valid bit is <strong>unset </strong>â†’ <strong>Page Fault</strong></li></ol><ol type="1" id="b1ce5495-63c0-4921-89ac-d811cadaaa52" class="numbered-list" start="3"><li>The page fault exception invokes a <strong>page fault exception handler</strong> in the kernel.<ol type="a" id="e9c93491-e7fe-42b3-a072-7c5074f32fa1" class="numbered-list" start="1"><li>The kernel selects a <strong>victim page</strong>.</li></ol><ol type="a" id="d3d4adcb-38e9-44ff-8df1-40c68a203812" class="numbered-list" start="2"><li>If the victim page is modified, the kernel copies it back to disk.</li></ol><ol type="a" id="c6fd67ee-e53c-4bfa-9f8d-2abdec61c202" class="numbered-list" start="3"><li>The kernel modifies the page table entry for the victim page.</li></ol><ol type="a" id="5e21215d-a8f5-4500-bef9-3244abeabe4f" class="numbered-list" start="4"><li>The kernel copies missed page from disk to memory, updates PTE, and then returns.</li></ol></li></ol><ol type="1" id="017cc6cf-86cd-4292-b757-dbf5812f2ffd" class="numbered-list" start="4"><li>When the handler returns, the kernel <strong>restarts the faulting instruction</strong> â†’ <strong>Page Hit</strong></li></ol></details></li></ul><ul id="0ed5acc7-719c-4b12-bd10-ecd959e487e7" class="toggle"><li><details open=""><summary><strong>Allocating Pages</strong></summary><p id="a0f27288-3806-4e68-bb2f-7b1a916df4d7" class=""><strong>Allocating pages</strong> is done by <strong>creating room</strong> on disk and <strong>updating PTE</strong> to point to the newly created page on disk.</p></details></li></ul><ul id="12be8517-54dd-4452-8aef-f4afe1d5ff9f" class="toggle"><li><details open=""><summary><strong>Locality to the Rescue Again</strong></summary><p id="84a6df9d-ada8-41fc-ab82-c41f2b4b04a3" class="">In practice, virtual memory works well mainly because of <strong>locality</strong>.</p><p id="47652d9a-7750-4a28-8a86-53707e57fa52" class="">After an <strong>initial overhead </strong>where the working set is paged into memory, subsequent references to the working set result in <strong>hits</strong>, with no additional disk traffic.</p><p id="2ae7ce4c-a7fc-42ea-b289-31e990df1b12" class="">However, if the working set size <strong>exceeds </strong>the size of physical memory, the program can produce <strong>thrashing</strong>.</p></details></li></ul></div><h2 id="c5ac053f-a808-4d51-9b20-a53b6c2f86ce" class=""><details open=""><summary><mark class="highlight-blue">9.4</mark> VM as a Tool for Memory Management</summary></details></h2><div class="indented"><p id="32eddfe0-3289-4624-b66a-0eca563dccfa" class="">OS provide a <strong>separate page table</strong>, and thus a <strong>separate virtual address space</strong>, for each <strong>process</strong>.</p><figure id="887e6112-d6ec-4121-8d1c-38aa8058ab60" class="image"><a href="/assets/images/CSAPP-9/Untitled%204.png"><img style="width:336px" src="/assets/images/CSAPP-9/Untitled%204.png"/></a></figure><p id="3aa8b94d-735b-4457-8990-19666bfcb3f9" class="">Multiple virtual pages can be mapped to the same <strong>shared physical page</strong>.</p><p id="6871a122-d3c2-4dfa-84c1-e81b324f07f7" class="">VM simplifies linking and loading, the sharing of code and data, and allocating memory to applications :</p><ul id="e2f841d3-6a5d-4b76-ae94-0a7c51da2648" class="toggle"><li><details open=""><summary><strong>Simplifying linking</strong></summary><ul id="095192f5-7932-4e47-b990-935174ef9336" class="bulleted-list"><li style="list-style-type:disc">Separate address space â†’ Each process use the <strong>same basic format</strong> for its memory image.</li></ul><figure id="528cdbbd-030c-408d-b952-eb506f793e72" class="image"><a href="/assets/images/CSAPP-9/Untitled%205.png"><img style="width:288px" src="/assets/images/CSAPP-9/Untitled%205.png"/></a></figure><ul id="d9fe0d04-182a-48fd-b77b-2901d2bc6fc2" class="bulleted-list"><li style="list-style-type:disc">Uniformity <strong>simplifies </strong>the design and implementation of <strong>linkers</strong>. </li></ul><ul id="7186567d-b739-401f-9217-0c16e141ca05" class="bulleted-list"><li style="list-style-type:disc">Linker can produce fully linked executables that are <strong>independent</strong> of the ultimate location of the code and data in <strong>physical memory</strong>.</li></ul></details></li></ul><ul id="19dba01f-35c0-4b1f-8729-188271a64fda" class="toggle"><li><details open=""><summary><strong>Simplifying loading</strong></summary><ul id="7a7d5b17-88d8-4dfc-8f15-75fcf0dbabed" class="bulleted-list"><li style="list-style-type:disc">Linux loader <strong>loading </strong><strong><code>.text</code></strong><strong> &amp; </strong><strong><code>.data</code></strong><strong> sections</strong> of an object file into a <strong>newly created process</strong> :<ol type="1" id="574c00a9-9e00-40ce-a656-302f622194da" class="numbered-list" start="1"><li>Linux loader <strong>allocates virtual pages</strong> for the code and data segments.</li></ol><ol type="1" id="9ac942b0-d7e6-4641-b2fc-b646a0cd23b4" class="numbered-list" start="2"><li>Linux loader marks them as <strong>invalid </strong>(<strong>not cached</strong>).</li></ol><ol type="1" id="8ed3bd16-feb6-4c19-b298-f4b6e47a6549" class="numbered-list" start="3"><li>Linux loader <strong>points </strong>their <strong>page table entries</strong> to the appropriate locations in the object file.</li></ol><ol type="1" id="e4262fbf-502f-49a4-ac74-a3a76e48ed2a" class="numbered-list" start="4"><li>The data are <strong>paged in automatically</strong> by the VM system the <strong>first time each page is referenced</strong>. (When CPU fetches an instruction, or an executing instruction references a memory location.)</li></ol></li></ul><ul id="66665a37-d9a6-40a1-b7bc-dda2cecb05f7" class="bulleted-list"><li style="list-style-type:disc"><strong>Memory mapping</strong> : Mapping a set of contiguous virtual pages to an arbitrary location in an arbitrary file</li></ul><ul id="7ec460b9-dfae-410f-82be-2ca58f1d5303" class="bulleted-list"><li style="list-style-type:disc">Linux provides a <strong>system call </strong><strong><code>mmap</code></strong> - allows <strong>application programs</strong> to do their own memory mapping. (Section <strong><mark class="highlight-blue">9.8</mark></strong>)</li></ul></details></li></ul><ul id="a8283cfa-bc01-4268-9aec-3ccef8cc2a03" class="toggle"><li><details open=""><summary><strong>Simplifying sharing</strong></summary><ul id="2a31c793-7b27-4b98-83fa-76e1ee738e54" class="bulleted-list"><li style="list-style-type:disc">In some instances processes need to <strong>share code and data</strong>:<ul id="d9f95168-a958-46dc-a834-371602b6a2d9" class="bulleted-list"><li style="list-style-type:circle">Every process must call the same <strong>OS kernel code</strong>.</li></ul><ul id="23e2e87c-e25e-4cfd-b276-5490f36f8631" class="bulleted-list"><li style="list-style-type:circle">Every C program makes calls to routines in the <strong>standard C library</strong>. (<em>example : </em><code><em>printf</em></code>)</li></ul></li></ul><ul id="73ee7336-eb6e-4061-9e2d-6c5f7567b465" class="bulleted-list"><li style="list-style-type:disc">OS can arrange for multiple processes to <strong>share a single copy of code</strong> by <strong>mapping the appropriate virtual pages</strong> in different processes <strong>to the same physical pages</strong>.</li></ul><figure id="77451a82-5547-43a4-baa1-9328568c76a1" class="image"><a href="/assets/images/CSAPP-9/Untitled%204.png"><img style="width:336px" src="/assets/images/CSAPP-9/Untitled%204.png"/></a></figure></details></li></ul><ul id="63ecb9b5-e2ca-4bc1-be6b-d1bd30de16ff" class="toggle"><li><details open=""><summary><strong>Simplifying Memory Allocation</strong></summary><ul id="0b19a12b-2264-4a34-af69-9eee3d51d9b8" class="bulleted-list"><li style="list-style-type:disc">When a program running in a user process <strong>requests additional heap space</strong> (<em>example : </em><code><em>malloc</em></code>) :<ol type="1" id="0c819969-df07-4fb4-b7ce-e4a4d268445a" class="numbered-list" start="1"><li>OS <strong>allocates</strong> an appropriate number, <em>k</em>, of contiguous <strong>virtual memory pages.</strong></li></ol><ol type="1" id="9551fa9e-3961-44c7-9845-8e3262f57f70" class="numbered-list" start="2"><li>OS <strong>maps </strong>them to <em>k</em> arbitrary <strong>physical pages</strong> located <strong>anywhere </strong>in physical memory.<p id="54e9a0d1-b7ba-4505-b1d0-b1c89cea75ea" class="">There is no need for OS to locate <em>k</em> contiguous pages of physical memory. - The pages can be <strong>scattered randomly</strong>.</p></li></ol></li></ul></details></li></ul></div><h2 id="5d3e2487-2c53-41ee-81b3-ac9a70e9d586" class=""><details open=""><summary><mark class="highlight-blue">9.5</mark> VM as a Tool for Memory Protection</summary></details></h2><div class="indented"><ul id="9741cb11-a67c-4d70-b8b3-f43e509a1fed" class="toggle"><li><details open=""><summary><strong>Rules for Protecting Memory</strong></summary><ul id="28d3bf39-d58d-4ecd-a568-126f04c13dc9" class="bulleted-list"><li style="list-style-type:disc">A user process shouldnâ€™t be allowed to modify its <strong>read-only </strong>code section.</li></ul><ul id="f08f3482-9a92-4bae-838b-daf4682a5276" class="bulleted-list"><li style="list-style-type:disc">A user process shouldnâ€™t be allowed to read or modify any of the code and data in the <strong>kernel</strong>.</li></ul><ul id="ecb6ae16-fb01-4e5e-a5a5-8c2f24e602f4" class="bulleted-list"><li style="list-style-type:disc">A user process shouldnâ€™t be allowed to read or write the private memory of <strong>other processes</strong>.</li></ul><ul id="38cbc44c-9c75-4f61-b989-a7f28b814c4d" class="bulleted-list"><li style="list-style-type:disc">A user process shouldnâ€™t be allowed to modify any <strong>virtual pages that are shared</strong> with other processes, unless all parties explicitly allow it.</li></ul></details></li></ul><ul id="e4598d47-370b-4a49-b1da-2635973296c1" class="toggle"><li><details open=""><summary><strong>Adding Permission Bits to PTE</strong></summary><p id="1b277bb0-71e7-4702-8810-6a82f00b2e89" class="">Add three <strong>permission bits</strong> to each PTE to control access to the contents of a virtual page.</p><ul id="f7f2e419-1a68-4459-9d81-f7e0d8b44b92" class="bulleted-list"><li style="list-style-type:disc"><strong>SUP bit</strong> indicates whether processes must be running in <strong>kernel (supervisor) mode</strong> to access the page. (<strong>user process</strong> can access only page where <strong>SUP bit = 0</strong>)</li></ul><ul id="caf538a6-2f9b-4fff-a3c4-b71192207110" class="bulleted-list"><li style="list-style-type:disc"><strong>READ and WRITE bits</strong> control <strong>read and write access </strong>to the page.</li></ul><p id="6cd6c371-7d79-43d8-8969-e8a93472681f" class="">If an instruction violates these permissions (<strong>segmentation fault</strong>), CPU triggers a <strong>general protection fault handler</strong> in the kernel. - sends a <strong>SIGSEGV signal </strong>to the offending process.</p></details></li></ul></div><h2 id="6a249d3d-c6ef-4d00-afa7-a92a18487fc3" class=""><details open=""><summary><mark class="highlight-blue">9.6</mark> Address Translation</summary></details></h2><div class="indented"><ul id="5de95fb3-cc94-438a-9337-e6dc14afad16" class="toggle"><li><details open=""><summary><strong>Address Translation</strong></summary><p id="3ac298af-7a7e-4fb0-9e5d-a62cb5e8e616" class=""><strong>Address translation</strong> is a <strong>mapping </strong>between the elements of an <strong><em>N-</em></strong><strong>element virtual address space (VAS)</strong> and an <strong><em>M</em></strong><strong>-element physical address space (PAS)</strong>,</p><figure id="c233ad45-7076-4654-aaf6-06b691fc0872" class="image"><a href="/assets/images/CSAPP-9/Untitled%206.png"><img style="width:192px" src="/assets/images/CSAPP-9/Untitled%206.png"/></a></figure><p id="ff3bdc3b-b586-40c4-850b-8aa514e9b1b0" class="">where</p><figure id="6ca052b8-f26e-439f-a465-48c6184be4a0" class="image"><a href="/assets/images/CSAPP-9/Untitled%207.png"><img style="width:624px" src="/assets/images/CSAPP-9/Untitled%207.png"/></a></figure></details></li></ul><ul id="c7b499f7-1302-4845-ba65-11ead4dd570f" class="toggle"><li><details open=""><summary><strong>Address translation with a page table</strong></summary><figure id="80f3da64-3b18-49cb-8597-a58bfabd95e2" class="image"><a href="/assets/images/CSAPP-9/Untitled%208.png"><img style="width:432px" src="/assets/images/CSAPP-9/Untitled%208.png"/></a></figure><p id="6a42d75c-413b-4af0-a47a-f366c8b0ce91" class=""><strong>MMU </strong>uses the <strong>page table</strong> to perform <strong>address translation</strong>.</p><ul id="b110d0dd-1e15-43b1-a232-04c61796bb07" class="bulleted-list"><li style="list-style-type:disc">The <strong>page table base register (PTBR)</strong> points to the <strong>current page table</strong>.</li></ul><ul id="f8e14729-59e3-41cc-88fb-b296983f7aa5" class="bulleted-list"><li style="list-style-type:disc"><strong><em>n-</em></strong><strong>bit virtual address</strong> consists of a <strong><em>p</em></strong><strong>-bit virtual page offset (VPO)</strong> &amp; an <strong>(</strong><strong><em>n-p</em></strong><strong>)-bit virtual page number (VPN)</strong>.<ul id="ef3a013c-aba5-495e-b182-1f6851e8b2b5" class="bulleted-list"><li style="list-style-type:circle"><strong>VPN </strong>is used for MMU to select the appropriate PTE. (<em>example : VPN 0 selects PTE 0</em>)</li></ul></li></ul><ul id="0a49e14f-584d-4ac3-aa5a-c8d3d399cfce" class="bulleted-list"><li style="list-style-type:disc">Corresponding <strong><em>m</em></strong><strong>-bit physical address</strong> is the concatenation of <strong>physical page number (PPN) </strong>&amp; <strong>physical page offset (PPO)</strong>.<ul id="873383e5-be06-41ad-b92e-818d48ee27cf" class="bulleted-list"><li style="list-style-type:circle"><strong>PPN </strong>is from the <strong>PTE </strong>selected using VPN.</li></ul><ul id="cccb1182-eddf-431c-83cd-a45817c34085" class="bulleted-list"><li style="list-style-type:circle"><strong>PVO </strong>is identical to the <strong>VPO</strong>. (Physical and virtual pages are both <em>P </em>bytes.)</li></ul></li></ul><hr id="60f42ec3-e5da-4032-8eff-a7d55951ade6"/><ul id="ab6b4d23-8a76-4d4c-bdc7-04067a8cb7f1" class="bulleted-list"><li style="list-style-type:disc">The steps the <strong>CPU hardware</strong> performs when there is a <strong>page hit</strong>.<figure id="19ac37f7-de77-4258-aad5-6005b00508ef" class="image"><a href="/assets/images/CSAPP-9/Untitled%209.png"><img style="width:240px" src="/assets/images/CSAPP-9/Untitled%209.png"/></a></figure><ol type="1" id="006bb5a8-abeb-4446-8f0f-94cddecc4b03" class="numbered-list" start="1"><li>The processor generates a <strong>VA </strong>and sends it to the MMU.</li></ol><ol type="1" id="ee8ef0cd-26f5-4d11-80f2-1f5b3b0dbf47" class="numbered-list" start="2"><li>The MMU generates the <strong>PTE address (PTEA)</strong> and requests it from the cache/main memory.</li></ol><ol type="1" id="99be5a1d-705c-44a6-8e25-2e5a85d4bb96" class="numbered-list" start="3"><li>The cache/main memory returns the <strong>PTE </strong>to the MMU.</li></ol><ol type="1" id="5626ec4b-f358-4a55-aeb0-e8ffdc781917" class="numbered-list" start="4"><li>The MMU constructs the <strong>physical address (PA)</strong> and sends it to the cache/main memory.</li></ol><ol type="1" id="ba3a5e36-21d8-4f0b-ae1b-3ce40a63f0b9" class="numbered-list" start="5"><li>The cache/main memory returns the <strong>requested data word</strong> to the processor.</li></ol></li></ul><ul id="35901226-441a-4914-9f3e-d17002144d64" class="bulleted-list"><li style="list-style-type:disc">The steps the <strong>CPU hardware &amp; OS kernel</strong> performs when there is a <strong>page fault</strong>.<figure id="e10e7fa2-ccad-4be0-bea9-80b8226c9392" class="image"><a href="/assets/images/CSAPP-9/Untitled%2010.png"><img style="width:336px" src="/assets/images/CSAPP-9/Untitled%2010.png"/></a></figure><ol type="1" id="c03869ab-971d-449d-9907-6a9e8f2269a7" class="numbered-list" start="1"><li>The processor generates a <strong>VA </strong>and sends it to the MMU.</li></ol><ol type="1" id="bffdce2e-af82-436f-8cfc-c41ad070c3f6" class="numbered-list" start="2"><li>The MMU generates the <strong>PTE address (PTEA)</strong> and requests it from the cache/main memory.</li></ol><ol type="1" id="9a2df6f6-f186-4f15-960d-43366e0324dd" class="numbered-list" start="3"><li>The cache/main memory returns the <strong>PTE </strong>to the MMU.</li></ol><ol type="1" id="85cfb98a-2d9e-4625-b4f2-f8f7765e9373" class="numbered-list" start="4"><li>The <strong>valid bit</strong> in the PTE is <strong>zero </strong>â†’ MMU triggers an <strong>exception </strong>â†’ A <strong>page fault exception handler</strong> in <strong>OS kernel</strong> takes control.</li></ol><ol type="1" id="b48045cc-ffc6-4928-8b25-57ee747ea546" class="numbered-list" start="5"><li>The fault handler identifies a <strong>victim page</strong> in physical memory, and <strong>pages it out to disk</strong> if it has been modified.</li></ol><ol type="1" id="06bb199c-fe86-4bf9-821d-22be89dda1ec" class="numbered-list" start="6"><li>The fault handler <strong>pages in the new page</strong> and <strong>updates the PTE</strong> in memory.</li></ol><ol type="1" id="7b4437c7-2585-455a-bf5a-5ffa23284056" class="numbered-list" start="7"><li>The fault handler returns to the original process, <strong>restarting the faulting instruction</strong>. â†’ <strong>Page hit</strong></li></ol></li></ul></details></li></ul><ul id="d1f8207f-e470-45d4-a456-af008b083d22" class="toggle"><li><details open=""><summary><strong>Integrating Caches and VM</strong></summary><p id="88be48cb-37d3-4404-b3fd-b405d43683aa" class="">Most system that uses both <strong>VM and SRAM caches</strong> uses <strong>physical addressing</strong> to access the SRAM cache:</p><ul id="16dcf410-6344-4000-8a2d-3bedef245830" class="bulleted-list"><li style="list-style-type:disc">It is straightforward for multiple processes to <strong>have blocks in the cache at the same time</strong>, and to <strong>share blocks</strong> from the same virtual pages.</li></ul><ul id="3a55550c-24f2-475e-b063-0474717a3700" class="bulleted-list"><li style="list-style-type:disc">The cache doesnâ€™t have to deal with <strong>protection issues</strong> - access rights are checked as part of the address translation process.</li></ul><figure id="3747236e-732a-4829-b7c8-c309b9f9e99b" class="image"><a href="/assets/images/CSAPP-9/Untitled%2011.png"><img style="width:480px" src="/assets/images/CSAPP-9/Untitled%2011.png"/></a></figure><p id="2f78dc37-fa69-40dd-9915-060c29c3c08b" class="">In a system that uses both VM and SRAM cache, the <strong>address translation occurs before the cache lookup</strong>.</p><p id="dcffadd2-ab5d-4880-be4e-5c32b1944495" class=""><strong>PTEs can be cached </strong>just like any other data words. </p></details></li></ul><ul id="b232437a-626e-481d-9fe1-1162e84ffad4" class="toggle"><li><details open=""><summary><strong>Speeding Up Address Translation with a TLB</strong></summary><p id="881af628-fe98-4bc3-a15b-0a488f19aa67" class="">By including a <strong>small cache of PTEs</strong> in the MMU called a <strong>translation lookaside buffer (TLB)</strong>, we can speed up the address translation.</p><figure id="46409a4f-beac-4ced-91be-e52fb40b415b" class="image"><a href="/assets/images/CSAPP-9/Untitled%2012.png"><img style="width:336px" src="/assets/images/CSAPP-9/Untitled%2012.png"/></a></figure><ul id="4f39ec57-2537-4a03-8769-0d4bf5b953c7" class="bulleted-list"><li style="list-style-type:disc"><strong>TLB </strong>is a small, virtually addressed <strong>cache </strong>where each line holds a block consisting of a <strong>single PTE</strong>.</li></ul><ul id="8bd2c724-c745-4ac4-84b0-874d889dcc11" class="bulleted-list"><li style="list-style-type:disc">The <strong>index and tag fields</strong> for TLB are extracted from <strong>VPN</strong>.</li></ul><ul id="7ce1408e-bb06-44f0-8b10-458efa01739c" class="bulleted-list"><li style="list-style-type:disc">If the TLB has <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo>=</mo><msup><mn>2</mn><mi>t</mi></msup></mrow><annotation encoding="application/x-tex">T=2^t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7935559999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7935559999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span></span></span></span></span></span></span></span></span><span>ï»¿</span></span> sets, then the <strong>TLB index (TLBI)</strong> consists of the <strong><em>t</em></strong><strong> least significant bits of VPN</strong>, and the <strong>TLB tag (TLBT)</strong> constis of the <strong>remaining </strong><strong><em>n-p-t</em></strong><strong> bits in the VPN</strong>.</li></ul><hr id="9b0a1b65-d5a0-4392-98ed-ce984416f7db"/><ul id="0f78595f-72e9-41fd-b990-5c6d29f62fe5" class="bulleted-list"><li style="list-style-type:disc"><strong>TLB hit &amp; miss</strong></li></ul><figure id="1ad81da2-c6fe-48b6-8b05-f73a48c6a344" class="image"><a href="/assets/images/CSAPP-9/Untitled%2013.png"><img style="width:576px" src="/assets/images/CSAPP-9/Untitled%2013.png"/></a></figure><ul id="b93b3d99-2049-43e4-9477-a05788158140" class="bulleted-list"><li style="list-style-type:disc">The steps when there is a <strong>TLB hit</strong><ol type="1" id="04d028a9-153f-4baa-9e37-9223fbf631f3" class="numbered-list" start="1"><li>The CPU generates a <strong>VA</strong>.</li></ol><ol type="1" id="fba3c2ed-9e0a-46f3-853b-ab2e0b8d5f65" class="numbered-list" start="2"><li>The MMU fetches the <strong>appropriate PTE</strong> from TLB.</li></ol><ol type="1" id="4503441f-c5b1-434f-b222-e5a52ccd3c6b" class="numbered-list" start="3"><li>The MMU translates the VA to a <strong>PA </strong>and sends it to the cache/main memory.</li></ol><ol type="1" id="83fe207f-a0d6-42cd-9780-6a08c67ea3ae" class="numbered-list" start="4"><li>The cache/main memory returns the <strong>requested data word</strong> to the CPU.</li></ol></li></ul><ul id="5885941c-2ff9-4389-9699-7320c120adec" class="bulleted-list"><li style="list-style-type:disc">When there is a <strong>TLB miss, </strong>The MMU must <strong>fetch the PTE from the L1 cache</strong>. The newly fetched PTE is stored in the TLB, possibly overwriting an existing entry.</li></ul></details></li></ul><ul id="09c079bd-3585-48ba-a60f-fea3fcabded6" class="toggle"><li><details open=""><summary><strong>Multi-Level Page Tables</strong></summary><p id="fc5b6c2d-9e20-4ce1-b640-845873a65bf1" class="">Using a <strong>hierarchy of page tables </strong>is a common approach for <strong>compacting the page table </strong>to save memory.</p><figure id="9e3e0d6a-bbfe-4071-89fa-d4aa7e5f3cd8" class="image"><a href="/assets/images/CSAPP-9/Untitled%2014.png"><img style="width:384px" src="/assets/images/CSAPP-9/Untitled%2014.png"/></a></figure><ul id="6a35c137-d4b3-4596-afbb-1c1fee25eafc" class="bulleted-list"><li style="list-style-type:disc"><strong>Example of Multi-Level Page Tables</strong><ul id="38351226-e40b-4c67-a49d-7264cc04f451" class="bulleted-list"><li style="list-style-type:circle">Consider a <strong>32-bit VAS (4 GB)</strong> partitioned into <strong>4 KB pages</strong>, with <strong>PTE </strong>that are <strong>4 bytes</strong> <strong>each</strong>. </li></ul><ul id="86c2edaf-9a72-46ba-8cf3-15f8080a3948" class="bulleted-list"><li style="list-style-type:circle">Suppose that the VAS has the form as shown in the figure.</li></ul><ul id="4c9a7362-e3ff-4967-a14a-e1d32bd0720c" class="bulleted-list"><li style="list-style-type:circle"><strong>Level 1 Page Table</strong><ul id="a5aa1d28-51af-45cb-a40b-080b1d8111a9" class="bulleted-list"><li style="list-style-type:square">Each <strong>PTE in level 1 </strong>is responsible for <strong>mapping a 4 MB chunk of the VAS</strong>, where each chunk consists of <strong>1024 contiguous pages</strong>.</li></ul><ul id="c13926c3-568b-456d-99d7-121a6ad8819b" class="bulleted-list"><li style="list-style-type:square">The VAS is 4 GB â†’ 1024 PTEs are sufficient to cover the entire space.</li></ul><ul id="9f666f12-4cc2-426d-adcd-434b595aca8c" class="bulleted-list"><li style="list-style-type:square">If <strong>every page </strong>in chunk <em>i</em> is <strong>unallocated</strong>, then level 1 PTE <em>i </em>is <strong>null</strong>.</li></ul><ul id="4bb15cd9-eff9-4011-bf2b-afbc14e6abbb" class="bulleted-list"><li style="list-style-type:square">If <strong>at least one</strong> <strong>page </strong>in chunk <em>i</em> is <strong>allocated</strong>, then level 1 PTE <em>i</em> points to the <strong>base of a level 2 page table</strong>.</li></ul></li></ul><ul id="3f7ef21d-f7e5-4b28-a8dc-6b3eec363815" class="bulleted-list"><li style="list-style-type:circle"><strong>Level 2 Page Table</strong><ul id="78e5cdbe-8bb7-431c-b2f2-5ec96ff3cace" class="bulleted-list"><li style="list-style-type:square">Each <strong>PTE in level 2</strong> is responsible for <strong>mapping a 4 KB page</strong> of virtual memory.</li></ul></li></ul></li></ul><ul id="6753a2cb-2491-436a-a533-f77bd0f51d72" class="bulleted-list"><li style="list-style-type:disc">Multi level page tables <strong>reduces memory requirements</strong> in two ways:<ul id="ebe3b691-4bab-4b4d-bb14-98c60d7e86b8" class="bulleted-list"><li style="list-style-type:circle">If a PTE in the level 1 table is <strong>null</strong>, the corresponding level 2 page table <strong>doesnâ€™t have to exist</strong>.</li></ul><ul id="7708fd20-8205-4216-8ace-86965578d773" class="bulleted-list"><li style="list-style-type:circle">Only the <strong>level 1 table</strong> needs to be in main memory <strong>at all times</strong>. Only the <strong>most heavily used</strong> <strong>level 2 page tables</strong> need to be <strong>cached </strong>in main memory.</li></ul></li></ul><ul id="25b882be-3ede-4ec4-a4a5-848b9985fb90" class="bulleted-list"><li style="list-style-type:disc"><strong>Address Translation with a </strong><strong><em>k</em></strong><strong>-level page table hierarchy</strong><figure id="d2d5d2a2-f3ad-45f9-bdd7-b6cc5c3259e2" class="image"><a href="/assets/images/CSAPP-9/Untitled%2015.png"><img style="width:336px" src="/assets/images/CSAPP-9/Untitled%2015.png"/></a></figure><ul id="13a97629-418e-4581-b2ed-8cccd4ed2da8" class="bulleted-list"><li style="list-style-type:circle">The virtual address is partitioned into <em>k</em> VPNs and a VPO.</li></ul><ul id="840d8c8d-5b7a-41e3-a404-0426536564e7" class="bulleted-list"><li style="list-style-type:circle">Each PTE in a <strong>level </strong><strong><em>j</em></strong> table, <em>1â‰¤jâ‰¤k-1</em>, points to the <strong>base </strong>of some page table at <strong>level </strong><strong><em>j+1</em></strong><em>.</em></li></ul><ul id="7936e2ec-dbbd-4dff-97b7-1707974eed3c" class="bulleted-list"><li style="list-style-type:circle">Each PTE in a <strong>level </strong><strong><em>k</em></strong><strong> </strong>table contains either the <strong>PPN </strong>of some physical page or the <strong>address of a disk block</strong>.</li></ul><ul id="ab698bc1-8069-4d7b-b897-f726910adf0e" class="bulleted-list"><li style="list-style-type:circle">MMU must <strong>access </strong><strong><em>k</em></strong><strong> PTEs</strong> to construct the physical address.</li></ul></li></ul></details></li></ul><ul id="25a02f86-a640-4487-878c-1abb1cf904e9" class="toggle"><li><details open=""><summary><strong>Putting it Together: End-to-End Address Translation</strong></summary><ul id="ccaa3f76-493e-430b-985f-34db0db47c44" class="bulleted-list"><li style="list-style-type:disc"><strong>Assumptions on the system</strong><ul id="fdfc85a1-ac0f-4c43-be44-f6303fc2ea17" class="bulleted-list"><li style="list-style-type:circle">The memory is byte addressable.</li></ul><ul id="efd5b5ee-eceb-46dc-be4d-849bb576b44a" class="bulleted-list"><li style="list-style-type:circle">Memory accesses are to <strong>1-byte words </strong>(not 4-byte words).</li></ul><ul id="66736e30-855c-467f-a336-58cf5f4dcbaf" class="bulleted-list"><li style="list-style-type:circle">Virtual addresses are 14 bits wide (<strong>n = 14</strong>)</li></ul><ul id="f9abd0e1-ec7d-4ebf-8a77-4a0a5bb9c19e" class="bulleted-list"><li style="list-style-type:circle">Physical addresses are 12 bits wide (<strong>m = 12</strong>).</li></ul><ul id="289f5647-f2b5-47ba-a1b9-59a60c14b437" class="bulleted-list"><li style="list-style-type:circle">The page size is 64 bytes (<strong>P = 64</strong>). â†’ <strong>p = 6</strong></li></ul><ul id="26e3c2ea-402d-4c31-aa04-e3b147656c44" class="bulleted-list"><li style="list-style-type:circle">The <strong>TLB </strong>is <strong>4-way set associative</strong> with <strong>16 total entries</strong>.</li></ul><ul id="4e96430c-18a6-4010-a4ab-5a5e1d652213" class="bulleted-list"><li style="list-style-type:circle">The <strong>L1 d-cache</strong> is physically addressed and <strong>direct mapped</strong>, with a <strong>4-byte line size</strong> and <strong>16 total sets</strong>.</li></ul></li></ul><ul id="62137189-92cf-47c0-8ee5-0129534bb7d9" class="bulleted-list"><li style="list-style-type:disc"><strong>Addressing for the system</strong><figure id="1e5da93f-6982-421d-bd29-e23255c37d2a" class="image"><a href="/assets/images/CSAPP-9/Untitled%2016.png"><img style="width:432px" src="/assets/images/CSAPP-9/Untitled%2016.png"/></a></figure><figure id="607e727e-4bca-4c41-849b-7478591618d4" class="image"><a href="/assets/images/CSAPP-9/Untitled%2017.png"><img style="width:336px" src="/assets/images/CSAPP-9/Untitled%2017.png"/></a></figure></li></ul><ul id="d3673653-0a8c-44b3-bdf2-d0d3ec42c4b6" class="bulleted-list"><li style="list-style-type:disc"><strong>TLB, Page Table, and Cache for the system</strong><figure id="66c18025-7df6-4832-b4b9-809944ad9f4f" class="image"><a href="/assets/images/CSAPP-9/Untitled%2018.png"><img style="width:384px" src="/assets/images/CSAPP-9/Untitled%2018.png"/></a></figure><ul id="5577ca54-900f-4ae4-8df9-98272c334fcf" class="bulleted-list"><li style="list-style-type:circle">In this system, the <strong>page table</strong> is a <strong>single-level</strong> design with a total of <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>8</mn></msup><mo>=</mo><mn>256</mn></mrow><annotation encoding="application/x-tex">2^8=256</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">256</span></span></span></span></span><span>ï»¿</span></span> PTEs.</li></ul></li></ul><ul id="3cd84424-0b96-4ea0-818b-8d6e12b41f65" class="bulleted-list"><li style="list-style-type:disc"><strong>Loading the byte at address </strong><strong><code>0x03d4</code></strong><ol type="1" id="efb48482-bad2-4fc3-99cb-1b17506d3453" class="numbered-list" start="1"><li>Get <strong>VPN, VPO, TLBT, TLBI</strong> from <strong>VA</strong>.</li></ol><ol type="1" id="d86af61d-f77c-46ab-931f-95c727b05380" class="numbered-list" start="2"><li><strong>TLB hit</strong> â†’ Get <strong>PPN </strong>from <strong>TLB</strong>.<p id="87505674-c222-4a98-a94a-626e166e301f" class=""><strong>TLB miss</strong> â†’ Fetch <strong>PPN </strong>from a PTE in the <strong>page table</strong>.</p></li></ol><ol type="1" id="6019c88b-daac-4f97-b616-7bfdd7b52b84" class="numbered-list" start="3"><li>The resulting PTE is <strong>invalid </strong>(<strong>Page fault</strong>) â†’ Invoke the <strong>page fault handler</strong> to page in the appropriate page. <p id="2cf1a2c6-f14e-4702-81c3-168494d29dc1" class="">Otherwise â†’ Construct <strong>PA</strong>. (<strong>PA = PPN + PPO</strong>)</p></li></ol><ol type="1" id="233c8260-1517-4a0b-9265-5d9c827e0445" class="numbered-list" start="4"><li>Get <strong>CT, CI, CO</strong> from PA.</li></ol><ol type="1" id="a3305724-54a7-4546-9728-8b02eb784b2c" class="numbered-list" start="5"><li><strong>Cache hit</strong> â†’ Read out the <strong>data </strong>from the cache.<p id="d4ca60a4-5aae-4f29-9411-c2959ebcbee7" class=""><strong>Cache miss</strong> â†’ <strong>Fetch the data</strong> from memory in the lower level.</p></li></ol></li></ul></details></li></ul></div><h2 id="5f9cbb0c-5c57-4eaa-bfbe-8f34b152af50" class=""><details open=""><summary><mark class="highlight-blue">9.7</mark> Case Study: The Intel Core i7/Linux Memory System</summary></details></h2><div class="indented"><ul id="bc011ea2-4efc-441e-ab67-e40022b9ae44" class="toggle"><li><details open=""><summary><strong>The Core i7 Memory System</strong></summary><figure id="242b75eb-72ca-4330-9c3a-bfe162383710" class="image"><a href="/assets/images/CSAPP-9/Untitled%2019.png"><img style="width:336px" src="/assets/images/CSAPP-9/Untitled%2019.png"/></a></figure><ul id="54f10306-d942-4316-964b-13caf083d5be" class="bulleted-list"><li style="list-style-type:disc">The current <strong>Core i7 </strong>implementations support a <strong>48-bit VAS &amp; a 52-bit PAS</strong>, along with a compatibility mode that supports <strong>32-bit VAS &amp; PAS</strong>.</li></ul><ul id="178506a0-e200-4986-bf3f-d606d6ee75ca" class="bulleted-list"><li style="list-style-type:disc">The processor package includes <strong>4 cores</strong>, a large <strong>L3 cache</strong> shared by all cores, and a <strong>DDR3 </strong>memory controller.</li></ul><ul id="aba629d2-eeb2-4828-b164-3211e6cb8bd0" class="bulleted-list"><li style="list-style-type:disc">Each core contains a <strong>hierarchy of TLBs</strong>, a <strong>hierarchy of d-caches and i-caches</strong>, and a set of <strong>fast point-to-point links</strong>.<ul id="36715555-0055-4700-b081-24aa223c8bf4" class="bulleted-list"><li style="list-style-type:circle">The<strong> fast point-to-point links</strong> are for <strong>communicating </strong>directly with the <strong>other cores</strong> and the <strong>external I/O bridge</strong>.</li></ul><ul id="d99cf291-1fb2-4f47-99db-d35e43fb1f7d" class="bulleted-list"><li style="list-style-type:circle">The <strong>TLBs </strong>are <strong>virtually addressed</strong>, and <strong>4-way set associative</strong>.</li></ul><ul id="3116031c-a5a4-4b1a-a203-c51cf678aa46" class="bulleted-list"><li style="list-style-type:circle">The<strong> L1, L2, L3 caches</strong> are <strong>physically addressed</strong>, with a <strong>block size of 64 bytes</strong>.</li></ul><ul id="793153c5-af71-4b11-8f8d-e640164149c2" class="bulleted-list"><li style="list-style-type:circle">The <strong>L1, L2 caches</strong> are <strong>8-way set associative</strong>, and <strong>L3</strong> is <strong>16-way set associative</strong>.</li></ul></li></ul><ul id="bd41ceb0-fe18-4df9-bf87-0954ca734ef4" class="bulleted-list"><li style="list-style-type:disc">The page size can be configured at start-up time as either 4KB or 4MB. Linux uses 4KB pages.</li></ul></details></li></ul><ul id="93cb3fb5-8dc6-4238-873f-be3f1dce5e71" class="toggle"><li><details open=""><summary><strong>Core i7 Address Translation</strong></summary><figure id="880d5007-c07f-4617-a091-8e2db0a34b7e" class="image"><a href="/assets/images/CSAPP-9/Untitled%2020.png"><img style="width:528px" src="/assets/images/CSAPP-9/Untitled%2020.png"/></a></figure><ul id="79471745-6b33-4de5-902f-7bc987c6cf95" class="bulleted-list"><li style="list-style-type:disc">The Core i7 uses a <strong>four-level page table hierarchy</strong>. </li></ul><ul id="2b070df5-2507-4b21-abf7-9efd75151883" class="bulleted-list"><li style="list-style-type:disc">When a Linux process is running, the <strong>page tables</strong> are <strong>all memory-resident</strong>, although the <strong>Core i7 architecture</strong> allows the page tables to be <strong>swapped in and out</strong>.</li></ul><ul id="38a52ddd-95ab-4d02-87bb-f1e40b61d759" class="bulleted-list"><li style="list-style-type:disc">The <strong>CR3 control register </strong>contains <strong>PA </strong>of the beginning of the <strong>level 1 page table</strong>. - The value of <strong>CR3 </strong>is part of each <strong>process context</strong>.</li></ul><ul id="f261a3c4-621f-4ad3-a44f-d1cbb8f0ba37" class="bulleted-list"><li style="list-style-type:disc"><strong>Format of entry in a level 1, level 2, and level 3 page table</strong><figure id="c9f25ed0-b03f-4bf0-8fc0-d38e5297f4b1" class="image"><a href="/assets/images/CSAPP-9/Untitled%2021.png"><img style="width:432px" src="/assets/images/CSAPP-9/Untitled%2021.png"/></a></figure><ul id="112e12db-03b9-4d4e-a717-2cb39da6e5e0" class="bulleted-list"><li style="list-style-type:circle"><strong>P = 1 </strong>(always in Linux) â†’ the <strong>address field</strong> contains a <strong>40-bit PPN</strong> that points to the beginning of the <strong>appropriate page table</strong>.</li></ul><ul id="8835c05d-a805-4bda-96d3-58a5ddb558c2" class="bulleted-list"><li style="list-style-type:circle"><strong>R/W bit</strong> : determines whether the contents of a page are <strong>read/write or read-only</strong>.</li></ul><ul id="a32a761e-9ae5-42ed-ac43-b22c243e098a" class="bulleted-list"><li style="list-style-type:circle"><strong>U/S bit</strong> : determines whether the page <strong>can be accessed in user mode, or not</strong> (protected from user programs).</li></ul><ul id="47cf32f6-471d-454d-b676-9d099d752e23" class="bulleted-list"><li style="list-style-type:circle"><strong>XD bit</strong> : can be used to <strong>disable instruction fetches</strong> from individual memory pages. â†’ can reduce the risk of buffer overflow attacks.</li></ul><ul id="1dfb4819-59ee-4295-88ea-8de371562a7c" class="bulleted-list"><li style="list-style-type:circle"><strong>A bit (reference bit)</strong> : is set each time a page is <strong>accessed</strong>.</li></ul></li></ul><ul id="5a7368bf-13f8-4bcf-a909-b1f370621cea" class="bulleted-list"><li style="list-style-type:disc"><strong>Format of entry in a level 4 page table</strong><figure id="c7a4331e-13a0-4f98-87a2-39c7b8262949" class="image"><a href="/assets/images/CSAPP-9/Untitled%2022.png"><img style="width:432px" src="/assets/images/CSAPP-9/Untitled%2022.png"/></a></figure><ul id="aaa1d917-e37e-49b1-8efb-fbee00a7a8cb" class="bulleted-list"><li style="list-style-type:circle"><strong>P = 1</strong> (always in Linux) â†’ the <strong>address field</strong> contains a <strong>40-bit PPN</strong> that points to the <strong>base of some page </strong>in <strong>physical memory</strong>.</li></ul><ul id="001cabb1-8e46-475b-96f8-4833da3765ee" class="bulleted-list"><li style="list-style-type:circle"><strong>D bit (dirty bit)</strong> : is set each time the page is <strong>written to</strong>. â†’ tells the kernel whether or not it must <strong>write back</strong> a victim page.</li></ul></li></ul><ul id="41b009de-f6af-4d5f-90ab-5babc7c9a94a" class="bulleted-list"><li style="list-style-type:disc">The <strong>36-bit VPN</strong> is partitioned into <strong>four 9-bit chunks</strong>, each of which is used as an <strong>offset </strong>into a page table.</li></ul><ul id="764f9195-a8b6-4f09-a122-e1384cb966d4" class="bulleted-list"><li style="list-style-type:disc">The <strong>CR3 register</strong> contains the <strong>physical address of the L1 page table</strong>.</li></ul></details></li></ul><ul id="0e6fc297-f77e-4569-a7e4-5ecaa6cbdcb2" class="toggle"><li><details open=""><summary><strong>Linux Virtual Memory System</strong></summary><p id="b8228759-7e4c-48aa-93c8-f43fc117d99f" class="">Linux maintains a <strong>separate VAS</strong> for <strong>each process.</strong></p><figure id="f02d8ebf-d849-46e9-a62f-adae502ce126" class="image"><a href="/assets/images/CSAPP-9/Untitled%2023.png"><img style="width:240px" src="/assets/images/CSAPP-9/Untitled%2023.png"/></a></figure><ul id="833f48a3-8dc8-4291-80d3-63c7bb68794b" class="bulleted-list"><li style="list-style-type:disc"><strong>The kernel virtual memory </strong>contains:<ul id="02d71332-afa8-4990-a859-71f13f633b72" class="bulleted-list"><li style="list-style-type:circle">Kernel <strong>code &amp; data</strong> structures</li></ul><ul id="9158aec4-ff65-4adf-af94-cf0a05647332" class="bulleted-list"><li style="list-style-type:circle"><strong>Physical pages</strong> that are <strong>shared </strong>by all processes.</li></ul><ul id="65c9c77e-be9f-4d35-85a3-3b0899f8801e" class="bulleted-list"><li style="list-style-type:circle">Linux also maps a set of contiguous virtual pages to the corresponding set of contiguous physical pages. â†’ The <strong>kernel </strong>can access <strong>any specific location in physical memory</strong> conveniently. (<em>example : when it needs to access page tables</em>)</li></ul><ul id="92c7b6ae-0264-4bd2-b337-887a2635462c" class="bulleted-list"><li style="list-style-type:circle">Data that <strong>differ</strong> for each process<ul id="0ac20549-ca1e-40ef-91ef-a0d25dbf2ca4" class="bulleted-list"><li style="list-style-type:square"><strong>Page tables</strong></li></ul><ul id="e7a4aa54-724f-4de0-926e-b7f2d1b50b5a" class="bulleted-list"><li style="list-style-type:square"><strong>Kernel stack</strong></li></ul><ul id="680d3cc3-b42f-4717-8979-2b347fd8debc" class="bulleted-list"><li style="list-style-type:square">Various data structures that keep track of the current organization of the VAS.</li></ul></li></ul></li></ul><p id="e5e64144-c9f0-4edd-a849-2e614716ba4c" class="">
</p></details></li></ul><ul id="40720bb4-3d77-4311-8e80-26ab2af3548a" class="toggle"><li><details open=""><summary><strong>Linux Virtual Memory Areas</strong></summary><p id="0827f74e-ce2b-45d5-b4d2-a36fb875f872" class="">An <strong>area </strong>is a contiguous chunk of allocated VM whose pages are related in some way. (<em>example : code seg, data seg, heap, â€¦</em>)</p><p id="a00a6157-cf95-4e60-8ccd-5ca8211b80a5" class="">Any virtual page that is <strong>not part of some area doesnâ€™t exist</strong> and <strong>canâ€™t be referenced</strong> by the process.</p><figure id="abfd5ae9-067f-4377-ba74-916778ee39f9" class="image"><a href="/assets/images/CSAPP-9/Untitled%2024.png"><img style="width:432px" src="/assets/images/CSAPP-9/Untitled%2024.png"/></a></figure><p id="f0dc05d9-8c5d-4ed9-9b51-09060538f772" class="">The kernel keeps track of the VMA in a process using the data structure in the figure.</p><ul id="6d8ad0ae-b2ae-4dbe-a362-f9a6e465302d" class="bulleted-list"><li style="list-style-type:disc">The kernel maintains a distinct <strong>task structure (</strong><strong><code>task_struct</code></strong><strong>)</strong> for each process.<ul id="bd26980f-ecd6-4a19-bdb3-587a1cd0c40d" class="bulleted-list"><li style="list-style-type:circle">The elements of <code>task_struct</code> either contain or point to <strong>all of the info that the kernel needs to run the process</strong>.<ul id="256db5cb-128c-41c7-ad90-85d8d1cdc0a9" class="bulleted-list"><li style="list-style-type:square"><strong>PID</strong></li></ul><ul id="85a0b24b-4051-46a3-82c0-6f2d7d00b0fb" class="bulleted-list"><li style="list-style-type:square">pointer to the <strong>user stack</strong></li></ul><ul id="963d8479-fa78-4ed2-93a6-0557f65ebb76" class="bulleted-list"><li style="list-style-type:square">name of the <strong>executable object file</strong></li></ul><ul id="2d15f50d-bf08-413d-aefc-48cd1ac920a1" class="bulleted-list"><li style="list-style-type:square"><strong>PC</strong></li></ul></li></ul><ul id="d6081878-0ea5-45e0-9f1f-ae5fd36dce3c" class="bulleted-list"><li style="list-style-type:circle">One of the entry points to an <strong><code>mm_struct</code></strong><strong> </strong>that characterizes the <strong>current state of VM</strong>.</li></ul></li></ul><ul id="90881e4d-a57a-49ff-a2e2-c0281af2958b" class="bulleted-list"><li style="list-style-type:disc"><strong><code>mm_struct</code></strong>&#x27;s two field<ul id="7bef1eac-d627-4072-a66b-1da8ed0e3c07" class="bulleted-list"><li style="list-style-type:circle"><strong><code>pgd</code></strong> : points to the <strong>base of the level 1 table</strong>. When the kernel run this process, it stores <code>pgd</code> in the <strong>CR3 control register</strong>.</li></ul><ul id="eb7bcbc4-8c51-4bfa-8da7-cdece73b9782" class="bulleted-list"><li style="list-style-type:circle"><strong><code>mmap</code></strong> : points to a list of <strong><code>vm_area_structs</code></strong> (area struct), each of which <strong>characterizes an area </strong>of the current VAS.</li></ul></li></ul><ul id="f9d7e592-7560-469b-8b2e-f847ca0aca7c" class="bulleted-list"><li style="list-style-type:disc"><strong><code>vm_are_struct</code></strong><ul id="3fe757a5-1da7-4857-b246-b58e67b2bf8b" class="bulleted-list"><li style="list-style-type:circle"><strong><code>vm_start</code></strong><strong> </strong>: points to the <strong>beginning</strong> of the area.</li></ul><ul id="f0241fbf-7260-4887-9f4d-b8eaa2d8441d" class="bulleted-list"><li style="list-style-type:circle"><strong><code>vm_end</code></strong><strong> </strong>: points to the <strong>end </strong>of the area.</li></ul><ul id="ef249e6f-e283-4371-99e1-558048ae106d" class="bulleted-list"><li style="list-style-type:circle"><strong><code>vm_prot</code></strong><strong> </strong>: describes the <strong>read/write permissions</strong> for all of the pages contained in the area.</li></ul><ul id="b75dd766-5571-4cd7-ad0a-417306bb2ca9" class="bulleted-list"><li style="list-style-type:circle"><strong><code>vm_flags</code></strong><strong> </strong>: describes (among other things) whether the pages in the area are <strong>shared </strong>with other processes or private to this process.</li></ul><ul id="55553f61-fadb-466a-a3bc-ef5a3f2f139d" class="bulleted-list"><li style="list-style-type:circle"><strong><code>vm_next</code></strong><strong> </strong>: points to the <strong>next area</strong> <strong>struct </strong>in the list.</li></ul></li></ul></details></li></ul><ul id="60aea582-a316-43a7-8609-6065859b6ae2" class="toggle"><li><details open=""><summary><strong>Linux Page Fault Exception Handling</strong></summary><p id="20b173a3-c16c-48d0-bb5a-f728f552e416" class="">When the MMU triggers a <strong>page fault</strong> while trying to translate some <strong>virtual address </strong><em><strong>A</strong></em>, the kernelâ€™s <strong>page fault handler</strong> performs the following steps :</p><figure id="24bc7eb0-ec8b-4f21-8d5d-3abcc8b9f9f9" class="image"><a href="/assets/images/CSAPP-9/Untitled%2025.png"><img style="width:384px" src="/assets/images/CSAPP-9/Untitled%2025.png"/></a></figure><ol type="1" id="0404596b-7aab-4e8a-9304-81d5fc82237a" class="numbered-list" start="1"><li><strong>Is VA</strong><em><strong> A</strong></em><strong> legal?</strong><p id="92342e94-5788-4791-8eb0-5a4429520fc9" class="">The handler checks if <em>A</em> lie within an area defined by some area struct.</p><ul id="190ce4f1-4953-42b8-bc05-345a91af79fb" class="bulleted-list"><li style="list-style-type:disc">The fault handler searches the list of area structs, comparing <em>A</em> with <code>vm_start</code> &amp; <code>vm_end</code> in each area struct.</li></ul><ul id="2987de31-1edd-4519-a17c-6971bf56e67b" class="bulleted-list"><li style="list-style-type:disc"><em>A</em> is not legal â†’ The handler triggers a segmentation fault, which terminates the process.</li></ul></li></ol><ol type="1" id="29c0df6e-46c2-42db-aadd-d9dad6425e67" class="numbered-list" start="2"><li><strong>Is the attempted memory access legal?</strong><p id="2ed244a9-180f-44b1-9f44-9c7171749db2" class="">The handler checks if the process have <strong>permission </strong>to read, write, or execute the pages in the area.</p><ul id="00d9db92-4056-43f8-b52a-87620a36d74a" class="bulleted-list"><li style="list-style-type:disc">The attempted access is not legal â†’ The handler triggers a protection exception, which terminates the process.</li></ul></li></ol><ol type="1" id="23a9578e-a984-4567-97ab-29f3a6a8b9be" class="numbered-list" start="3"><li><strong>Handle the page fault</strong><p id="6e231e05-b117-4e3c-a74c-278e5c9e4bcd" class="">At this point, the kernel knows that the page fault resulted from a <strong>legal operation on a legal VA.</strong> â†’ The kernel handles the fault.</p><ul id="03be8cc8-fccd-430a-a232-b47288b98bed" class="bulleted-list"><li style="list-style-type:disc">The handler <strong>selects </strong>a <strong>victim page</strong>, <strong>swaps out</strong> the <strong>victim page</strong> if itâ€™s <strong>dirty</strong>, swaps in the<strong> new page</strong>, and updates the <strong>page table</strong>.</li></ul><ul id="a6ef5a36-5552-446b-a5d7-a62b61d7e207" class="bulleted-list"><li style="list-style-type:disc">When the page fault <strong>handler returns</strong>, the CPU <strong>restarts the faulting instruction</strong>, which sends <em>A </em> to the MMU again.</li></ul></li></ol></details></li></ul></div><h2 id="00703025-d593-44c5-938c-79416745c0d9" class=""><details open=""><summary><mark class="highlight-blue">9.8 </mark>Memory Mapping</summary></details></h2><div class="indented"><ul id="17a35532-a7be-43e8-b194-fa1e39c3cf16" class="toggle"><li><details open=""><summary><strong>Initializing the Contents of Virtual Memory Area</strong></summary><p id="07e5e962-b773-46b7-bdcc-4cd5b7c79d38" class="">Linux <strong>initializes </strong>the contents of a <strong>virtual memory area</strong> by <strong>associating it with an object on disk</strong>. â†’ <strong>Memory mapping</strong></p><p id="36ff60e9-9020-4530-8209-2ff8923a6d2e" class="">Areas can be mapped to one of two types of objects:</p><ul id="8ff35867-810c-4485-8968-11eb7b2c3ffe" class="bulleted-list"><li style="list-style-type:disc"><strong>Regular file</strong> in the Linux file system<ul id="87b0ae5c-45b7-48eb-b10f-6df8b547aed7" class="bulleted-list"><li style="list-style-type:circle">An area can be mapped to a contiguous section of a regular disk file. (<em>example : executable object file</em>)</li></ul><ul id="549cd8f0-93f8-4496-b86c-8c154ce19005" class="bulleted-list"><li style="list-style-type:circle">The file section is divided into <strong>page-size pieces</strong>, with each piece containing the <strong>initial contents of a virtual page</strong>.</li></ul><ul id="6d116a1e-21ed-42b3-af3b-999b36e5eb00" class="bulleted-list"><li style="list-style-type:circle">The <strong>CPU first</strong> touches the page â†’ These <strong>virtual pages</strong> are actually <strong>swapped into physical memory</strong>. (<strong>demand paging</strong>)</li></ul><ul id="bee884da-e924-453b-9244-103faa67c3e0" class="bulleted-list"><li style="list-style-type:circle">If the area is larger than the file section, the area is padded with zeros.</li></ul></li></ul><ul id="d35476b7-c529-489e-bd02-4f4a5d5025d4" class="bulleted-list"><li style="list-style-type:disc"><strong>Anonymous file</strong><ul id="6ab7c478-bfa5-4a13-8023-54729507aaae" class="bulleted-list"><li style="list-style-type:circle">An area can be mapped to an <strong>anonymous file</strong> that <strong>contains all binary zeros.</strong></li></ul><ul id="f6c2fa32-74a5-4189-b471-9b55a14af614" class="bulleted-list"><li style="list-style-type:circle">The kernel performs the following steps for memory mapping:<ol type="1" id="f3969e50-661a-44cb-ad67-0e79931d3cc4" class="numbered-list" start="1"><li>The <strong>CPU touches a virtual page</strong> in the area mapped to anonymous file.</li></ol><ol type="1" id="18b7bdf0-54ef-4421-9a7f-40c217369ca3" class="numbered-list" start="2"><li>The kernel <strong>finds </strong>an appropriate <strong>victim page </strong>in PM, and swaps out it if itâ€™s dirty.</li></ol><ol type="1" id="2c6067bc-9c63-4bad-a8e9-9446baede301" class="numbered-list" start="3"><li>The kernel <strong>overwrites</strong> the victim page <strong>with binary zeros</strong>.</li></ol><ol type="1" id="d75a6083-e502-4851-ad19-a361b7f629bd" class="numbered-list" start="4"><li>The kernel <strong>updates the page table</strong> to mark the page as resident.</li></ol></li></ul><ul id="07de5241-661d-4bd6-bb45-5a73d4adc568" class="bulleted-list"><li style="list-style-type:circle">Pages in areas that are mapped to anonymous files are sometimes called <strong>demand-zero pages</strong>.</li></ul></li></ul><p id="536ebbe7-7b63-455f-a8ba-ac764740a9bd" class="">In either case, once a virtual page is initialized, it is swapped back and forth between a special <strong>swap file </strong>maintained by the kernel. </p><p id="5275b65f-32c0-4cc5-86f2-2f89d1ab69d0" class="">The <strong>swap space</strong> bounds the <strong>total amount of VPs</strong> that can be allocated by the currently running processes.</p><p id="7e64f810-45da-406b-a4df-596c98778531" class="">
</p></details></li></ul><ul id="4346a0c0-a38b-454e-8b28-dc0fd808bcce" class="toggle"><li><details open=""><summary><strong>Shared Objects Revisited</strong></summary><p id="2216724c-7a81-4284-8eb8-ee18cd3fe7da" class="">In general, many processes have <strong>identical read-only code</strong> areas. (<em>example : every C program requires functions from the standard C library.</em>)</p><p id="eb52a1a4-914a-489e-bebc-75b9164f30c1" class="">â‡’ <strong>Memory mapping</strong> provides a clean mechanism for controlling how objects are shared by multiple processes.</p><p id="5916beac-9322-4d3c-9d73-081a0d57a131" class="">An <strong>object </strong>can be <strong>mapped into an area of VM</strong> as either a <strong>shared object</strong> or a <strong>private object</strong>:</p><ul id="af9818ed-f0df-41e0-844e-af795642acca" class="bulleted-list"><li style="list-style-type:disc"><strong>Shared object</strong><ul id="8c68986b-92b9-4234-99e4-7fb26fec60e5" class="bulleted-list"><li style="list-style-type:circle">Any changes made to the area are <strong>visible to any other processes</strong> that have also mapped the shared object into their VM.</li></ul><ul id="736c30e1-6d88-4f20-80f7-0bbb33f47802" class="bulleted-list"><li style="list-style-type:circle">The changes are also <strong>reflected</strong> in the <strong>original object on disk</strong>.<figure id="888edb7e-b5b3-461f-af03-7516072bf2a0" class="image"><a href="/assets/images/CSAPP-9/Untitled%2026.png"><img style="width:384px" src="/assets/images/CSAPP-9/Untitled%2026.png"/></a></figure></li></ul><ul id="7220e2cc-1f52-445c-9065-06782241588b" class="bulleted-list"><li style="list-style-type:circle">Only <strong>a single copy of the shared objec</strong>t needs to be <strong>stored in PM,</strong> even though the object is mapped into multiple shared libraries.</li></ul><ul id="b9884997-2240-4866-97ec-cb9b65bebb7d" class="bulleted-list"><li style="list-style-type:circle">In the figure, the physical pages are being <strong>contiguous </strong>for convenience. - This is <strong>not </strong>true in general.</li></ul></li></ul><ul id="cca980e2-34c3-45b3-8047-d2b2bdda1636" class="bulleted-list"><li style="list-style-type:disc"><strong>Private object</strong><ul id="e7ed68e8-af65-4262-9d22-cd97da243e7d" class="bulleted-list"><li style="list-style-type:circle">Changes made to the area are <strong>not visible to other processes</strong>.</li></ul><ul id="149eb28f-e2cb-42ad-8cf9-a5dcc7ed3c23" class="bulleted-list"><li style="list-style-type:circle">The changes are <strong>not reflected</strong> to the object on disk.</li></ul><figure id="902a7fe9-ed38-4bf0-8e95-441f2f4abf19" class="image"><a href="/assets/images/CSAPP-9/Untitled%2027.png"><img style="width:528px" src="/assets/images/CSAPP-9/Untitled%2027.png"/></a></figure><ul id="ceaaea8d-ee2e-47d2-9a0c-271be925563a" class="bulleted-list"><li style="list-style-type:circle">Private objects are mapped into VM using a technique known as <strong>copy-on-write</strong>.<ol type="1" id="f4d1feee-4e51-4b94-a666-c642dd69ee3b" class="numbered-list" start="1"><li>A private object begins life in the <strong>same way</strong> as a <strong>shared object</strong>.<p id="607e215b-ac06-4fdb-99fa-c0afbdd03df4" class="">For each process that maps the private object, the <strong>PTEs </strong>for the corresponding area are flagged as <strong>read-only</strong>, and the <strong>area struct</strong> is flagged as <strong>private copy-on-write</strong>.</p></li></ol><ol type="1" id="f163149b-79ac-4d54-bb6c-6b8308783a9a" class="numbered-list" start="2"><li>As long as neither process attempts to write to its respective private area, they continue to <strong>share a single copy</strong> in physical memory.</li></ol><ol type="1" id="daf9c500-87d2-44e3-8cda-fcb765026094" class="numbered-list" start="3"><li>As soon as a process <strong>attempts to write</strong> to some page in the private area, the write triggers a <strong>protection fault</strong>.</li></ol><ol type="1" id="e95db06d-a0fe-41fa-bd76-110fd9dee69f" class="numbered-list" start="4"><li>The <strong>fault handler</strong> creates a <strong>new copy</strong> of the page in physical memory, <strong>updates the PTE</strong> to point to the new copy and <strong>restores write permissions</strong> to the page. </li></ol><ol type="1" id="8770a15a-267a-44d2-b428-33571d98b8c9" class="numbered-list" start="5"><li>When the handler returns, the CPU <strong>re-executes</strong> the write, which now proceeds normally on the newly created page.</li></ol></li></ul></li></ul></details></li></ul><ul id="b99ec118-3314-473c-a541-e20cbc85f717" class="toggle"><li><details open=""><summary><strong>The </strong><strong><code>fork</code></strong><strong> Function Revisited</strong></summary><p id="dcd3c2bf-5478-49c0-bbde-59a8cda20d6e" class="">When the <strong><code>fork</code></strong><strong> function</strong> is called by the current process, it performs the following steps:</p><ul id="311c85be-1ebc-4778-b5f7-ca9e62a9e9d4" class="bulleted-list"><li style="list-style-type:disc">It creates exact <strong>copies </strong>of the current processâ€™s <strong><code>mm_struct</code></strong><strong>, area structs, and page tables</strong>.</li></ul><ul id="93a139f3-3568-427d-b6a0-0064ff609c7b" class="bulleted-list"><li style="list-style-type:disc">It flags each <strong>page </strong>in both processes as <strong>read-only</strong>, and flags each <strong>area struct</strong> in both processes as <strong>private copy-on-write</strong>.</li></ul><p id="0dfd5095-e274-4a00-a6a9-198c9d7b8df3" class="">After the <code>fork</code> returns, if either of the processes performs any <strong>subsequent writes</strong>, the <strong>copy-on-write mechanism</strong> creates new pages.</p></details></li></ul><ul id="ddf6aba4-b4d1-456b-b0c1-f413fb4a5aa8" class="toggle"><li><details open=""><summary><strong>The </strong><strong><code>execve</code></strong><strong> Function Revisited</strong></summary><figure id="5eb9e9b7-ac82-482f-b5b4-97f58716b859" class="image"><a href="/assets/images/CSAPP-9/Untitled%2028.png"><img style="width:288px" src="/assets/images/CSAPP-9/Untitled%2028.png"/></a></figure><p id="0dcc67a2-faad-416c-8259-4892b94f1168" class="">The <code>execve</code> <strong>loads and runs</strong> the program by performing the following steps:</p><ol type="1" id="369845d6-3f2e-4ca8-b479-18a6e59f4a65" class="numbered-list" start="1"><li><strong>Delete existing area</strong> <strong>structs </strong>in the user virtual address space.</li></ol><ol type="1" id="26e51cdd-2bfe-4566-be30-ccb9c2505f52" class="numbered-list" start="2"><li>Map private areas.<ul id="7a7b3687-56d2-4317-9ff6-94223e2b4c3a" class="bulleted-list"><li style="list-style-type:disc">Create <strong>new area structs</strong> for the <strong>code, data, bss, and stack areas</strong> of the new program.</li></ul><ul id="37a61dc5-9ef8-4973-b38e-bfc8dda568ae" class="bulleted-list"><li style="list-style-type:disc">All of these new areas are <strong>private copy-on-write</strong>.</li></ul><ul id="5dbb20a0-77ab-4dc8-9ac8-b5d2a513c236" class="bulleted-list"><li style="list-style-type:disc">The <strong>code and data</strong> areas are mapped to the <strong><code>.text</code></strong><strong> and </strong><strong><code>.data</code></strong> sections.</li></ul><ul id="fb7f9d20-95a6-460e-958a-9863efed5d37" class="bulleted-list"><li style="list-style-type:disc">The<strong> bss area</strong> is <strong>demand-zero, </strong>mapped to an <strong>anonymous file</strong> whose size is contained in the object file.</li></ul><ul id="5db12ae2-e023-431e-bf9c-a385b266ac58" class="bulleted-list"><li style="list-style-type:disc">The <strong>stack and heap area</strong> are also <strong>demand-zero</strong>, initially of <strong>zero length</strong>.</li></ul></li></ol><ol type="1" id="e98099d3-954c-4088-b331-75a84a640cc6" class="numbered-list" start="3"><li>If the object file was linked with <strong>shared objects</strong>, these objects are <strong>dynamically linked</strong> into the program, and then mapped into the <strong>shared region </strong>of the user VAS.</li></ol><ol type="1" id="76c1e873-a296-48db-8586-35ceb1aea913" class="numbered-list" start="4"><li>Set the <strong>PC </strong>in the current processâ€™s context to point to the <strong>entry point</strong> in the code area.</li></ol></details></li></ul><ul id="ee2dd1e0-fb13-4ddb-b548-68b9a01e7fde" class="toggle"><li><details open=""><summary><strong>User-Level Memory Mapping with the </strong><strong><code>mmap</code></strong><strong> Function</strong></summary><figure id="a3c0524b-e2e0-47e8-bb66-a56240a50912" class="image"><a href="/assets/images/CSAPP-9/Untitled%2029.png"><img style="width:288px" src="/assets/images/CSAPP-9/Untitled%2029.png"/></a></figure><pre id="645a51bc-23cc-4a8f-932e-49ffc8cd918d" class="code"><code>#include &lt;unistd.h&gt;
#include &lt;sys/main.h&gt;

void *mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset);</code></pre><ul id="b93f7bd9-3ca5-426b-aa1d-a4f073380ce7" class="bulleted-list"><li style="list-style-type:disc"><strong><code>mmap</code></strong><strong> </strong>asks the kernel to <strong>create a new VM area</strong>, preferably one that <strong>starts at </strong><strong><code>start</code></strong>, and to <strong>map </strong>a <strong>contiguous chunk of the object </strong>specified by <strong>file descriptor </strong><strong><code>fd</code></strong> to the new area. (<strong><code>start</code></strong><strong> </strong>is usually specified as <strong>NULL</strong>.)</li></ul><ul id="7917a75b-3bd7-4eb8-a6a8-a43167092bc2" class="bulleted-list"><li style="list-style-type:disc">The <strong>contiguous object chunk</strong> has a <strong>size of </strong><strong><code>length</code></strong><strong> bytes</strong> and starts at an <strong>offset of </strong><strong><code>offset</code></strong><strong> bytes</strong> from the beginning of the file.</li></ul><ul id="6faa9854-edb4-4a54-b0c2-129151dcc3d2" class="bulleted-list"><li style="list-style-type:disc"><strong><code>prot</code></strong> contains bits that describe the <strong>access permissions</strong> of the newly mapped VM area.<ul id="378cd17c-94e5-4086-af80-6b051dde1874" class="bulleted-list"><li style="list-style-type:circle"><code>PROT_EXEC</code> : Pages in the area consist of instructions that <strong>may be executed</strong> by the CPU.</li></ul><ul id="f036ce10-5be2-4713-abc6-f203a58fec61" class="bulleted-list"><li style="list-style-type:circle"><code>PROT_READ</code> : Pages in the area <strong>may be read</strong>.</li></ul><ul id="60965846-7308-499b-844f-3ff4037bcad6" class="bulleted-list"><li style="list-style-type:circle"><code>PROT_WRITE</code> : Pages in the area <strong>may be written</strong>.</li></ul><ul id="b549fd13-3235-450e-a1bc-f94f43d8bc48" class="bulleted-list"><li style="list-style-type:circle"><code>PROT_NONE</code> : Pages in the area <strong>canâ€™t be accessed</strong>.</li></ul></li></ul><ul id="cdafb29c-ba64-4a01-9f6c-3a4cca87e816" class="bulleted-list"><li style="list-style-type:disc"><code>flags</code> consists of bits that describe the <strong>type of the mapped object</strong>.<ul id="fe8e53ca-9f74-4df5-80f1-b120f7dc37dc" class="bulleted-list"><li style="list-style-type:circle"><code>MAP_ANON</code> is set : the mapped object is an <strong>anonymous object</strong> and the corresponding virtual pages are <strong>demand-zero</strong>.</li></ul><ul id="271719ea-9912-4838-9743-18e66cf09490" class="bulleted-list"><li style="list-style-type:circle"><code>MAP_PRIVATE</code> is set : the mapped object is a <strong>private copy-on-write object</strong>.</li></ul><ul id="29d64863-4d5c-45c5-b40f-ff107fe2a541" class="bulleted-list"><li style="list-style-type:circle"><code>MAP_SHARED</code> is set : the mapped object is a <strong>shared object</strong>.</li></ul></li></ul><ul id="e7725481-de92-489b-92fb-ea1d27ed2e4e" class="bulleted-list"><li style="list-style-type:disc"><em><code>bufp = Mmap(NULL, size, PROT_READ, MAP_PRIVATE|MAP_ANON, 0, 0);</code></em><em> â†’ asks the kernel to create a new read-only, private, demand-zero area of VM containing </em><em><code>size</code></em><em> bytes.</em></li></ul><pre id="e5acd89d-7c69-4ad6-9677-4e3f22986992" class="code"><code>#include &lt;unistd.h&gt;
#include &lt;sys/main.h&gt;

void munmap(void *start, size_t length);</code></pre><ul id="8fdf6b23-18ba-422e-bcad-0ad05ea127a5" class="bulleted-list"><li style="list-style-type:disc"><strong><code>munmap</code></strong><strong> deletes </strong>the area starting at virtual address <code>start</code> and consisting of the next <code>length</code> bytes.</li></ul><ul id="049d9bf7-131c-40cf-8b93-a8f402d0ad52" class="bulleted-list"><li style="list-style-type:disc">Subsequent references to the deleted region result in <strong>segmentation fault</strong>.</li></ul></details></li></ul></div><h2 id="9243acb8-3f3f-4a43-ae92-db03a73b5f05" class=""><details open=""><summary><mark class="highlight-blue">9.9 </mark>Dynamic Memory Allocation</summary></details></h2><div class="indented"><ul id="84fa5434-f33d-40b9-b050-f79f666f8ed1" class="toggle"><li><details open=""><summary><strong>Dynamic Memory Allocator</strong></summary><p id="e90815a0-2b2c-4608-a2cd-8f5f33198f98" class="">A <strong>dynamic memory allocator</strong> maintains an area of a processâ€™s VM known as the <strong>heap</strong>.</p><figure id="ae5ea77f-6476-44ff-9db4-54dcbe901c6c" class="image"><a href="/assets/images/CSAPP-9/Untitled%2030.png"><img style="width:240px" src="/assets/images/CSAPP-9/Untitled%2030.png"/></a></figure><ul id="5b82b2b8-e0cd-4f62-a6bf-c597addbe4f2" class="bulleted-list"><li style="list-style-type:disc">The <strong>heap </strong>is an area of <strong>demand-zero memory</strong> that begins immediately <strong>after the uninitialized data area</strong> and <strong>grows upward</strong>.</li></ul><ul id="ae22f270-d5fd-46e8-ac8a-2f5c807a2928" class="bulleted-list"><li style="list-style-type:disc">The kernel maintains a variable <strong><code>brk</code></strong><strong> </strong>that points to the top of the heap for each process.</li></ul><ul id="975545dd-d220-4260-a289-9db99d796a36" class="bulleted-list"><li style="list-style-type:disc">The heap is maintained as a collection of various-size <strong>blocks</strong>.<ul id="264a1d50-2449-4b20-9651-3823f0358a5b" class="bulleted-list"><li style="list-style-type:circle">Each <strong>block </strong>is a <strong>contiguous chunk of VM</strong> that is either <strong>allocated or free</strong>.</li></ul><ul id="08951d02-cc50-4e83-aa1d-5d2f6123a85a" class="bulleted-list"><li style="list-style-type:circle">An <strong>allocated block</strong> remains allocated until it is <strong>freed </strong>either <strong>explicitly </strong>by the application or <strong>implicitly </strong>by the memory allocator itself.</li></ul></li></ul><ul id="b64be244-5533-4d7c-9be9-36f1bae80bf6" class="bulleted-list"><li style="list-style-type:disc">Allocator comes in two basic styles that differ about which entity is responsible for freeing allocated blocks.<ul id="0ee2ea1c-094e-4619-9632-68ea077bbbc1" class="bulleted-list"><li style="list-style-type:circle">Explicit allocators require the <strong>application </strong>to <strong>explicitly free</strong> any allocated blocks. (<em>example : C standard library provides an explicit allocator called the </em><code><em>malloc</em></code><em> package.</em>)</li></ul><ul id="7efc925d-4a86-4bcf-baa6-2ba2319a35f7" class="bulleted-list"><li style="list-style-type:circle">Implicit allocators require the <strong>allocator </strong>to <strong>detect </strong>when an allocated block is no longer being used and then <strong>free </strong>the block. (<em>example : garbage collectors</em>) â†’ <strong>Section </strong><strong><mark class="highlight-blue">9.10</mark></strong></li></ul></li></ul></details></li></ul><ul id="e85694b7-372c-4a3b-b9ef-5bc9defe200f" class="toggle"><li><details open=""><summary><strong>The </strong><strong><code>malloc</code></strong><strong> and </strong><strong><code>free</code></strong><strong> Functions - </strong><strong><code>malloc</code></strong><strong>, </strong><strong><code>free</code></strong><strong>, </strong><strong><code>sbrk</code></strong></summary><pre id="e6d37f9f-854b-4712-b68e-be5add6fa781" class="code"><code>#include &lt;stdlib.h&gt;

void *malloc(size_t size);</code></pre><ul id="d345433b-d44f-46ba-bea7-f12bb41e92bf" class="bulleted-list"><li style="list-style-type:disc">The <strong><code>malloc</code></strong><strong> </strong>returns a <strong>pointer </strong>to a <strong>block memory </strong>of at least <strong><code>size</code></strong><strong> bytes </strong>that is suitably <strong>aligned for any kind of data object.</strong></li></ul><ul id="8e36cfe8-1e12-42c1-96cb-7f7243da929d" class="bulleted-list"><li style="list-style-type:disc">In <strong>32-bit mode</strong>, <code>malloc</code> returns a block whose address is always a <strong>multiple of 8</strong>. In <strong>64-bit mode</strong>, the address is always a <strong>multiple of 16</strong>.</li></ul><ul id="78819fe0-35ca-49a2-b637-83230e075adf" class="bulleted-list"><li style="list-style-type:disc">If <code>malloc</code> encounters a <strong>problem</strong>, it returns <strong>NULL </strong>and sets <strong><code>errno</code></strong>.</li></ul><ul id="2b613c40-d3be-41d7-a946-5742ec7e7c4f" class="bulleted-list"><li style="list-style-type:disc"><code>malloc</code> <strong>doesnâ€™t initialize</strong> the memory it returns. - Use <strong><code>calloc</code></strong>, a thin wrapper around the <code>malloc</code> that <strong>initializes the allocated memory to zero</strong>.</li></ul><ul id="3a762536-b032-4a83-88ec-31f90f80b4b0" class="bulleted-list"><li style="list-style-type:disc">To change the size of a previously allocated block, use the <strong><code>realloc</code></strong>.</li></ul><pre id="6aeb773c-904e-46ad-9835-051e07daf02a" class="code"><code>#include &lt;unistd.h&gt;

void *sbrk(intptr_t incr);</code></pre><ul id="1a0c8084-ec7f-4814-9af5-42a55d6b4b34" class="bulleted-list"><li style="list-style-type:disc">Dynamic memory allocators can allocate heap memory explicitly by using the <code>mmap</code> and <code>munmap</code>, or they can use <strong><code>sbrk</code></strong><strong> function</strong>.</li></ul><ul id="507c3bf1-3c5a-4a0e-829c-b1e563102a11" class="bulleted-list"><li style="list-style-type:disc"><code>sbrk</code> grows or shrinks the heap by <strong>adding </strong><strong><code>incr</code></strong><strong> to the kernelâ€™s </strong><strong><code>brk</code></strong><strong> pointer</strong>.</li></ul><ul id="873c7878-e5de-4508-8b29-05411a0e0128" class="bulleted-list"><li style="list-style-type:disc">If successful, it returns the <strong>old value of </strong><strong><code>brk</code></strong>, otherwise it returns -1 and sets <code>errno</code> to ENOMEM.</li></ul><pre id="49995fc7-b0da-4b20-83c5-28c552231f25" class="code"><code>#include &lt;stdlib.h&gt;

void free(void *ptr);</code></pre><ul id="fed9e30e-c8ae-49d6-8983-e30e927a3e9c" class="bulleted-list"><li style="list-style-type:disc">Programs free allocated heap blocks by calling the <code>free</code>.</li></ul><ul id="5e443034-60e9-49cf-9045-fba380cf7b9f" class="bulleted-list"><li style="list-style-type:disc"><strong><code>ptr</code></strong><strong> </strong>must point to the <strong>beginning of an allocated block</strong> that was obtained from <code>malloc</code>, <code>calloc</code>, or <code>realloc</code>.</li></ul><ul id="6c7c9752-6c49-4f5c-aca7-06f33a9643cb" class="bulleted-list"><li style="list-style-type:disc">Allocating and freeing blocks with <code>malloc</code> &amp; <code>free</code><figure id="970784b7-e1d3-402a-a3b7-456ae451b5ae" class="image"><a href="/assets/images/CSAPP-9/Untitled%2031.png"><img style="width:288px" src="/assets/images/CSAPP-9/Untitled%2031.png"/></a></figure><ul id="359800e5-62e1-4736-bc44-9bb37819cba0" class="bulleted-list"><li style="list-style-type:circle">(b) : <code>malloc</code> pads the block with an <strong>extra word</strong> to <strong>keep the free block aligned</strong> on a double-word boundary. (b)</li></ul><ul id="b01b6a92-da73-4634-b94b-a91e3c4827cd" class="bulleted-list"><li style="list-style-type:circle">(d) : After the <code>free</code> returns, the pointer <strong><code>p2</code></strong><strong> still points to the freed block</strong>. Application should not use <code>p2</code> again until it is reinitialized by a new call to <code>malloc</code>.</li></ul></li></ul></details></li></ul><ul id="ffda9ff0-a00c-4242-a053-06554896d9b2" class="toggle"><li><details open=""><summary><strong>Why Dynamic Memory Allocation?</strong></summary><p id="4f26da8e-4cbb-457e-a519-445776e25f91" class="">Programs donâ€™t know the sizes of certain data structures until the program actually runs. â†’ Use dynamic memory allocation.</p></details></li></ul><ul id="a45bea65-428d-4e2a-8fc8-f9c463c3ce0e" class="toggle"><li><details open=""><summary><strong>Allocator Requirements and Goals</strong></summary><ul id="de096a55-f8bc-4e38-a8da-f5bd689b2cf7" class="bulleted-list"><li style="list-style-type:disc"><strong>Allocator Requirements</strong><ul id="7778624d-62f2-4bdc-8f92-19c694857275" class="bulleted-list"><li style="list-style-type:circle">Handling <strong>arbitrary request sequences</strong> : Each <strong>free request</strong> must <strong>correspond to </strong>a <strong>currently allocated block</strong> obtained from a previous allocate request.</li></ul><ul id="7ddc3d7b-5289-4b70-8f12-a230df2357db" class="bulleted-list"><li style="list-style-type:circle">Making <strong>immediate responses</strong> to requests : The allocator is <strong>not </strong>allowed to <strong>reorder </strong>or <strong>buffer requests</strong> in order to improve performance.</li></ul><ul id="bee31cd5-d52c-4dea-8b40-ad71d89b855a" class="bulleted-list"><li style="list-style-type:circle">Using only the <strong>heap </strong>: Any nonscalar data structures used by the allocator must be stored in the heap itself.</li></ul><ul id="c36ee6c1-0782-4dac-92d1-136be464038a" class="bulleted-list"><li style="list-style-type:circle"><strong>Aligning blocks (alignment requirement)</strong></li></ul><ul id="ae3986e0-7364-436d-a17e-2adc1fc291d3" class="bulleted-list"><li style="list-style-type:circle"><strong>Not modifying allocated blocks</strong> : Allocators are not allowed to modify or move blocks once they are allocated.</li></ul></li></ul><ul id="b239b822-bad2-4a5e-b33c-5022a240d8f4" class="bulleted-list"><li style="list-style-type:disc"><strong>Allocator Goals</strong><ul id="491a9bd6-b62e-4ee1-9cc1-1ad7a883717c" class="bulleted-list"><li style="list-style-type:circle">Maximizing <strong>Throughput</strong></li></ul><ul id="968db9b8-7977-4809-a3c9-d7517cb2df2e" class="bulleted-list"><li style="list-style-type:circle">Maximizing <strong>Memory Utilization</strong><ul id="9fb63fa9-e2ed-42ae-8ea5-a1c94de682c0" class="bulleted-list"><li style="list-style-type:square">We use a <strong>peak utilization</strong> to characterize how efficiently an allocator uses the heap.</li></ul><ul id="ed0ccbca-c3f2-48f1-b822-2fd252e23287" class="bulleted-list"><li style="list-style-type:square">The <strong>peak utilization</strong> over the first <em>k</em> + 1 requests, <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>U</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">U_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span><span>ï»¿</span></span>, is given by <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>U</mi><mi>k</mi></msub><mo>=</mo><mfrac><mrow><mi>m</mi><mi>a</mi><msub><mi>x</mi><mrow><mi>i</mi><mo lspace="0em" rspace="0em">â‰¤</mo><mi>k</mi></mrow></msub><msub><mi>P</mi><mi>i</mi></msub></mrow><msub><mi>H</mi><mi>k</mi></msub></mfrac></mrow><annotation encoding="application/x-tex">U_k=\frac{max_{i{\le}k}P_i}{H_k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.413036em;vertical-align:-0.4508599999999999em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9621759999999999em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:-0.08125em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.483845em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">ma</span><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mord mtight"><span class="mrel mtight">â‰¤</span></span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.24834999999999996em;"><span></span></span></span></span></span></span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:-0.13889em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.4508599999999999em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span><span>ï»¿</span></span>. (<style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>H</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">H_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.08125em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span><span>ï»¿</span></span> = the current size of the heap, <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span><span>ï»¿</span></span> = the sum of the payloads of the currently allocated blocks)</li></ul></li></ul><ul id="ad687bd7-a7ad-4489-97be-99e55e384f79" class="bulleted-list"><li style="list-style-type:circle">There is a tension between maximizing throughput and utilization.</li></ul></li></ul></details></li></ul><ul id="23e8f97f-b8bd-4192-bc2a-96e408d8c1a5" class="toggle"><li><details open=""><summary><strong>Fragmentation</strong></summary><p id="2b48e5de-aca8-44e2-8c87-8205de3405bc" class=""><strong>Fragmentation </strong>is the primary cause of poor heap utilization, which occurs when otherwise unused memory is not available to satisfy allocate requests.</p><ul id="47116dac-0f2d-4693-8f02-58c7b72e5e8f" class="bulleted-list"><li style="list-style-type:disc"><strong>Internal Fragmentation</strong><ul id="4f629642-3ee1-4f31-b9aa-eeb5ab311d17" class="bulleted-list"><li style="list-style-type:circle"><strong>Internal fragmentation</strong> occurs when an <strong>allocated block is larger than the payload</strong>.</li></ul><ul id="cb4e4bc8-a530-4f2b-aa85-a706a3a245aa" class="bulleted-list"><li style="list-style-type:circle">This happen for a number of reasons:<ul id="f3ef50a3-eb74-4bb0-80a6-f67d4cbf2e22" class="bulleted-list"><li style="list-style-type:square">The <strong>implementation of an allocator</strong> impose a minimum size on allocated blocks.</li></ul><ul id="c3f2d7f2-1ea7-4bc2-83a0-1d10e2705c52" class="bulleted-list"><li style="list-style-type:square">The allocator increase the block size to satisfy <strong>alignment constraints</strong>.</li></ul></li></ul><ul id="578f3e33-b05d-4222-b69b-76c443720384" class="bulleted-list"><li style="list-style-type:circle">Internal fragmentation is quantified as the <strong>sum of the differences between the sizes of the allocated blocks and their payloads</strong>.</li></ul></li></ul><ul id="150f8e43-e85b-4478-87d3-5fdb7ad6a4c1" class="bulleted-list"><li style="list-style-type:disc"><strong>External Fragmentation</strong><ul id="876558a6-13d6-4dd1-8432-1a0982057c28" class="bulleted-list"><li style="list-style-type:circle"><strong>External fragmentation</strong> occurs when there is <strong>enough aggregate free memory</strong> to satisfy an allocate request, but no<strong> single free block is large enough</strong> to handle the request.</li></ul><ul id="e956c9b9-44ad-4222-834b-a2c724798715" class="bulleted-list"><li style="list-style-type:circle">External fragmentation is much more <strong>difficult to quantify</strong> - it also depends on the pattern of <strong>future requests</strong>.</li></ul><ul id="8dc83a27-eb5f-4640-9f77-a0e388370be1" class="bulleted-list"><li style="list-style-type:circle">Allocators typically employ <strong>heuristics </strong>that attempt to maintain <strong>small numbers of larger free blocks</strong> rather than large numbers of smaller free blocks.</li></ul></li></ul></details></li></ul><ul id="a0483d92-5d7e-4718-a89b-95417830d984" class="toggle"><li><details open=""><summary><strong>Implementation Issues</strong></summary><p id="4ae9b623-afa6-4364-b570-ab8a3d3f77cc" class="">A practical allocator with a better balance between throughput and utilization must consider the following issues:</p><ul id="9bd76fe4-c09f-4971-9460-43eaace85442" class="bulleted-list"><li style="list-style-type:disc"><strong>Free block organization</strong> : How do we <strong>keep track of free blocks</strong>?</li></ul><ul id="14a98ce0-e5d5-432c-9808-d5eeaf09857c" class="bulleted-list"><li style="list-style-type:disc"><strong>Placement </strong>: How do we<strong> choose an appropriate free block</strong> to place a newly allocated block?</li></ul><ul id="e81ee4c7-3317-4612-827b-d37d4fefa5ad" class="bulleted-list"><li style="list-style-type:disc"><strong>Splitting </strong>: What do we do with the <strong>remainder of the free block</strong> after placing a newly allocated block?</li></ul><ul id="4eacab06-634a-41ee-be3e-9e7e602182c4" class="bulleted-list"><li style="list-style-type:disc"><strong>Coalescing </strong>: What do we do with a <strong>block that has just been freed</strong>?</li></ul></details></li></ul><ul id="979a2dac-0471-4973-afde-0b50992b9002" class="toggle"><li><details open=""><summary><strong>Implicit Free Lists</strong></summary><p id="c4393f9f-c87a-40ea-9122-c7f20e3021c6" class="">An <strong>implicit free lists</strong> is a simple free block organization.</p><figure id="c42eaceb-7e05-4d37-a9e0-4cbbf243fdfb" class="image"><a href="/assets/images/CSAPP-9/Untitled%2032.png"><img style="width:576px" src="/assets/images/CSAPP-9/Untitled%2032.png"/></a></figure><ul id="475aab23-cb1f-47a2-aade-970137c18146" class="bulleted-list"><li style="list-style-type:disc">A block consists of a<strong> one-word header</strong>, the <strong>payload</strong>, and possibly some <strong>additional padding</strong>.</li></ul><ul id="7c8fc9d5-66d3-4379-8058-9927805c9786" class="bulleted-list"><li style="list-style-type:disc">The <strong>header </strong>encodes the <strong>block size</strong>, and whether the block is <strong>allocated or free</strong>.<ul id="8e0e6b4a-5d45-48a8-afb9-79920e00296e" class="bulleted-list"><li style="list-style-type:circle">If we impose a <strong>double-word alignment constraint</strong>, the block size is always a <strong>multiple of 8</strong> and the <strong>3 low-order bits of the size are always zero</strong>. â†’ <strong>Store only the 29 high-order bits</strong> of the size, and <strong>use remaining 3 bits</strong> to encode other information.</li></ul><ul id="4b2fd53c-d7ec-466d-98da-a431800cc32e" class="bulleted-list"><li style="list-style-type:circle">In this case, use the <strong>leas significant of these bits</strong> to indicate whether the block is <strong>allocated or free.</strong></li></ul></li></ul><ul id="4bf32382-26ab-4a75-944c-4712ab585107" class="bulleted-list"><li style="list-style-type:disc">The free blocks are <strong>linked implicitly</strong> by the size fields in the headers â†’ This organization is called an <strong>implicit free list</strong>.<figure id="bd69532c-4e7b-40a7-9895-f08a3a6bcf3c" class="image"><a href="/assets/images/CSAPP-9/Untitled%2033.png"><img style="width:720px" src="/assets/images/CSAPP-9/Untitled%2033.png"/></a></figure></li></ul><ul id="edb64880-544a-4332-9bff-595218271987" class="bulleted-list"><li style="list-style-type:disc">The allocator can traverse the entire set of free blocks by <strong>traversing all of the blocks in the heap</strong>.</li></ul><ul id="762adeb8-ecfd-4e9e-8175-5d6c85c4d994" class="bulleted-list"><li style="list-style-type:disc">There is a <strong>specially marked end block</strong> - in this example, a terminating header with the <strong>allocated bit set and a size of zero</strong>.</li></ul><ul id="6b98c00e-47fa-406c-bd72-dd3023a63359" class="bulleted-list"><li style="list-style-type:disc">Advantage â†’ <strong>Simplicity</strong>.</li></ul><ul id="3d6a4a5b-56bd-4d05-b822-7fdea2693fd9" class="bulleted-list"><li style="list-style-type:disc">Disadvantage â†’ The cost of any operation that requires a search of the free list will be <strong>linear </strong>in the total number of allocated and free blocks in the heap.</li></ul><ul id="ed43d0dc-bc85-4f9f-96b4-8099c9ce5320" class="bulleted-list"><li style="list-style-type:disc"><strong>Minimum Block Size</strong><ul id="23015392-0afa-4503-a4fe-5090bcbf68dc" class="bulleted-list"><li style="list-style-type:circle">The systemâ€™s <strong>alignment requirement</strong> &amp; the allocatorâ€™s choice of <strong>block format</strong> impose a <strong>minimum block size</strong>.</li></ul><ul id="25aa530e-355b-4a65-90a4-1300fef1bd0c" class="bulleted-list"><li style="list-style-type:circle">IF we assume a <strong>double-word alignment requirement</strong>, the size of each block must be a <strong>multiple of two words (8 bytes)</strong>. â†’ The <strong>implicit free listâ€™s block format</strong> induces a <strong>minimum block size of two words</strong> : one word for the <strong>header</strong>, and another to maintain the <strong>alignment requirement</strong>. â†’ Even if the application were to request a <strong>single byte</strong>, the allocator would still <strong>create a two-word block</strong>.</li></ul></li></ul></details></li></ul><ul id="61f87d5b-eb09-453c-be6f-c592db724c8d" class="toggle"><li><details open=""><summary><strong>Placing Allocated Blocks</strong></summary><p id="197cf359-d1cd-4085-8003-08344f0592e0" class="">When requested a block of <em>k </em>bytes, the allocator <strong>searches the free list for a free block</strong> that is <strong>large enough</strong> to hold the requested block according to the <strong>placement policy</strong>.</p><ul id="fac79e99-5f45-447c-aadb-43e681055728" class="bulleted-list"><li style="list-style-type:disc"><strong>First fit</strong><ul id="62a5626e-95fb-4e2e-b16b-37097b992d92" class="bulleted-list"><li style="list-style-type:circle">searches the free list <strong>from the beginning</strong> and <strong>chooses the first free block</strong> that fits.</li></ul><ul id="89b78d13-219a-4029-9384-25f08262eec1" class="bulleted-list"><li style="list-style-type:circle">tends to retain <strong>large free blocks at the end </strong>of the list.</li></ul><ul id="3e1101b0-c9d4-43b1-8dc3-94ad2b6c2376" class="bulleted-list"><li style="list-style-type:circle">tends to leave <strong>splinters </strong>of small free blocks toward the <strong>beginning </strong>of the list, which will increase the search time for larger blocks.</li></ul></li></ul><ul id="0d015b58-d839-45fa-ad3d-6d902d2869ad" class="bulleted-list"><li style="list-style-type:disc"><strong>Next fit</strong><ul id="b182fc1b-fd9e-4c0a-a6e9-569cab153861" class="bulleted-list"><li style="list-style-type:circle">starts each search <strong>where the previous search left off</strong>.</li></ul><ul id="8b45d57e-8b23-4175-aada-324d41eb82e2" class="bulleted-list"><li style="list-style-type:circle">can run significantly <strong>faster </strong>than first fit, especially if the front of the list becomes littered with many splinters.</li></ul><ul id="90bdd313-0b7b-411e-9f9f-73638ad0220d" class="bulleted-list"><li style="list-style-type:circle">suffers from <strong>worse memory utilization</strong> than first fit.</li></ul></li></ul><ul id="16e126bf-a5ba-46ff-922e-3b421b3efc84" class="bulleted-list"><li style="list-style-type:disc"><strong>Best fit</strong><ul id="9d476713-df1c-4b88-b1f0-97a5c6ece87f" class="bulleted-list"><li style="list-style-type:circle"><strong>examines every free block</strong> and chooses the free block <strong>with the smallest size</strong> that fits.</li></ul><ul id="4f572338-8f3d-48a7-9ec8-b9eee28c6824" class="bulleted-list"><li style="list-style-type:circle">enjoys <strong>better memory utilization</strong> than either first fit or next fit.</li></ul><ul id="66db7598-0ce4-4399-ba40-1d1df270a190" class="bulleted-list"><li style="list-style-type:circle">with simple free list organizations such as the implicit free list, requires an <strong>exhaustive search of the heap</strong>. â†’ use <strong>more sophisticated organization</strong></li></ul></li></ul></details></li></ul><ul id="d0dcb835-202f-4b68-8851-efdd57b6cfe4" class="toggle"><li><details open=""><summary><strong>Splitting Free Blocks</strong></summary><p id="63d514ee-92d3-46c1-8975-13a46bc44028" class="">The allocator also has to make policy decision about <strong>how much of the free block to allocate</strong>.</p><p id="0647af08-c86e-42e6-ac88-2424bab5fd36" class=""><strong>Using the entire free block</strong> is <strong>simple and fast, </strong>but can introduce <strong>internal fragmentation</strong>.</p><p id="a1a703ef-b81b-4124-80d9-5caab6afcb72" class="">If the placement policy tends to produce good fits, then some additional internal fragmentation might be acceptable.</p><p id="db575df2-d87b-4cf9-9190-3d17dd3923fd" class="">If the fit is not good, the allocator usually opt to <strong>split the free block</strong> into two parts. (<strong>allocated block &amp; new free block</strong>)</p></details></li></ul><ul id="501368a3-91b1-4127-a50c-cc0dfdff7826" class="toggle"><li><details open=""><summary><strong>Getting Additional Heap Memory</strong></summary><p id="f1a76968-28ef-4d4b-98e9-5fce2cff44c1" class="">If the allocator is <strong>unable to find a fit</strong> for the requested block:</p><ol type="1" id="42db5990-469b-4bfd-b6de-c86df8cd5324" class="numbered-list" start="1"><li>The allocator try to create some larger free blocks by <strong>merging (coalescing) free blocks</strong> that are physically adjacent in memory.</li></ol><ol type="1" id="39382702-7a70-439d-b2ab-40606cdeb26e" class="numbered-list" start="2"><li>If this doesnâ€™t yield a sufficiently large block, or if the free blocks are already maximally coalesced, the allocator asks the <strong>kernel </strong>for<strong> additional heap memory</strong> by <strong>calling the </strong><strong><code>sbrk</code></strong>.</li></ol><ol type="1" id="1d5315cf-0a50-462d-bf45-5fa11b1caa03" class="numbered-list" start="3"><li>The allocator transforms the additional memory into <strong>one large free block</strong>, <strong>inserts the block into the free list</strong>, and then <strong>places the requested block</strong> in this new block.</li></ol></details></li></ul><ul id="863d7d40-e65a-4f0e-a595-f171d5810ab5" class="toggle"><li><details open=""><summary><strong>Coalescing Free Blocks</strong></summary><p id="1d1b4a69-7ef2-47ea-8b23-5b72af0c0bad" class="">After freeing an allocated block, there can be a <strong>false fragmentation</strong>, where there is a lot of <strong>available free memory chopped up into small, unusable free blocks</strong>.</p><p id="cbd58844-fc88-4c93-9402-12387da7e8e1" class="">â†’ Need to <strong>merge adjacent free blocks</strong>. (<strong>coalescing</strong>)</p><ul id="f88adba8-ce84-483a-9ed7-3acec8ea2c52" class="bulleted-list"><li style="list-style-type:disc"><strong>Immediate coalescing </strong><ul id="ed80d34e-9cd5-4ff6-af5e-3c9e4b5f7671" class="bulleted-list"><li style="list-style-type:circle">merging any adjacent blocks <strong>each time a block is freed</strong>.</li></ul><ul id="03556289-cb51-4b58-8f23-3feaef86b945" class="bulleted-list"><li style="list-style-type:circle">can be performed <strong>in constant time</strong></li></ul><ul id="e9412a0b-1dc3-4ab3-9537-be51816734c3" class="bulleted-list"><li style="list-style-type:circle">can introduce a form of <strong>thrashing </strong>where a block is <strong>repeatedly coalesced and then split</strong> soon thereafter, with some request patterns.</li></ul></li></ul><ul id="72d9f343-8eb9-464e-8302-0479598bd94f" class="bulleted-list"><li style="list-style-type:disc"><strong>Deferred coalescing</strong><ul id="287a8e7e-bfa7-4cf1-9a28-1e6a9be68b75" class="bulleted-list"><li style="list-style-type:circle"><strong>waiting </strong>to coalesce free blocks at some later time. (<em>example : until some allocation request fails</em>)</li></ul><ul id="1b1fcca4-a389-41f0-abcc-a03b2c022657" class="bulleted-list"><li style="list-style-type:circle">fast allocators often opt for some form of deferred coalescing.</li></ul></li></ul></details></li></ul><ul id="5f930207-34bf-4c4a-ba72-3bdeac7bf700" class="toggle"><li><details open=""><summary><strong>Coalescing with Boundary Tags</strong></summary><p id="7782b448-dd57-45bf-86e5-099457737c9c" class="">To <strong>coalesce the previous block</strong> efficiently, use a technique known as <strong>boundary tags</strong> : add a <strong>footer (the boundary tag)</strong> at the end of each block, where the footer is a re<strong>plica of the header</strong>.</p><p id="6b468b2c-5a20-4173-9b1e-92a0e1ff8595" class="">â†’ The allocator can <strong>determine the starting location and status of the previous block</strong> by <strong>inspecting its footer</strong>, which is always <strong>one word away from the start of the current block</strong>.</p><ul id="ae70fe2e-dbae-40dc-b5ec-2f1d9fb36faa" class="bulleted-list"><li style="list-style-type:disc"><strong>Case 1 : prev and next allocated</strong><figure id="b1ddd62e-156d-4594-ae81-fceffdf1fb39" class="image"><a href="/assets/images/CSAPP-9/Untitled%2034.png"><img style="width:240px" src="/assets/images/CSAPP-9/Untitled%2034.png"/></a></figure><ul id="7d04fe7a-7dcc-4674-89ff-1ce692a17a9a" class="bulleted-list"><li style="list-style-type:circle">The status of the <strong>current </strong>block is changed <strong>from allocated to free</strong>.</li></ul></li></ul><ul id="eff83370-4761-420d-aaee-4a8b230995ab" class="bulleted-list"><li style="list-style-type:disc"><strong>Case 2: prev allocated, next free</strong><figure id="f10fd92e-fb5d-4dbc-b523-2cdb8afddc9d" class="image"><a href="/assets/images/CSAPP-9/Untitled%2035.png"><img style="width:240px" src="/assets/images/CSAPP-9/Untitled%2035.png"/></a></figure><ul id="b4933473-8918-4fc6-a758-18f37cefff14" class="bulleted-list"><li style="list-style-type:circle">The <strong>header of current block</strong> and the <strong>footer of the next block</strong> are updated with the combined sizes of the two blocks.</li></ul></li></ul><ul id="68577ceb-958b-4448-ad17-2f75ecee317b" class="bulleted-list"><li style="list-style-type:disc"><strong>Case 3: prev free, next allocated</strong><figure id="e3e205ae-ab6d-444c-9fdf-f0c535aab5c2" class="image"><a href="/assets/images/CSAPP-9/Untitled%2036.png"><img style="width:240px" src="/assets/images/CSAPP-9/Untitled%2036.png"/></a></figure><ul id="026415eb-a4d5-4c42-b164-c6e5c527f485" class="bulleted-list"><li style="list-style-type:circle">The <strong>header of the previous block</strong> and the <strong>footer of the current block</strong> are updated with the combined sizes of the two blocks.</li></ul></li></ul><ul id="9d992d50-3eef-4322-89b4-97ca7dc5ec50" class="bulleted-list"><li style="list-style-type:disc"><strong>Case 4: next and prev free</strong><figure id="fc02a099-90e1-49ad-947f-c505ca674a4f" class="image"><a href="/assets/images/CSAPP-9/Untitled%2037.png"><img style="width:240px" src="/assets/images/CSAPP-9/Untitled%2037.png"/></a></figure><ul id="4120fed4-d8db-41b6-822f-c629ea33f1aa" class="bulleted-list"><li style="list-style-type:circle">The <strong>header of the previous block</strong> and the <strong>footer of the next block</strong> are updated with the combined sizes of the <strong>three</strong> blocks.</li></ul></li></ul><p id="2ed8066c-76cb-4719-92c7-ee066914b081" class="">We can <strong>eliminate the footer in allocated blocks</strong> for optimization - Instead, we can store the <strong>allocated/free bit of the previous block</strong> in one of the excess <strong>low-order bits of the current block</strong>. However, the <strong>free blocks would still need footers</strong>.</p></details></li></ul><ul id="a05592f8-1e4f-4c49-805c-d34f37c11165" class="toggle"><li><details open=""><summary><strong>Putting It Together: Implementing a Simple Allocator</strong></summary><p id="c2e24fcd-bd72-4648-89e7-861de466a0b7" class="">Implement a simple allocator based on an <strong>implicit free list</strong> with <strong>immediate boundary-tag coalescing</strong>.</p><p id="73d9264e-1fda-4726-820b-70fa41a270b3" class="">The maximum block size is <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup><mo>=</mo><mn>4</mn><mi>G</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">2^{32}=4GB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord mathnormal" style="margin-right:0.05017em;">GB</span></span></span></span></span><span>ï»¿</span></span>. The code is 64-bit clean, running without modification in 32-bit or 64-bit processes.</p><ul id="fbade4f0-5117-4896-a2c6-4453836c8d7a" class="toggle"><li><details open=""><summary><strong>General Allocator Design</strong></summary><p id="6018745c-5862-445f-9bf9-b4fe5821ae60" class="">Our allocator uses a model of the memory system provided by the <strong><code>memlib.c</code></strong><strong> package</strong>.</p><pre id="8d63d938-5146-45db-8fe7-0ab1dd424d32" class="code"><code>/* Private global variables */
static char *mem_heap; /* Points to first byte of heap */
static char *mem_brk; /* Points to last byte of heap plus 1 */
static char *mem_max_addr; /* Max legal heap addr plus 1 */

/*
 * mem_init - INitialize the memory system model
 */
void mem_init(void){
	mem_heap = (char *)Malloc(MAX_HEAP);
	mem_brk = (char *)mem_heap;
	mem_max_addr = (char *)(mem_heap + MAX_HEAP);
}

/*
 * mem_sbrk - Simple model of the sbrk function. Extends the heap
 * by incr bytes and returns the start address of the new area. In
 * this model, the heap cannot be shrunk.
 */
void *mem_sbrk(int incr){
	char *old_brk = mem_brk;
	
	if( (incr &lt; 0) || ((mem_brk + incr) &gt; mem_max_addr) ){
		errno = ENOMEM;
		fprintf(stderr, &quot;ERROR: mem_sbrk failed. Ran out of memory...\n&quot;);
		return (void *)-1;
	}
	mem_brk += incr;
	return (void *)old_brk;
}</code></pre><ul id="e0fea779-b07b-40bf-a0dc-f1c5dfc9fc78" class="bulleted-list"><li style="list-style-type:disc"><code>mem_init</code> models the <strong>VM available to the heap </strong>as a <strong>large double-word aligned array of bytes</strong>.</li></ul><ul id="383d8249-96d0-4554-91df-32d4c96e1115" class="bulleted-list"><li style="list-style-type:disc">The bytes <strong>between </strong><strong><code>mem_heap</code></strong><strong> and </strong><strong><code>mem_brk</code></strong><strong> </strong>represent <strong>allocated VM</strong>.</li></ul><ul id="3e5f04a9-23fb-4a66-bb80-8c4be771f992" class="bulleted-list"><li style="list-style-type:disc">The bytes <strong>following </strong><strong><code>mem_brk</code></strong> represent <strong>unallocated VM</strong>.</li></ul><ul id="fcfd372a-1f04-4e03-844e-ecbce4a20c6b" class="bulleted-list"><li style="list-style-type:disc">The allocator requests <strong>additional heap memory</strong> by calling the <strong><code>mem_sbrk</code></strong>.</li></ul><ul id="6835d346-f816-4729-8905-c0bcf7aa196b" class="bulleted-list"><li style="list-style-type:disc">The allocator exports three functions to application programs:<pre id="51e1bcfc-180e-4537-bff2-5edae9db1ecf" class="code"><code>extern int mm_init(void);
extern void *mm_malloc(size_t size);
extern void mm_free(void *ptr);</code></pre><ul id="18ea7630-28d7-47b1-985b-c0eacfad9e13" class="bulleted-list"><li style="list-style-type:circle"><code>mm_malloc</code> and <code>mm_free</code> have the same interfaces and semantics as their system counterparts.</li></ul></li></ul><ul id="60e1046f-d08e-4f7e-95dc-370c4542a716" class="bulleted-list"><li style="list-style-type:disc">The allocator uses the invariant form of the <strong>implicit free list</strong>.<figure id="e5b1bc0d-08d1-4265-9cb8-29a4f170d2a1" class="image"><a href="/assets/images/CSAPP-9/Untitled%2038.png"><img style="width:624px" src="/assets/images/CSAPP-9/Untitled%2038.png"/></a></figure><ul id="5e191844-7ecc-434d-8ff9-fadac0bd8819" class="bulleted-list"><li style="list-style-type:circle">The first word is an unused <strong>padding word</strong> aligned to a double-word boundary.</li></ul><ul id="99517afd-8917-401d-8048-d1447e8cc242" class="bulleted-list"><li style="list-style-type:circle">The padding is followed by a special <strong>prologue block</strong>, which is an<strong> 8-byte allocated block </strong>consisting of<strong> only a header and a footer</strong>.</li></ul><ul id="8a605499-eae5-4657-996b-aa1a946aeb0c" class="bulleted-list"><li style="list-style-type:circle">The heap always ends with a special <strong>epilogue block</strong>, which is a <strong>zero-size allocated block</strong> that consists of <strong>only a header</strong>.</li></ul><ul id="3841ac64-056a-40d6-bda5-633a5f35c2c9" class="bulleted-list"><li style="list-style-type:circle">The allocator uses a single private (<code>static</code>) global variable, <strong><code>heap_listp</code></strong>, that always <strong>points to the prologue block</strong>.</li></ul></li></ul></details></li></ul><ul id="ea1a580f-706c-4834-9a9e-d99174dd1eae" class="toggle"><li><details open=""><summary><strong>Basic Constants and Macros for Manipulating the Free List</strong></summary><pre id="e706a353-72b4-43d4-bac2-271d49b330cf" class="code"><code>/* Basic constants and macros */
#define WSIZE 4 /* Word and header/footer size (bytes) */
#define DSIZE 8 /* Double word size (bytes) */
#define CHUNKSIZE (1&lt;&lt;12) /* Extend heap by this amount (bytes) */

#define MAX(x, y) ((x) &gt; (y)? (x) : (y))

/* Pack a size and allocated bit into a word */
#define PACK(size, alloc) ((size) | (alloc))

/* Read and write a word at address p */
#define GET(p) (*(unsigned int *)(p))
#define PUT(p) (*(unsigned int *)(p) = (val))

/* Read the size and allocated fields from address p */
#define GET_SIZE(p) (GET(p) &amp; ~0x7)
#define GET_ALLOC(p) (GET(p) &amp; 0x1)

/* Given block ptr bp, compute address of its header and footer */
#define HDRP(bp) ((char *)(bp) - WSIZE)
#define FTRP(bp) ((char *)(bp) + GET_SIZE(HDRP(bp)) - DSIZE)

/* Given block ptr bp, compute address of next and previous blocks */
#define NEXT_BLKP(bp) ((char *)(bp) + GET_SIZE(((char *)(bp) - WSIZE)))
#define PREV_BLKP(bp) ((char *)(bp) - GET_SIZE(((char *)(bp) - DSIZE)))</code></pre><ul id="b38b94b4-17b4-4f33-ad2c-3fb17903f71d" class="bulleted-list"><li style="list-style-type:disc"><code>HDRP</code> and <code>FTRP</code> operate on block pointers (<code>bp</code>) that point to the first payload byte.</li></ul><ul id="13dbe95e-e169-4963-8271-98fd2a786c52" class="bulleted-list"><li style="list-style-type:disc">We can use the macro in various ways to manipulate the free list (<em>example : determining the size of the next block - </em><em><code>GET_SIZE(HDRP(NEXT_BLKP(bp)));</code></em>)</li></ul></details></li></ul><ul id="9abf78d7-dc5a-4731-bec2-f03e05355fa9" class="toggle"><li><details open=""><summary><strong>Creating the Initial Free List</strong></summary><pre id="6eff775d-86ca-40f5-8ec4-a6454854d4d5" class="code"><code>int mm_init(void){
	/* Create the initial empty heap */
	if ((heap_listp = mem_sbrk(4*WSIZE)) == (void *)-1) return -1;
	PUT(heap_listp, 0); /* Alignment padding */
	PUT(heap_listp + (1*WSIZE), PACK(DSIZE, 1)); /* Prologue header */
	PUT(heap_listp + (2*WSIZE), PACK(DSIZE, 1)); /* Prologue footer */
	PUT(heap_listp + (3*WSIZE), PACK(0, 1)); /* Epilogue header */
	heap_listp += (2*WSIZE);
	
	/* Extend the empty heap with a free block of CHUNKSIZE bytes */
	if (extend_heap(CHUNKSIZE/WSIZE) == NULL) return -1;
	return 0;
}

static void *extend_heap(size_t words){
	char *bp;
	size_t size;
	
	/* Allocate an even number of words to maintain alignment */
	size = (words % 2) ? (words+1) * WSIZE : words * WSIZE;
	if ((long)(bp = mem_sbrk(size)) == -1) return NULL;

	/* Initialize free block header/footer and the epilogue header */
	PUT(HDRP(bp), PACK(size, 0)); /* Free block header */
	PUT(FTRP(bp), PACK(size, 0)); /* Free block footer */
	PUT(HDRP(NEXT_BLKP(bp)), PACK(0, 1)); /* New epilogue header */

	/* Coalesce if the previous block was free */
	return coalesce(bp);
}</code></pre><ul id="cca13713-ecb2-4b0b-bc2e-aa2bf6a1bdab" class="bulleted-list"><li style="list-style-type:disc"><strong><code>mm_init</code></strong><strong> </strong>gets <strong>4 words</strong> from the memory system and initializes them to create the <strong>empty free list</strong>. It then calls <code>extend_heap</code>.</li></ul><ul id="c935095f-351f-4193-92b9-2ac6eb12e4a0" class="bulleted-list"><li style="list-style-type:disc"><code>extend_heap</code> <strong>extends the heap</strong> by <code>words</code> bytes and creates the initial free block.<ul id="f63987cb-35d2-4868-be6f-6b21df72d175" class="bulleted-list"><li style="list-style-type:circle"><code>extend_heap</code> is invoked when the <strong>heap is initialized</strong>, and when <code>mm_malloc</code> is <strong>unable to find a suitable fit</strong>. </li></ul><ul id="89d6b1be-8ede-4d82-b0c1-a4548195c3e7" class="bulleted-list"><li style="list-style-type:circle"><code>extend_heap</code> <strong>rounds up</strong> the requested size to the <strong>nearest multiple of 2 words (8 bytes),</strong> and requests the <strong>additional heap space</strong> from the memory system.</li></ul><ul id="f99646f6-4a71-4080-b051-939d3d58da60" class="bulleted-list"><li style="list-style-type:circle">The remainder of the <code>extend_heap</code> initializes <strong>free block header, footer, and the epilogue header</strong>.</li></ul><ul id="44f6c9c6-eb72-4b45-a7b9-12e05ebeb2b0" class="bulleted-list"><li style="list-style-type:circle">Finally, <code>extend_heap</code> call the <strong><code>coalesce</code></strong><strong> </strong>to <strong>merge the possible two free blocks</strong>, and return the block pointer of the merged blocks.</li></ul></li></ul></details></li></ul><ul id="0c9ea572-64e1-4571-a13d-5f8ab4e10b47" class="toggle"><li><details open=""><summary><strong>Freeing and Coalescing Blocks</strong></summary><pre id="6cae9982-6d8e-406d-98c5-3b292f1c8795" class="code"><code>void mm_free(void *bp){
	size_t size = GET_SIZE(HDRP(bp));

	PUT(HDRP(bp), PACK(size, 0));
	PUT(FTRP(bp), PACK(size, 0));
	coalesce(bp);
}

static void *coalsece(void *bp){
	size_t prev_alloc = GET_ALLOC(FTRP(PREV_BLKP(bp)));
	size_t next_alloc = GET_ALLOC(HDRP(NEXT_BLKP(bp)));
	size_t size = GET_SIZE(HDRP(bp));

	if (prev_alloc &amp;&amp; next_alloc) { /* Case 1 */
		return bp;
	}

	else if (prev_alloc &amp;&amp; !next_alloc) { /* Case 2 */
		size += GET_SIZE(HDRP(NEXT_BLKP(bp)));
		PUT(HDRP(bp), PACK(size, 0));
		PUT(FTRP(bp), PACK(size, 0));
	}

	else if (!prev_alloc &amp;&amp; next_alloc) { /* Case 3 */
		size += GET_SIZE(HDRP(PREV_BLKP(bp)));
		PUT(FTRP(bp), PACK(size, 0));
		PUT(HDRP(PREV_BLKP(bp)), PACK(size, 0));
		bp = PREV_BLKP(bp);
	}
	
	else { /* Case 4 */
		size += GET_SIZE(HDRP(PREV_BLKP(bp))) + GET_SIZE(FTRP(NEXT_BLKP(bp)));
		PUT(HDRP(PREV_BLKP(bp)), PACK(size, 0));
		PUT(FTRP(NEXT_BLKP(bp)), PACK(size, 0));
		bp = PREV_BLKP(bp);
	}
	return bp;
}</code></pre><ul id="e8baf5f5-9ee5-4c6c-a801-a2f304b4a350" class="bulleted-list"><li style="list-style-type:disc"><code>mm_free</code> <strong>frees the requested block</strong> (<code>bp</code>) and then <strong>merges adjacent free blocks</strong> using the <strong>boundary-tags coalescing technique</strong>.</li></ul><ul id="940c13e2-ea09-43ca-9d2f-b72581045698" class="bulleted-list"><li style="list-style-type:disc">In <strong><code>coalesce</code></strong>, the <strong>prologue and epilogue blocks</strong> allow us to ignore the potentially troublesome <strong>edge conditions</strong>.</li></ul></details></li></ul><ul id="734dc7ec-b916-4f3f-91e9-8748f2a9ebba" class="toggle"><li><details open=""><summary><strong>Allocating Blocks</strong></summary><pre id="a88c45fb-8f90-4bd2-9e0b-db47ed31dc7a" class="code"><code>void *mm_malloc(size_t size){
	size_t asize; /* Adjusted block size */
	size_t extendsize; /* Amount to extend heap if no fit */
	char *bp;

	/* Ignore spurious requests */
	if (size == 0) return NULL;
	
	/* Adjust block size to include overhead and alignment reqs. */
	if (size &lt;= DSIZE) asize = 2*DSIZE; /* 8 bytes for alginment requirement, and another 8 bytes for header and footer. */
	else asize = DSIZE * ((size + (DSIZE) + (DSIZE-1)) / DSIZE); /* Add 8 bytes for header and footer, then round up to the nearest multiple of 8. */

	/* Search the free list for a fit */
	if ((bp = find_fit(asize)) != NULL) {
		place(bp, asize);
		return bp;
	}

	/* No fit found. Get more memory and place the block */
	extendsize = MAX(asize, CHUNKSIZE);
	if ((bp = extend_heap(extendsize/WSIZE)) == NULL) return NULL;
	place(bp, asize);
	return bp;
}</code></pre><ul id="6e2a896c-69c2-4426-a689-4cbd82353745" class="bulleted-list"><li style="list-style-type:disc"><code>find_fit</code> perform a first-fit search of the implicit free list.</li></ul><pre id="b1dc86f5-2d23-4b94-a935-d43be1b24a0a" class="code"><code>static void *find_fit(size_t asize){
	char *bp = heap_listp;
	while(GET_SIZE(HDRP(bp))){
		if(!GET_ALLOC(HDRP(bp)) &amp;&amp; GET_SIZE(HDRP(bp)) &gt;= asize) return bp;
		bp = NEXT_BLKP(bp);
	}
	return NULL;
}	</code></pre><ul id="e5194bde-8341-4bfa-a166-df575bdc557b" class="bulleted-list"><li style="list-style-type:disc"><code>place</code> in place the requested block at the beginning of the free block, then splits only if the size of the remainder would equal or exceed the minimum block size (16 bytes).</li></ul><pre id="e089b235-ded2-4617-a046-9aef5369af5b" class="code"><code>static void place(void *bp, size_t asize){
	int csize = GET_SIZE(HDRP(bp));
	if (csize - asize &gt;= 2 * DSIZE) {
		PUT(HDRP(bp), PACK(asize, 1));
		PUT(FTRP(bp), PACK(asize, 1));
		bp = NEXT_BLKP(bp);
		PUT(HDRP(bp), PACK(csize-asize, 0));
		PUT(FTRP(bp), PACK(csize-asize, 0));
	}
	else {
		PUT(HDRP(bp), PACK(csize, 1));
		PUT(FTRP(bp), PACK(csize, 1));
	}
}</code></pre></details></li></ul></details></li></ul><ul id="d36c76b9-d95c-43b6-9a32-c59fe0536637" class="toggle"><li><details open=""><summary><strong>Explicit Free Lists</strong></summary><p id="8bc923fc-4ed4-472a-9e96-11434630b787" class="">For the implicit free list, <strong>block allocation time is linear</strong> in the total number of heap blocks. â†’ Organize the free blocks into some form of <strong>explicit </strong>data structure.</p><figure id="24d0b20b-28e7-443a-a5a4-2eb2dc201c12" class="image"><a href="/assets/images/CSAPP-9/Untitled%2039.png"><img style="width:480px" src="/assets/images/CSAPP-9/Untitled%2039.png"/></a></figure><ul id="f2f04026-c8ac-4788-a9cc-7006475deca9" class="bulleted-list"><li style="list-style-type:disc">The <strong>body of a free block</strong> is not needed â†’ the <strong>pointers </strong>that implement the data structure can be stored <strong>within the body of the free blocks</strong>.</li></ul><ul id="ac4b6b20-719c-4bfe-bae4-51fd4a9b1037" class="bulleted-list"><li style="list-style-type:disc">For example, the heap can be organized as a <strong>doubly linked free list</strong> by including a <strong><code>pred</code></strong><strong> and </strong><strong><code>succ</code></strong><strong> pointer</strong> in each free block.</li></ul><ul id="4c9a55ae-df47-4b3f-bd5f-cdf089bb681d" class="bulleted-list"><li style="list-style-type:disc">Using a doubly linked list reduces the <strong>first-fit allocation time</strong> from linear in the total number of blocks to <strong>linear in the number of free blocks</strong>.</li></ul><ul id="19ead156-7fa5-4dd1-ab8c-bf83b7c6461f" class="bulleted-list"><li style="list-style-type:disc">The time to <strong>free </strong>a block can be either linear or constant depending on how we order the blocks in the free list:<ul id="512b9748-7a7f-40e5-8b47-2ad5a464356b" class="bulleted-list"><li style="list-style-type:circle"><strong>LIFO ordered</strong> (inserting newly freed blocks at the beginning of the list)<ul id="17f11af7-d9a5-4c5c-9e5c-151bf4bcf561" class="bulleted-list"><li style="list-style-type:square">With a LIFO ordering and a first-fit placement policy, <strong>freeing a block</strong> can be performed<strong> in constant time</strong>.</li></ul><ul id="09fae1e0-a0f5-473f-a30c-81d98fec606a" class="bulleted-list"><li style="list-style-type:square">If boundary tags are used, <strong>coalescing </strong>can be performed <strong>in constant time</strong>.</li></ul></li></ul><ul id="b2889932-6f6d-4799-a4de-0e0ee107357a" class="bulleted-list"><li style="list-style-type:circle"><strong>Address ordered</strong> :<ul id="1e1f2dcd-e76e-4336-afac-83bc3067ac12" class="bulleted-list"><li style="list-style-type:square"><strong>Freeing a block</strong> requires a <strong>linear-time</strong> search.</li></ul><ul id="97df5924-1b50-4256-a7f1-8e70ab0d70d6" class="bulleted-list"><li style="list-style-type:square">Address-ordered first fit enjoys <strong>better memory utilization</strong> than LIFO-ordered first fit.</li></ul></li></ul></li></ul><ul id="9fb03652-581b-459a-ac19-44a25dc30365" class="bulleted-list"><li style="list-style-type:disc">Free blocks must be large enough to contain all of the <strong>necessary pointers</strong>, as well as the <strong>header and a footer</strong>. â†’ A <strong>larger minimum block size</strong> â†’ Increased potential for <strong>internal fragmentation</strong>.</li></ul></details></li></ul><ul id="af3f0fc9-f5a4-40a7-862e-ab7ab6b340e1" class="toggle"><li><details open=""><summary><strong>Segregated Free Lists</strong></summary><p id="5c53c025-13c0-42a6-bbc5-70d4ea455a01" class="">An allocator that uses a <strong>single free list</strong> requires time <strong>linear </strong>in the number of free blocks to allocate a block â†’ Use a <strong>segregated storage</strong>.</p><p id="9cdeb977-a8d7-41ad-a257-b13d2093ebcf" class="">The <strong>segregated storage</strong> maintain <strong>multiple free lists</strong>, where each list holds blocks that are roughly the same size. The storage <strong>partition the set of all possible block sizes</strong> into equivalence classes called <strong>size classes</strong>.</p><p id="0a02141d-9b80-4273-a92e-bbbe9acee08d" class="">The allocator maintains an <strong>array of free lists</strong>, with <strong>one free list per size class</strong>, <strong>ordered by increasing size</strong>.  When the allocator needs a block of size <em>n</em>, it searches the appropriate free list. If it canâ€™t find a block that fits, it searches the next list, and so on.</p><p id="82712c68-1d22-41da-82e8-d32ce00e7b17" class="">There are many <strong>variants </strong>of segregated storage:</p><ul id="4e057b8f-2029-4f02-b3c8-f655da7f76b6" class="bulleted-list"><li style="list-style-type:disc"><strong>Simple Segregated Storage</strong><ul id="e30da445-9b90-4ee9-8197-b9997b800b29" class="bulleted-list"><li style="list-style-type:circle">With <strong>simple segregated storage</strong>, the free list for each size class contains <strong>same-size blocks</strong>, each the size of the <strong>largest</strong> element of the size class. <p id="0059f974-0fd2-454a-ae1e-d4888f5ded52" class="">(<em>example : if some size class is defined as {17-32}, the free list for that class consists entirely of blocks of size 32.</em>)</p></li></ul><ul id="f8745b1c-c1db-4632-9804-00292aa3cfa6" class="bulleted-list"><li style="list-style-type:circle">To <strong>allocate</strong> a block of some given size:<ol type="1" id="c5871782-5b91-4cea-aeeb-6a9cb5c480aa" class="numbered-list" start="1"><li>Check the appropriate free list.</li></ol><ol type="1" id="2bf2ca25-95ef-4220-81e6-d27872b19f49" class="numbered-list" start="2"><li>If the list is <strong>not empty</strong> â†’ <strong>allocate the first block</strong> in the list <strong>in its entirety</strong>. Free blocks are <strong>never split</strong> to satisfy allocation requests.</li></ol><ol type="1" id="6531e1df-a886-40ab-a4d3-8288ba36157e" class="numbered-list" start="3"><li>If the list is <strong>empty</strong>:<ol type="a" id="5ff02460-3abb-41b8-a01a-04ec2eb852ce" class="numbered-list" start="1"><li>The allocator <strong>requests a fixed-size chunk of additional memory</strong> from the OS.</li></ol><ol type="a" id="8d9b4743-bb4c-4346-8afd-0152ec0c8f27" class="numbered-list" start="2"><li>The allocator <strong>divides the chunk into equal-size blocks</strong>, and links the blocks together to form the <strong>new free list</strong>.</li></ol></li></ol></li></ul><ul id="c16da6f8-5fc2-4e0f-a18e-43f35da5c4bf" class="bulleted-list"><li style="list-style-type:circle">To <strong>free </strong>a block, the allocator simply <strong>inserts the block</strong> at the <strong>front of the appropriate free list</strong>.</li></ul><ul id="103c05ce-0fc5-4047-868d-2476f7b0d78a" class="bulleted-list"><li style="list-style-type:circle">Allocating and freeing blocks are both <strong>fast constant-time</strong> operations.</li></ul><ul id="3825e467-1814-43ad-9e60-4bb765154131" class="bulleted-list"><li style="list-style-type:circle"><strong>No splitting</strong>, <strong>no coalescing</strong>, the <strong>size </strong>of an allocated block can be <strong>inferred from its address</strong>, the list need only be <strong>singly linked</strong> (allocate and free operations insert and delete blocks at the beginning of the free list) â†’ the only required field in any block is a <strong>one-word </strong><strong><code>succ</code></strong><strong> pointer</strong> in each <strong>free block</strong>. â†’ the <strong>minimum block size</strong> is only <strong>one word</strong>.</li></ul><ul id="9bec0707-df99-43b4-8240-21b009e2c542" class="bulleted-list"><li style="list-style-type:circle">Simple segregated storage is susceptible to <strong>internal and external fragmentation</strong>. - Free blocks are never <strong>split</strong>, and never <strong>coalesced</strong>.</li></ul></li></ul><ul id="2694a9f2-ff9c-47d9-ab9f-556bc4d7837f" class="bulleted-list"><li style="list-style-type:disc"><strong>Segregated Fits</strong><ul id="7181882c-d253-42cf-8755-9ed210ec4a12" class="bulleted-list"><li style="list-style-type:circle">The allocator maintains an array of free lists, where each free list contains potentially <strong>different-size blocks</strong> whose sizes are <strong>members of the size class</strong>.</li></ul><ul id="e7e7fc50-a2f8-460a-af47-acad37481a2b" class="bulleted-list"><li style="list-style-type:circle">To <strong>allocate </strong>a block:<ol type="1" id="7c0e3385-5df4-4d09-8454-cb6d56078737" class="numbered-list" start="1"><li>Determine the size class of the request, and do a <strong>first-fit search</strong> of the appropriate free list for a block that fits.</li></ol><ol type="1" id="bcb5fa46-e352-4741-9244-6635f00d17f1" class="numbered-list" start="2"><li>If found one â†’ (optionally) <strong>split</strong> it, <strong>insert the fragment</strong> in the appropriate free list.</li></ol><ol type="1" id="afd39d7c-b8b2-465d-ae25-3c78d6083cff" class="numbered-list" start="3"><li>If failed to find one â†’ search the free list for the <strong>next larger size class</strong>. Repeat until we find a block that fits.</li></ol><ol type="1" id="f44beff7-a77e-4f01-b3a0-3a0b741aeed1" class="numbered-list" start="4"><li>If <strong>none</strong> of the free lists yields a block that fits â†’ request <strong>additional heap memory</strong> from the OS, <strong>allocate the block</strong> out of this new heap memory, and place the <strong>remainder</strong> in the <strong>appropriate size class</strong>.</li></ol></li></ul><ul id="0beefe37-96a3-4e64-985b-8ff80226f034" class="bulleted-list"><li style="list-style-type:circle">To <strong>free </strong>a block, <strong>coalesce</strong> and place the result on the <strong>appropriate free list</strong>.</li></ul><ul id="c9b023d5-25e1-4a03-a680-720504ac50ba" class="bulleted-list"><li style="list-style-type:circle">The segregated fits is <strong>fast </strong>- Search times are reduced because <strong>searches are limited to particular parts of the heap</strong>.</li></ul><ul id="158f963f-1114-437d-8a79-34d5d55e42ac" class="bulleted-list"><li style="list-style-type:circle">The segregated fits is <strong>memory efficient</strong> - A simple first-fit search of a segregated free list <strong>approximates a best-fit search of the entire heap</strong>.</li></ul></li></ul><ul id="15324ecb-f1a6-46f1-90bb-815b23076809" class="bulleted-list"><li style="list-style-type:disc"><strong>Buddy Systems</strong><ul id="973fdcd5-4045-4f07-81e3-7537fd8994ce" class="bulleted-list"><li style="list-style-type:circle">A buddy system is a special case of <strong>segregated fits</strong> where each <strong>size class is a power of 2</strong>.</li></ul><ul id="198278f4-6029-4db8-ac53-b771508962d8" class="bulleted-list"><li style="list-style-type:circle">Given a heap of <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>m</mi></msup></mrow><annotation encoding="application/x-tex">2^m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span></span></span></span></span></span></span></span></span><span>ï»¿</span></span> words, we maintain a separate free list for each block size <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">2^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span></span><span>ï»¿</span></span>, where <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>â‰¤</mo><mi>k</mi><mo>â‰¤</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">0\leq k\leq m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">â‰¤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">â‰¤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span></span><span>ï»¿</span></span>.  (Originally, there is one free block of size <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>m</mi></msup></mrow><annotation encoding="application/x-tex">2^m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span></span></span></span></span></span></span></span></span><span>ï»¿</span></span> words.)</li></ul><ul id="bd670b7d-285a-4261-94ae-ec8f865e2cf7" class="bulleted-list"><li style="list-style-type:circle">Requested block sizes are <strong>rounded up</strong> to the nearest power of 2.</li></ul><ul id="4250acbc-7dac-42c6-97bb-acc6de6f4356" class="bulleted-list"><li style="list-style-type:circle">To allocate a block of size <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">2^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span></span><span>ï»¿</span></span>:<ol type="1" id="361bcd32-8c9a-4c45-98f9-5509c5939d32" class="numbered-list" start="1"><li>Find the first available block of size <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>j</mi></msup></mrow><annotation encoding="application/x-tex">2^j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.824664em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span></span></span></span></span></span></span></span><span>ï»¿</span></span>, such that <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>â‰¤</mo><mi>j</mi><mo>â‰¤</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">k \leq j \leq m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">â‰¤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">â‰¤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span></span><span>ï»¿</span></span>. </li></ol><ol type="1" id="2bb6a15b-f48b-4857-8072-1de0c968e562" class="numbered-list" start="2"><li>If <em>j = k</em>, we are done.</li></ol><ol type="1" id="b8fa29c1-696a-4ff0-b9ff-19158992e5af" class="numbered-list" start="3"><li>Otherwise, we <strong>recursively split</strong> the block in half until <em>j = k</em>. As we perform splitting, each <strong>remaining half</strong> (<strong>buddy</strong>) is placed on the <strong>appropriate free list</strong>.</li></ol></li></ul><ul id="22c27e9e-3454-407a-8a7a-eef8805938eb" class="bulleted-list"><li style="list-style-type:circle">To free a block of size <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">2^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span></span><span>ï»¿</span></span>, we continue <strong>coalescing with the free buddies</strong>. When we encounter an allocated buddy, we stop the coalescing.</li></ul><ul id="2b8ebcea-638a-438a-b2c0-9e898fd81843" class="bulleted-list"><li style="list-style-type:circle">Given the <strong>address and size of a block</strong>, itâ€™s easy to <strong>compute the address of its buddy</strong>.<p id="39b9a066-2e9e-4f65-8828-3d1281f01bc2" class="">(<em>Example : a block of size 32 bytes with address xxxâ€¦x00000 has its buddy at address xxxâ€¦x10000.</em>)</p></li></ul><ul id="8ca6d71e-24db-4cfb-9d13-2892a94f35e9" class="bulleted-list"><li style="list-style-type:circle">The buddy system allocator is <strong>fast in searching and coalescing</strong>.</li></ul><ul id="114ee46d-627f-4b89-a916-a64f1687a344" class="bulleted-list"><li style="list-style-type:circle">The <strong>power-of-2 requirement on the block size</strong> can cause significant <strong>internal fragmentation</strong>.</li></ul></li></ul></details></li></ul></div><h2 id="8e6314a6-96d3-4f20-a94f-c08fd64d97a1" class=""><details open=""><summary><mark class="highlight-blue">9.10 </mark>Garbage Collection</summary></details></h2><div class="indented"><ul id="961ac57a-40c5-479e-ba93-64a818745beb" class="toggle"><li><details open=""><summary><strong>Garbage Collector Basics</strong></summary><p id="20631ad9-9d09-473e-82e8-8bba4438e340" class="">A <strong>garbage collector </strong>is a <strong>dynamic storage allocator </strong>that <strong>automatically frees </strong>allocated blocks that are no longer needed by the program (<strong>garbage</strong>).</p><figure id="e1e8ca9e-784d-4969-9c80-083657d84e08" class="image"><a href="/assets/images/CSAPP-9/Untitled%2040.png"><img style="width:432px" src="/assets/images/CSAPP-9/Untitled%2040.png"/></a></figure><ul id="803d3ed6-f310-4216-8b12-5d32a5473581" class="bulleted-list"><li style="list-style-type:disc">A garbage collector views memory as a<strong> directed reachability graph</strong>:<ul id="661780a9-a22b-4244-9ece-469bb21211ab" class="bulleted-list"><li style="list-style-type:circle">The nodes of the graph are partitioned into a set of <strong>root nodes</strong> and a set of <strong>heap nodes</strong>.</li></ul><ul id="4388e3ab-eb2f-4eb9-a683-f4a730e4c0ac" class="bulleted-list"><li style="list-style-type:circle">Each <strong>heap node</strong> corresponds to an <strong>allocated block</strong> in the heap.</li></ul><ul id="5af9d8be-e8e7-4c57-bba4-1c98f415ce72" class="bulleted-list"><li style="list-style-type:circle"><strong>Root nodes </strong>correspond to locations not in the heap that <strong>contain pointers into the heap</strong>. <p id="25410512-dcd7-4550-a598-7178a4531de0" class="">(<em>examples: registers, variables on the stack, or global variables in the read/write data area</em>)</p></li></ul><ul id="062a722b-d9eb-4694-b7ec-5cfaec25c739" class="bulleted-list"><li style="list-style-type:circle">A <strong>directed edge </strong><strong><em>pâ†’q</em></strong><strong> </strong>means that some location in block <em>p</em> <strong>points to </strong>some location in block <em>q</em>.</li></ul></li></ul><ul id="d4591d4e-93f5-4523-a6d1-81234417f2ab" class="bulleted-list"><li style="list-style-type:disc">The <strong>garbage collector maintains </strong>some representation of the <strong>reachability graph </strong>and periodically <strong>reclaim </strong>the <strong>unreachable nodes </strong>(=garbage) by <strong>freeing </strong>them.</li></ul><ul id="89bba05e-47aa-413f-99e6-b6b5231241f4" class="bulleted-list"><li style="list-style-type:disc"><strong>Conservative garbage collectors :</strong> collectors which can correctly identify each reachable block as reachable, while may <strong>incorrectly </strong>identify some <strong>unreachable nodes as reachable</strong>.<p id="b794b4bd-c91f-4fdd-9c1b-2cf12ce8fbf2" class="">(<em>example : Collectors for languages like C and C++</em>)</p></li></ul><ul id="7fcb7c63-b6c3-4f9c-8fb7-3f4b0c053c86" class="bulleted-list"><li style="list-style-type:disc">Collectors can provide their service <strong>on demand</strong>, or they can run as <strong>separate threads in parallel </strong>with the application.</li></ul></details></li></ul><ul id="837eb835-583a-4165-970f-d4315d7217b6" class="toggle"><li><details open=""><summary><strong>Mark&amp;Sweep Garbage Collectors</strong></summary><p id="9b1ce0d6-6262-4926-9a95-6e22e1143927" class="">A <strong>Mark&amp;Sweep </strong>garbage collector consists two phases:</p><ul id="26ae2650-af24-40de-a49e-0c1a53ec82a5" class="bulleted-list"><li style="list-style-type:disc"><strong>Mark phase marks </strong>all <strong>reachable </strong>and allocated descendants of the root nodes.</li></ul><ul id="c233cd76-3b38-4b79-a9c2-47d260bbf125" class="bulleted-list"><li style="list-style-type:disc"><strong>Sweep phase</strong> <strong>frees </strong>each <strong>unmarked </strong>allocated block.</li></ul><pre id="654cbf16-1bc5-467a-aeb2-dc0cedccf993" class="code"><code>typedef void* ptr;

void mark(ptr p){
	if ((b = isPtr(p)) == NULL) return;
	if(blockMarked(b)) return;
	markBlock(b);
	len = length(b);
	for (i=0; i &lt; len; i++) mark(b[i]);
	return;
}

void sweep(ptr b, ptr end) {
	while (b &lt; end) /* Iterate over each block in the heap */
		if (blockMarked(b)) unmarkBlock(b);
		else if (blockAllocated(b)) free(b);
		b = nextBlock(b);
	}
	return;
}</code></pre><ul id="73451967-3585-410e-a3ef-0d4260c6dcb4" class="bulleted-list"><li style="list-style-type:disc"><code>ptr isPtr(ptr p)</code> : If <code>p</code> points to some word in an allocated block, it returns a pointer <code>b</code> to the beginning of that block. Returns NULL otherwise.</li></ul><ul id="0274f691-dfa4-4a0d-941d-43ca52b5f5a1" class="bulleted-list"><li style="list-style-type:disc">The <strong>mark phase </strong>calls <strong><code>mark</code></strong><strong> </strong>once <strong>for each root node</strong>. The <strong>sweep phase </strong>is a <strong>single call </strong>to the <strong><code>sweep</code></strong>. </li></ul></details></li></ul><ul id="21461edb-708e-4451-8e36-136457502b29" class="toggle"><li><details open=""><summary><strong>Conservative Mark&amp;Sweep for C Programs</strong></summary><p id="56933a19-c75c-4510-9d9a-e9319229fc57" class="">The <strong>C language</strong> poses some challenges for the <strong>implementation of the </strong><strong><code>isPtr</code></strong>:</p><ul id="db5049ff-3a83-4bca-add8-78e87b2afaf4" class="bulleted-list"><li style="list-style-type:disc">C doesnâ€™t tag <strong>memory locations </strong>with any <strong>type information</strong>. - There is no obvious way for <code>isPtr</code> to determine <strong>if its input parameter </strong><strong><code>p</code></strong><strong> is a pointer or not</strong>.</li></ul><ul id="12667e70-6020-4def-8345-d9080b2220de" class="bulleted-list"><li style="list-style-type:disc">There is no obvious way for <code>isPtr</code> to determine <strong>whether </strong><strong><code>p</code></strong><strong> points to the payload </strong>of an allocated block.</li></ul><p id="17c27ea9-d768-48c6-abb9-b6f387eac7cd" class=""><strong>Solution </strong>: Maintain <strong>the set of allocated blocks </strong>as <strong>a balanced binary tree </strong>that maintains the invariant that all blocks in the left subtree are located at smaller addresses and all blocks in the right subtree are located in larger addresses.</p><ul id="af37b462-c049-4160-87a1-21e2a609ae59" class="bulleted-list"><li style="list-style-type:disc">This requires <strong>two additional fields (</strong><strong><code>left</code></strong><strong> &amp; </strong><strong><code>right</code></strong><strong>) </strong>in the header of each <strong>allocated block</strong>. Each field points to the header of some allocated block.</li></ul><ul id="820bde4f-1fa7-4832-84e9-a870237c72d7" class="bulleted-list"><li style="list-style-type:disc"><code>isPtr(ptr p)</code> uses the tree to perform a <strong>binary search </strong>of the allocated blocks. It relies on the <strong>size field </strong>in the block header to determine if <strong><code>p</code></strong><strong> falls within the extent of the block</strong>.</li></ul><ul id="719357d4-d22e-4361-8e6b-5713037abae8" class="bulleted-list"><li style="list-style-type:disc">This solution is guaranteed to mark all of the nodes that are reachable from the roots.</li></ul><ul id="33ec4530-d0b4-4978-af1b-f1fb3eda3392" class="bulleted-list"><li style="list-style-type:disc">This solution is <strong>conservative </strong>- it may <strong>incorrectly mark </strong>blocks that are actually <strong>unreachable</strong>, and thus it may fail to free some garbage. â†’ can result in <strong>unnecessary external fragmentation</strong>.<ul id="519fc848-1667-4d31-8769-fd5e57366d19" class="bulleted-list"><li style="list-style-type:circle">scalars like <code>int</code>s or <code>float</code>s can masquerade as pointers. </li></ul><ul id="cc26012c-cedb-4804-970c-4aa50798baf5" class="bulleted-list"><li style="list-style-type:circle"><em>example : when some reachable allocated block contain an </em><code><em>int</em></code><em> in its payload whose value corresponds to an address in the payload of some other allocated block b, the allocator must conservatively mark block b as reachable.</em></li></ul></li></ul></details></li></ul></div><h2 id="bac85bb3-fa38-414d-8f66-49824ccd3a10" class=""><details open=""><summary><mark class="highlight-blue">9.11 </mark>Common Memory-Related Bugs in C Programs</summary></details></h2><div class="indented"><ul id="c79270f6-c797-4db9-807c-5d8b977562cf" class="bulleted-list"><li style="list-style-type:disc"><strong>Dereferencing Bad Pointers</strong><ul id="454bfd25-b3e9-45c3-828f-da5c5a2a657e" class="bulleted-list"><li style="list-style-type:circle">If we attempt to <strong>dereference a pointer </strong>into one of <strong>large holes </strong>in the VAS, OS will terminate the process with a <strong>segmentation exception</strong>.</li></ul><ul id="e96842f1-5407-49ea-a2ed-df5fa2ef175a" class="bulleted-list"><li style="list-style-type:circle">If we attempt to <strong>write </strong>to one of <strong>read-only </strong>areas, OS will terminate the process with a <strong>protection exception</strong>.</li></ul><pre id="ca3f8fe7-3bcd-4752-8e62-d95fc9cd3563" class="code"><code>scanf(&quot;%d&quot;, val) /* Buggy Code */
scanf(&quot;%d&quot;, &amp;val) /* You should pass scanf the address of the variable. */</code></pre></li></ul><ul id="0df39236-01ce-4044-82da-e61debf2ec31" class="bulleted-list"><li style="list-style-type:disc"><strong>Reading Uninitialized Memory</strong><ul id="f078d791-623a-4068-81a2-8265f3c60767" class="bulleted-list"><li style="list-style-type:circle">While bss memory locations are always initialized to zeros by the loader, this is not true for heap memory. </li></ul><pre id="9c2e384b-8ca9-45e1-b1ac-c6aba8661ea2" class="code"><code>/* Return y = Ax */
int *matvec(int **A, int *x, int n){
	int i, j;
	
	int *y = (int *)Malloc(n * sizeof(int));
	for (i = 0; i &lt; n; i++)
		for (j = 0; j &lt; n; j++)
			y[i] += A[i][j] * x[j]; /* Wrong part - y[i] is not initialized to zero! */
	return y;
}</code></pre><p id="b1c216e2-14f1-4186-88b6-36a9542f3dc9" class="">â†’ Explicitly zero <code>y[i]</code> or use <code>calloc</code>.</p></li></ul><ul id="847b9266-fdcc-48e0-b22a-3a55e1e4f225" class="bulleted-list"><li style="list-style-type:disc"><strong>Allowing Stack Buffer Overflows</strong><pre id="9656e6a9-d234-4565-afef-4347ce25eca8" class="code"><code>void bufoverflow(){
	char buf[64];

	gets(buf); /* Here is the stack buffer overflow bug */
	return;
}</code></pre><ul id="f6bfee3f-f4c8-4991-9b76-c855219fbe33" class="bulleted-list"><li style="list-style-type:circle"><code>gets</code> copies an arbitrary-length string to the buffer. â†’ Use <code>fgets</code>, which limits the size of the input string.</li></ul></li></ul><ul id="42cde10f-5a25-417a-beea-b173288fcbb7" class="bulleted-list"><li style="list-style-type:disc">Assuming That Pointers and the Objects They Point to Are the Same Size<pre id="e099e7cb-e583-4a31-befc-b50d250732bf" class="code"><code>/* Create an nxm array */
int **makeArray1(int n, int m){
	int i;
	int **A = (int **)Malloc(n * sizeof(int)); /* Wrong part - should be sizeof(int*) */

	for (i = 0; i &lt; n; i++) 
		A[i] = (int *)Malloc(m * sizeof(int));
	return A;
}</code></pre><p id="623a10bf-3daf-436a-b8b6-9c2d1d4f490b" class="">If we run this code on the Core i7, where a <strong>pointer is larger than an </strong><strong><code>int</code></strong>, the loop will <strong>write past the end of the </strong><strong><code>A</code></strong><strong> array</strong>. One of these words will likely be the <strong>boundary-tag footer of the allocated block </strong>â†’ The error can occur when the <strong>coalescing code </strong>in the allocator <strong>fails </strong>for no apparent reason.</p></li></ul><ul id="c94f0a9e-ff47-474b-a84e-aedba95b4a3c" class="bulleted-list"><li style="list-style-type:disc"><strong>Making Off-by-One Errors</strong><pre id="d91e3fa6-f556-41b0-8b63-39715bd1e758" class="code"><code>/* Create an nxm array */
int **makeArray2(int n, int m){
	int i;
	int **A = (int **)Malloc(n * sizeof(int *));

	for (i = 0; i &lt;= n; i++) /* Wrong part - should be i &lt; n */
		A[i] = (int *)Malloc(m * sizeof(int));
	return A;
}</code></pre><p id="f8302107-fcd8-4303-ad63-947d41c4b0f9" class="">This code will try to initialize n + 1 of its elements, overwriting some memory that follows the <code>A</code> array.</p></li></ul><ul id="0aaecbe3-c7aa-4cbd-8507-6eaee0ee83dd" class="bulleted-list"><li style="list-style-type:disc"><strong>Referencing a Pointer Instead of the Object It Points To</strong><pre id="1718afe5-2c41-46a8-beb2-8126e67e2428" class="code"><code>int *binheapDelete(int **binheap, int *size){
	int *packet = binheap[0];

	binheap[0] = binheap[*size - 1];
	*size--; /* Wrong part - should be (*size)-- */
	heapify(binheap, *size, 0);
	return(packet);
}</code></pre><p id="831cff2f-8e67-45b1-8b27-8feb2d23e9da" class="">The unary <code>--</code> and <code>*</code> operators have the <strong>same precedence </strong>and <strong>associate from right to left </strong>â†’ <code>*size--;</code> actually <strong>decrements the pointer itself </strong>instead of the integer value that it points to. â†’ Use <strong>parentheses</strong>!</p></li></ul><ul id="a3a9b972-d8c4-4ac9-af5d-909841015d95" class="bulleted-list"><li style="list-style-type:disc"><strong>Misunderstanding Pointer Arithmetic</strong><pre id="0dbe6cd5-52e4-4f03-872d-7ce153208b22" class="code"><code>int *search(int *p, int val){
	while (*p &amp;&amp; *p != val)
		p += sizeof(int); /* Wrong part - should be p++ */
	return p;
}</code></pre><p id="29899a6c-a75c-437a-ac04-38a0f2bfcf16" class="">The <strong>arithmetic operations on pointers </strong>are performed in units that are <strong>the size of the objects they point to</strong>. â†’ This function incorrectly scans every fourth integer in the array.</p></li></ul><ul id="f422a3c1-8fb2-4505-8b83-043884fddaa2" class="bulleted-list"><li style="list-style-type:disc"><strong>Referencing Nonexistent Variables</strong><pre id="9b833da5-a1b1-4369-b840-d52a814ae7b7" class="code"><code>int *stackref(){
	int val;
	return &amp;val;
}</code></pre><p id="4f20cc92-ee87-41c4-addf-73e5469afda3" class="">This functions returns a pointer to a <strong>local variable on the stack</strong>, and then <strong>pops </strong>its stack frame. â†’ Although the pointer still points to a valid memory address, it <strong>no longer points to a valid variable</strong>.</p></li></ul><ul id="4da90be0-ea1b-49d5-9058-80d006874254" class="bulleted-list"><li style="list-style-type:disc"><strong>Referencing Data in Free Heap Blocks</strong><pre id="bca9496b-b2e4-48f0-b1e5-535dc9b7debe" class="code"><code>int *heapref(int n, int m){
	int i;
	int *x, *y;
	
	x = (int *)Malloc(n * sizeof(int));

	// Other calls to malloc and free go here

	free(x);
		
	y = (int *)Malloc(m * sizeof(int));
	for (i = 0; i &lt; m; i++)
		y[i] = x[i]++; /* Wrong part - x[i] is a word in a free block. */

	return y;
{</code></pre></li></ul><ul id="c5f7e499-2972-4346-b177-18782c8d5c39" class="bulleted-list"><li style="list-style-type:disc"><strong>Introducing Memory Leaks</strong><pre id="ef44eb58-db07-4a02-966a-b0f0bbdf9f2a" class="code"><code>void leak(int n){
	int *x = (int *)Malloc(n * sizeof(int));
	
	return; /* Wrong part - x is garbage at this point */
}</code></pre></li></ul></div></div></article></body></html>