---
title:  "CS:APP Chapter 10 Summary ↔"
excerpt: "Chatper 10 - System-Level I/O"
toc: true
classes: wide

categories:
  - CSAPP

---
Recently, I've been studying CS:APP - I'm posting my own summary of chapter 10 that I wrote up using [Notion](https://cw00h.notion.site/CS-APP-6d3c5c01e6e1456ca51f594a80b5c1f0).

<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Chapter 10 : System-Level I/O</title><style>
/* cspell:disable-file */
/* webkit printing magic: print all background colors */

.Notion strong {
    font-weight: 600;
}

.Notion a,
.Notion a.visited {
	color: inherit;
	text-decoration: underline;
}

.Notion .pdf-relative-link-path {
	font-size: 80%;
	color: #444;
}

.Notion h1,
.Notion h2,
.Notion h3 {
	letter-spacing: -0.01em;
	line-height: 1.2;
	font-weight: 600;
	margin-bottom: 0;
    display: flex;
}

.Notion .page-title {
	font-size: 2.5rem;
	font-weight: 700;
	margin-top: 0;
	margin-bottom: 0.75em;
}

.Notion h1 {
	font-size: 1.875rem;
	margin-top: 1.875rem;
}

.Notion h2 {
	font-size: 1.5rem;
	margin-top: 1.5rem;
}

.Notion h3 {
	font-size: 1.25rem;
	margin-top: 1.25rem;
}

.Notion .source {
	border: 1px solid #ddd;
	border-radius: 3px;
	padding: 1.5em;
	word-break: break-all;
}

.Notion .callout {
	border-radius: 3px;
	padding: 1rem;
}

.Notion figure {
	margin: 1.25em 0;
	page-break-inside: avoid;
}

.Notion figcaption {
	opacity: 0.5;
	font-size: 85%;
	margin-top: 0.5em;
}

.Notion mark {
	background-color: transparent;
}

.Notion .indented {
	padding-left: 1.5em;
}

.Notion hr {
	background: transparent;
	display: block;
	width: 100%;
	height: 1px;
	visibility: visible;
	border: none;
	border-bottom: 1px solid rgba(55, 53, 47, 0.09);
}

.Notion img {
	max-width: 100%;
}

@media only print {
	.Notion img {
		max-height: 100vh;
		object-fit: contain;
	}
}

@page {
	margin: 1in;
}

.Notion .collection-content {
	font-size: 0.875rem;
}

.Notion .column-list {
	display: flex;
	justify-content: space-between;
}

.Notion .column {
	padding: 0 1em;
}

.Notion .column:first-child {
	padding-left: 0;
}

.Notion .column:last-child {
	padding-right: 0;
}

.Notion .table_of_contents-item {
	display: block;
	font-size: 0.875rem;
	line-height: 1.3;
	padding: 0.125rem;
}

.Notion .table_of_contents-indent-1 {
	margin-left: 1.5rem;
}

.Notion .table_of_contents-indent-2 {
	margin-left: 3rem;
}

.Notion .table_of_contents-indent-3 {
	margin-left: 4.5rem;
}

.Notion .table_of_contents-link {
	text-decoration: none;
	opacity: 0.7;
	border-bottom: 1px solid rgba(55, 53, 47, 0.18);
}

.Notion table,
.Notion th,
.Notion td {
	border: 1px solid rgba(55, 53, 47, 0.09);
	border-collapse: collapse;
}

.Notion table {
	border-left: none;
	border-right: none;
}

.Notion th,
.Notion td {
	font-weight: normal;
	padding: 0.25em 0.5em;
	line-height: 1.5;
	min-height: 1.5em;
	text-align: left;
}

.Notion th {
	color: rgba(55, 53, 47, 0.6);
}

.Notion ol,
.Notion ul {
	margin: 0;
	margin-block-start: 0.6em;
	margin-block-end: 0.6em;
}

.Notion li > ol:first-child,
.Notion li > ul:first-child {
	margin-block-start: 0.6em;
}

.Notion ul > li {
	list-style: disc;
}

.Notion ul.to-do-list {
	text-indent: -1.7em;
}

.Notion ul.to-do-list > li {
	list-style: none;
}

.to-do-children-checked {
	text-decoration: line-through;
	opacity: 0.375;
}

.Notion ul.toggle > li {
	list-style: none;
}

.Notion ul {
	padding-inline-start: 1.7em;
}

.Notion ul > li {
	padding-left: 0.1em;
}

.Notion ol {
	padding-inline-start: 1.6em;
}

.Notion ol > li {
	padding-left: 0.2em;
}

.mono ol {
	padding-inline-start: 2em;
}

.mono ol > li {
	text-indent: -0.4em;
}

.Notion .toggle {
	padding-inline-start: 0em;
	list-style-type: none;
}

/* Indent toggle children */
.Notion .toggle > li > details {
	padding-left: 1.7em;
}

.Notion .toggle > li > details > summary {
	margin-left: -1.1em;
}

.Notion .selected-value {
	display: inline-block;
	padding: 0 0.5em;
	background: rgba(206, 205, 202, 0.5);
	border-radius: 3px;
	margin-right: 0.5em;
	margin-top: 0.3em;
	margin-bottom: 0.3em;
	white-space: nowrap;
}

.Notion .collection-title {
	display: inline-block;
	margin-right: 1em;
}

.Notion .simple-table {
	margin-top: 1em;
	font-size: 0.875rem;
	empty-cells: show;
}
.Notion .simple-table td {
	height: 29px;
	min-width: 120px;
}

.Notion .simple-table th {
	height: 29px;
	min-width: 120px;
}

.Notion .simple-table-header-color {
	background: rgb(247, 246, 243);
	color: black;
}
.Notion .simple-table-header {
	font-weight: 500;
}

.Notion time {
	opacity: 0.5;
}

.Notion .icon {
	display: inline-block;
	max-width: 1.2em;
	max-height: 1.2em;
	text-decoration: none;
	vertical-align: text-bottom;
	margin-right: 0.5em;
}

.Notion img.icon {
	border-radius: 3px;
}

.Notion .user-icon {
	width: 1.5em;
	height: 1.5em;
	border-radius: 100%;
	margin-right: 0.5rem;
}

.Notion .user-icon-inner {
	font-size: 0.8em;
}

.Notion .text-icon {
	border: 1px solid #000;
	text-align: center;
}

.Notion .page-cover-image {
	display: block;
	object-fit: cover;
	width: 100%;
	max-height: 30vh;
}

.Notion .page-header-icon {
	font-size: 3rem;
	margin-bottom: 1rem;
}

.Notion .page-header-icon-with-cover {
	margin-top: -0.72em;
	margin-left: 0.07em;
}

.Notion .page-header-icon img {
	border-radius: 3px;
}

.Notion .link-to-page {
	margin: 1em 0;
	padding: 0;
	border: none;
	font-weight: 500;
}

.Notion p > .user {
	opacity: 0.5;
}

.Notion td > .user,
.Notion td > time {
	white-space: nowrap;
}

.Notion input[type="checkbox"] {
	transform: scale(1.5);
	margin-right: 0.6em;
	vertical-align: middle;
}

.Notion p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
}

.Notion .image {
	border: none;
	margin: 1.5em 0;
	padding: 0;
	border-radius: 0;
	text-align: center;
}

.Notion .code,
.Notion code {
	background: rgba(135, 131, 120, 0.15);
	border-radius: 3px;
	padding: 0.2em 0.4em;
	border-radius: 3px;
	font-size: 85%;
	tab-size: 2;
}

.Notion code {
	color: #eb5757;
}

.Notion .code {
	padding: 1.5em 1em;
}

.Notion .code-wrap {
	white-space: pre-wrap;
	word-break: break-all;
}

.Notion .code > code {
	background: none;
	padding: 0;
	font-size: 100%;
	color: inherit;
}

.Notion blockquote {
	font-size: 1.25em;
	margin: 1em 0;
	padding-left: 1em;
	border-left: 3px solid rgb(55, 53, 47);
}

.Notion .bookmark {
	text-decoration: none;
	max-height: 8em;
	padding: 0;
	display: flex;
	width: 100%;
	align-items: stretch;
}

.Notion .bookmark-title {
	font-size: 0.85em;
	overflow: hidden;
	text-overflow: ellipsis;
	height: 1.75em;
	white-space: nowrap;
}

.Notion .bookmark-text {
	display: flex;
	flex-direction: column;
}

.Notion .bookmark-info {
	flex: 4 1 180px;
	padding: 12px 14px 14px;
	display: flex;
	flex-direction: column;
	justify-content: space-between;
}

.Notion .bookmark-image {
	width: 33%;
	flex: 1 1 180px;
	display: block;
	position: relative;
	object-fit: cover;
	border-radius: 1px;
}

.Notion .bookmark-description {
	color: rgba(55, 53, 47, 0.6);
	font-size: 0.75em;
	overflow: hidden;
	max-height: 4.5em;
	word-break: break-word;
}

.Notion .bookmark-href {
	font-size: 0.75em;
	margin-top: 0.25em;
}

.sans { font-family: ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
.code { font-family: "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace; }
.serif { font-family: Lyon-Text, Georgia, ui-serif, serif; }
.mono { font-family: iawriter-mono, Nitti, Menlo, Courier, monospace; }
.pdf .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK JP'; }
.pdf:lang(zh-CN) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC'; }
.pdf:lang(zh-TW) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK TC'; }
.pdf:lang(ko-KR) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK KR'; }
.pdf .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK JP'; }
.pdf:lang(zh-CN) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK SC'; }
.pdf:lang(zh-TW) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK TC'; }
.pdf:lang(ko-KR) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK KR'; }
.pdf .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.highlight-default {
	color: rgba(55, 53, 47, 1);
}
.highlight-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.highlight-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.highlight-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.highlight-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.highlight-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.highlight-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.highlight-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.highlight-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.highlight-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.highlight-gray_background {
	background: rgba(241, 241, 239, 1);
}
.highlight-brown_background {
	background: rgba(244, 238, 238, 1);
}
.highlight-orange_background {
	background: rgba(251, 236, 221, 1);
}
.highlight-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.highlight-teal_background {
	background: rgba(237, 243, 236, 1);
}
.highlight-blue_background {
	background: rgba(231, 243, 248, 1);
}
.highlight-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.highlight-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.highlight-red_background {
	background: rgba(253, 235, 236, 1);
}
.block-color-default {
	color: inherit;
	fill: inherit;
}
.block-color-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.block-color-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.block-color-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.block-color-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.block-color-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.block-color-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.block-color-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.block-color-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.block-color-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.block-color-gray_background {
	background: rgba(241, 241, 239, 1);
}
.block-color-brown_background {
	background: rgba(244, 238, 238, 1);
}
.block-color-orange_background {
	background: rgba(251, 236, 221, 1);
}
.block-color-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.block-color-teal_background {
	background: rgba(237, 243, 236, 1);
}
.block-color-blue_background {
	background: rgba(231, 243, 248, 1);
}
.block-color-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.block-color-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.block-color-red_background {
	background: rgba(253, 235, 236, 1);
}
.select-value-color-pink { background-color: rgba(245, 224, 233, 1); }
.select-value-color-purple { background-color: rgba(232, 222, 238, 1); }
.select-value-color-green { background-color: rgba(219, 237, 219, 1); }
.select-value-color-gray { background-color: rgba(227, 226, 224, 1); }
.select-value-color-opaquegray { background-color: rgba(255, 255, 255, 0.0375); }
.select-value-color-orange { background-color: rgba(250, 222, 201, 1); }
.select-value-color-brown { background-color: rgba(238, 224, 218, 1); }
.select-value-color-red { background-color: rgba(255, 226, 221, 1); }
.select-value-color-yellow { background-color: rgba(253, 236, 200, 1); }
.select-value-color-blue { background-color: rgba(211, 229, 239, 1); }

.checkbox {
	display: inline-flex;
	vertical-align: text-bottom;
	width: 16;
	height: 16;
	background-size: 16px;
	margin-left: 2px;
	margin-right: 5px;
}

.checkbox-on {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
}

.checkbox-off {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
}
	
</style></head><body><article id="6a5f18d6-a0d9-4cf8-96f8-99b7af1a354c" class="page sans Notion" style="width: 100%; padding: 0px;"><div class="page-body"><h2 id="4866c655-5c9e-4f08-b43b-8c57f6fc483f" class=""><details open=""><summary><mark class="highlight-blue">10.1</mark> Unix I/O</summary></details></h2><div class="indented"><p id="0dc12ad0-adc9-4604-9e30-8e72b033ebb0" class="">All <strong>I/O devices </strong>are modeled as <strong>files</strong>, and all <strong>input and output </strong>is performed by <strong>reading and writing </strong>the appropriate files.  (<em>example : networks, disks, and terminals</em>)</p><p id="c865f466-843a-4fa8-96e4-b6de1f597431" class="">→ The <strong>Linux kernel </strong>can export a simple, low-level application interface, <strong>Unix I/O</strong>, that enables all input and output to be performed in a uniform and consistent way.</p><ul id="7450b7c7-2626-42f9-8dc6-41c7c151457c" class="bulleted-list"><li style="list-style-type:disc"><strong>Opening files</strong><ul id="0c4dc135-b44d-4843-832a-711e40d9e418" class="bulleted-list"><li style="list-style-type:circle">An <strong>application </strong>announces its intention to access an I/O device by asking the <strong>kernel </strong>to <strong>open </strong>the file.</li></ul><ul id="341e31ee-660c-4bd7-be49-b365a334dce3" class="bulleted-list"><li style="list-style-type:circle">The kernel returns a small nonnegative integer, a <strong>descriptor</strong>, that <strong>identifies the file</strong> in all subsequent operations on the file.</li></ul><ul id="079636f4-9645-44d2-9f87-90b770c24e47" class="bulleted-list"><li style="list-style-type:circle">The <strong>kernel </strong>keeps track of <strong>all information</strong> about the open file. ↔ The <strong>application </strong>only keeps track of the <strong>descriptor</strong>.</li></ul><ul id="fcb43974-02ee-4d37-9d28-0cde19ed7441" class="bulleted-list"><li style="list-style-type:circle">Each process created by a Linux shell begins life with <strong>3 open files</strong>:<ul id="34f720fb-950b-4600-b3d4-a0ba9c9cf41a" class="bulleted-list"><li style="list-style-type:square">standard input (descriptor 0)</li></ul><ul id="5cd5d6e1-08e9-48c6-b289-07993c7c6a96" class="bulleted-list"><li style="list-style-type:square">standard output (descriptor 1)</li></ul><ul id="a15329f9-e019-4d4f-afb9-a645d9ab2931" class="bulleted-list"><li style="list-style-type:square">standard error (descriptor 2)</li></ul></li></ul></li></ul><ul id="ee316a44-8f49-47cd-bff8-8c677231a795" class="bulleted-list"><li style="list-style-type:disc"><strong>Changing the current file position</strong><ul id="a9dbc9b4-5362-49ae-90a9-535f6bfb55fe" class="bulleted-list"><li style="list-style-type:circle">A <strong>file position</strong> <em>k</em>, initially 0, is a <strong>byte offset</strong> from the beginning of a file, and is maintained for <strong>each open file</strong>. </li></ul><ul id="098a3658-81c9-44bd-af1c-2b9365e64ee2" class="bulleted-list"><li style="list-style-type:circle">An application can <strong>set the current file position</strong> explicitly by performing a <strong>seek </strong>operation.</li></ul></li></ul><ul id="474c3318-1b57-4a95-8811-2a3f826ade3b" class="bulleted-list"><li style="list-style-type:disc"><strong>Reading and writing files</strong><ul id="b622878b-3d80-4300-9433-652a44c5d8dd" class="bulleted-list"><li style="list-style-type:circle">A <strong>read operation</strong> copies <em>n &gt; 0</em> bytes <strong>from a file to memory</strong>, starting at the <strong>current file position</strong> <em>k</em> and then <strong>incrementing </strong><strong><em>k</em></strong><strong> by </strong><strong><em>n</em></strong>.</li></ul><ul id="89ba67d4-6461-4997-928b-01f0787fe4d9" class="bulleted-list"><li style="list-style-type:circle">A <strong>write operation</strong> copies <em>n &gt; 0 </em>bytes <strong>to a file</strong>, starting at the <strong>current file position</strong> <em>k</em> and then <strong>incrementing </strong><strong><em>k </em></strong><strong>by</strong><strong><em> n</em></strong>.</li></ul><ul id="66aceba3-6def-4435-81b3-90af0698376c" class="bulleted-list"><li style="list-style-type:circle">Given a file with a size of <em>m</em> bytes, performing a read operation when <strong><em>k ≥ m</em></strong> triggers a condition <strong>end-of-file (EOF)</strong>, which can be detected by the application.</li></ul></li></ul><ul id="a1b4a8bf-ffc6-4d78-8034-94f6979ca43b" class="bulleted-list"><li style="list-style-type:disc"><strong>Closing files</strong><ul id="7a853e46-5648-4f93-b3b3-622a41e5fee0" class="bulleted-list"><li style="list-style-type:circle">An <strong>application </strong>finishes accessing a file by asking the <strong>kernel </strong>to <strong>close </strong>the file.</li></ul><ul id="1b692249-10dc-4d55-bcb0-ccd281ab9322" class="bulleted-list"><li style="list-style-type:circle">The kernel <strong>frees the data structures</strong> it created when the file was opened, and <strong>restores the descriptor</strong> to a pool of available descriptors.</li></ul><ul id="6587de50-7c0d-441b-b0d9-db43f2c87638" class="bulleted-list"><li style="list-style-type:circle">When a <strong>process terminates</strong>, the kernel <strong>closes all open files</strong> and frees their memory resources.</li></ul></li></ul></div><h2 id="8adb1c6b-7db5-42ab-a4af-98ecfc61e0f5" class=""><details open=""><summary><mark class="highlight-blue">10.2</mark> Files</summary></details></h2><div class="indented"><p id="b34271af-0806-49ec-8bb9-d805b8c587fe" class="">Each Linux file has a <strong>type </strong>that indicates its role in the system:</p><ul id="a3964813-c835-4966-a3a0-c29e7658abdd" class="bulleted-list"><li style="list-style-type:disc"><strong>Regular file</strong><ul id="e080ef19-a4fb-44df-bdfa-fdebf74f0036" class="bulleted-list"><li style="list-style-type:circle">A regular file contains <strong>arbitrary data</strong>.</li></ul><ul id="521c5dfa-6aee-476d-93e6-48532c3082a8" class="bulleted-list"><li style="list-style-type:circle"><strong>Application </strong>programs distinguish between <strong>text files</strong>, and <strong>binary files</strong>. To the <strong>kernel</strong>, there is <strong>no difference</strong> between text and binary files.<ul id="bc80d582-6e18-49d6-9c6f-60fab6c2451e" class="bulleted-list"><li style="list-style-type:square"><strong>Text files</strong> are regular files that <strong>contain only ASCII or Unicode characters</strong>.</li></ul><ul id="6feb3327-6cb7-4139-b7bc-055fd6f863a7" class="bulleted-list"><li style="list-style-type:square"><strong>Binary files</strong> are everything else.</li></ul></li></ul></li></ul><ul id="3544e057-9fdd-47c2-b177-a866aa4265b3" class="bulleted-list"><li style="list-style-type:disc"><strong>Directory</strong><ul id="af79a2b5-fddf-4a0f-b981-c97ad7c694a8" class="bulleted-list"><li style="list-style-type:circle">A directory is a file consisting of an <strong>array of links</strong>, where each link <strong>maps a filename to a file</strong>, which may be another directory.</li></ul><ul id="82873b21-0419-41d6-93c9-2797a281622e" class="bulleted-list"><li style="list-style-type:circle">Each directory contains at least two entries: <code>.</code> is a link to the <strong>directory itself</strong>, and <code>..</code> is a link to the <strong>parent directory</strong> in the directory hierarchy.</li></ul><ul id="709048b4-c47c-4e8a-b8a4-8b20a004d75c" class="bulleted-list"><li style="list-style-type:circle">You can create a directory with the <code>mkdir</code>, view its contents with <code>ls</code>, and delete it with <code>rmdir</code>.</li></ul></li></ul><ul id="d37d87a1-60c3-4ede-a0a2-5947fa0f4618" class="bulleted-list"><li style="list-style-type:disc"><strong>Socket</strong><ul id="e0a86eba-c40c-4f33-b341-5a9c97c68da1" class="bulleted-list"><li style="list-style-type:circle">A socket is a file that is used to communicate with another process across a network. (<strong>Section </strong><mark class="highlight-blue"><strong>11.4</strong></mark>)</li></ul></li></ul><p id="c0fa544e-66f0-4674-9473-dee4cf0ecadb" class="">The Linux kernel organizes all files in a single directory hierarchy anchored by the root directory named <code>/</code>. </p><figure id="3e2d96d0-4259-49d7-a997-30cdc3ed54c6" class="image"><a href="/assets/images/CSAPP-10/Untitled.png"><img style="width:432px" src="/assets/images/CSAPP-10/Untitled.png"/></a></figure><p id="f5ba6cd3-e5db-43cc-8d07-ae0c7e78810c" class="">Each process has a current working directory as part of its context, that identifies its current location in the directory hierarchy.</p><p id="4443a7fa-d365-417c-a2df-55ba345ea421" class="">You can change the shell’s current working directory with the <code>cd</code> command.</p><p id="93750067-9e57-42c0-81be-63653c1c978d" class="">Locations in the directory hierarchy are specified by pathnames, each of which is a string consisting of an optional slash followed by a sequence of filenames separated by slashes.</p><ul id="c37b4286-ad0d-4930-b5a2-2e33005e7ded" class="bulleted-list"><li style="list-style-type:disc">An absolute pathname starts with a slash and denotes a path from the root node. (<em>example : </em><em><code>/home/droh/hello.c</code></em>)</li></ul><ul id="455c4f93-0af2-4deb-9eb0-e8bd03012b77" class="bulleted-list"><li style="list-style-type:disc">A relative pathname starts with a filename and denotes a path from the current working directory. (<em>example : </em><code><em>./hello.c</em></code><em><em>, </em></em><code><em><em>../home/droh/hello.c</em></em></code>)</li></ul></div><h2 id="0026c9a5-a7b8-4a8a-86c4-396ec3f94fab" class=""><details open=""><summary><mark class="highlight-blue">10.3</mark> Opening and Closing Files</summary></details></h2><div class="indented"><p id="5a048996-4aa1-4c30-b631-046e55519157" class="">A process opens an existing file or creates a new file by calling the <code>open</code>.</p><pre id="d2cb57c9-833d-48e7-9855-4cd3c4e233fb" class="code"><code>#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;

int open(char *filename, int flags, mode_t mode);</code></pre><ul id="9d8c0831-14f0-484b-a548-6fa8941e2f46" class="bulleted-list"><li style="list-style-type:disc">The <code>open</code> <strong>converts a filename to a file descriptor</strong> and <strong>returns the descriptor number</strong>.</li></ul><ul id="c5058d7c-19d7-4255-b71c-e435a153e055" class="bulleted-list"><li style="list-style-type:disc">The descriptor returned is always the <strong>smallest descriptor that is not currently open </strong>in the process.</li></ul><ul id="d440315e-94c2-4102-b91e-9abf4727cb98" class="bulleted-list"><li style="list-style-type:disc">The <strong><code>flags</code></strong><strong> argument</strong> indicates <strong>how the process intends to access the file</strong>:<ul id="bcdbf397-eee3-439a-bf32-5c94318cd1d1" class="bulleted-list"><li style="list-style-type:circle"><code>O_RDONLY</code> : Reading only</li></ul><ul id="eecbaa64-cc18-446c-88aa-87be17636e2b" class="bulleted-list"><li style="list-style-type:circle"><code>O_WRONLY</code> : Writing only</li></ul><ul id="3c83260f-0b7d-41d4-9d6b-c65620f202d0" class="bulleted-list"><li style="list-style-type:circle"><code>O_RDWR</code> : Reading and writing</li></ul><ul id="8684e771-47ad-4d4d-8ea7-a123847d4279" class="bulleted-list"><li style="list-style-type:circle"><code>O_CREAT</code> : If the file doesn’t exist, then create a truncated (empty) version of it.</li></ul><ul id="40ec652c-8247-4b11-93df-ed3547df9445" class="bulleted-list"><li style="list-style-type:circle"><code>O_TRUNC</code> : If the file already exists, then truncate it.</li></ul><ul id="c27aeec0-3119-47f2-9973-b4df47186a78" class="bulleted-list"><li style="list-style-type:circle"><code>O_APPEND</code> : Before each write operation, set the file position to the end of the file.</li></ul><ul id="93f1199b-11c8-42f1-9a7f-8c457a12cf4b" class="bulleted-list"><li style="list-style-type:circle">The <code>flags</code> can also be <strong>ORed </strong>with one or more bit masks. (<em>example : </em><code><em>fd = Open(&quot;foo.txt&quot;, O_WRONLY|O_APPEND, 0);</em></code>)</li></ul></li></ul><ul id="25e0d588-8873-4ee7-bae5-849d8faee490" class="bulleted-list"><li style="list-style-type:disc">The <code>mode</code> argument specifies the <strong>access permission bits</strong> of new files. <figure id="4e0848c8-1f9b-4c1d-aebd-f806231b3bf4" class="image"><a href="/assets/images/CSAPP-10/Untitled%201.png"><img style="width:384px" src="/assets/images/CSAPP-10/Untitled%201.png"/></a></figure><ul id="bd619c04-7e98-4ba6-a5ce-36210af842ab" class="bulleted-list"><li style="list-style-type:circle">Each process has a <code>umask</code> as part of its context, that is set set by calling the <code>umask</code> function.</li></ul><ul id="d5182d8f-4cb8-492e-b558-afcf090d3548" class="bulleted-list"><li style="list-style-type:circle">When a process creates a new file by calling the <code>open</code> with some <code>mode</code> argument, the access permission bits of the file are set to <code>mode &amp; ~umask</code>. </li></ul><pre id="b337257a-9304-4d8f-9a9d-5651783c5072" class="code"><code>umask(S_IWGRP|S_IWOTH);
fd = Open(&quot;foo.txt&quot;, O_CREAT|O_TRUNC|O_WRONLY, S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH);
// -&gt; Creates a new file in which the owner of the file has read and write permissions, and all other users have read permissions.</code></pre></li></ul><p id="8beb1822-b49f-4fc5-ba66-6428d8956636" class="">A process <strong>closes </strong>an open file by calling the <strong><code>close</code></strong>.</p><pre id="d51c2f74-42c8-4672-b373-31fd9fbebdf3" class="code"><code>#include &lt;unistd.h&gt;

int close(int fd);</code></pre></div><h2 id="eebaa123-8c77-4800-9f94-4a74bb360daa" class=""><details open=""><summary><mark class="highlight-blue">10.4</mark> Reading and Writing Files</summary></details></h2><div class="indented"><p id="058e73da-81b9-4e53-9ac8-954e1becb12a" class="">Applications perform input and output by calling <strong><code>read</code></strong><strong> and </strong><strong><code>write</code></strong> functions.</p><pre id="f36d04a4-88f7-41c2-bbdd-0f25a0848b82" class="code"><code>#include &lt;unistd.h&gt;

ssize_t read(int fd, void *buf, size_t n);

ssize_t write(int fd, const void *buf, size_t n);</code></pre><ul id="3e13e642-d8df-40dd-9562-43307faa98e5" class="bulleted-list"><li style="list-style-type:disc"><code>read</code> <strong>copies </strong>at most <strong><code>n</code></strong><strong> bytes</strong> from the <strong>current file position of descriptor </strong><strong><code>fd</code></strong> to <strong>memory location </strong><strong><code>buf</code></strong><strong>.</strong><ul id="1bfd1259-7b19-4dcd-9a74-fa67a5d6a2e5" class="bulleted-list"><li style="list-style-type:circle">A return value of <strong>1</strong> → an <strong>error</strong>, a return value of <strong>0</strong> → <strong>EOF</strong>.</li></ul><ul id="79a91b77-7483-44aa-8b76-54b720efaa83" class="bulleted-list"><li style="list-style-type:circle">Otherwise, the return value = the <strong>number of bytes </strong>that were <strong>actually transferred</strong>.</li></ul></li></ul><ul id="7e45b32a-5ddb-4915-b0e0-99a227b87ea3" class="bulleted-list"><li style="list-style-type:disc"><code>write</code> <strong>copies </strong>at most <strong><code>n</code></strong><strong> bytes</strong> from <strong>memory location </strong><strong><code>buf</code></strong> to the <strong>current file position of descriptor </strong><strong><code>fd</code></strong>.</li></ul><ul id="40026c5e-655a-4ddb-b9d0-6140a6c234e2" class="bulleted-list"><li style="list-style-type:disc">Applications can explicitly <strong>modify </strong>the <strong>current file position</strong> by calling the <strong><code>lseek</code></strong>.</li></ul><ul id="452a0b9a-fa56-4b30-88ef-dbacfb0329a8" class="bulleted-list"><li style="list-style-type:disc">In some situations, <code>read</code> and <code>write</code> <strong>transfer fewer bytes</strong> than the application requests. (<strong>Short counts</strong>) They occur for a number of reasons:<ul id="dad33e4b-93bc-42c5-94c9-9c75999b05fa" class="bulleted-list"><li style="list-style-type:circle"><strong>Encountering EOF on reads</strong></li></ul><ul id="821302a6-34b2-48f7-ab15-322e398b8e70" class="bulleted-list"><li style="list-style-type:circle"><strong>Reading text lines from a terminal </strong>: If the open file is associated with a <strong>terminal </strong>(i.e., a keyboard and display), then each <code>read</code> will <strong>transfer one text line at a time</strong>, returning a <strong>short count equal to the size of the text line</strong>.</li></ul><ul id="838d3417-3fac-4e08-b60c-70c9e11d679f" class="bulleted-list"><li style="list-style-type:circle"><strong>Reading and writing network sockets</strong> : If the open file corresponds to a <strong>network socket</strong>, then <strong>internal buffering constraints</strong> and <strong>long network delays</strong> can cause <code>read</code> and <code>write</code> to return <strong>short counts</strong>.</li></ul></li></ul><ul id="5371b094-5375-4d35-a002-50733a5ad048" class="bulleted-list"><li style="list-style-type:disc">To deal with short counts, <strong>repeatedly call </strong><strong><code>read</code></strong><strong> and </strong><strong><code>write</code></strong> until all requested bytes have been transferred.</li></ul></div><h2 id="ec942ac3-b497-4c8f-b8f2-7ba30db7114a" class=""><details open=""><summary><mark class="highlight-blue">10.5</mark> Robust Reading and Writing with the <code>RIO</code> Package</summary></details></h2><div class="indented"><ul id="cddc6db6-600c-4425-b9c3-1b8b36a3f086" class="toggle"><li><details open=""><summary><strong><code>RIO</code></strong><strong> Package</strong></summary><p id="2814677a-42d4-4308-a55b-170c14bc7676" class="">The <strong>RIO package</strong> provides two different kinds of functions:</p><ul id="229739c8-2629-4095-a75a-9e9630bccd06" class="bulleted-list"><li style="list-style-type:disc"><strong>Unbuffered input and output functions</strong><ul id="6f6cd1f4-1e60-44ab-ae08-0258dedfdcf9" class="bulleted-list"><li style="list-style-type:circle">transfer data <strong>directly </strong>between memory and a file, with <strong>no application-level buffering</strong>.</li></ul><ul id="d444c486-2326-49cc-bff6-7b07644a390e" class="bulleted-list"><li style="list-style-type:circle">especially useful for reading and writing <strong>binary data </strong>to and from <strong>networks</strong>.</li></ul></li></ul><ul id="46857518-c1e4-4a60-8623-b3cd54bcc7e5" class="bulleted-list"><li style="list-style-type:disc"><strong>Buffered input functions</strong><ul id="590e9ce5-d579-41b9-95f3-1ba2fcd9180f" class="bulleted-list"><li style="list-style-type:circle">Using these functions, you can read text lines and binary data from a file whose contents are <strong>cached in an application-level buffer</strong>. (similar to standard I/O functions such as <code>printf</code>)</li></ul><ul id="88d48b28-b651-49e3-be6a-ee3b983f8aea" class="bulleted-list"><li style="list-style-type:circle">are <strong>thread-safe</strong> (<strong>Section </strong><mark class="highlight-blue"><strong>12.7</strong></mark>)</li></ul><ul id="cde8aba8-b9a1-41a5-bd1a-8e2d25fc7e3b" class="bulleted-list"><li style="list-style-type:circle"><strong>can be interleaved</strong> arbitrarily on the <strong>same descriptor</strong>.</li></ul></li></ul></details></li></ul><ul id="1fec137c-c5a2-4ad7-a2f6-0efe2545ae3c" class="toggle"><li><details open=""><summary><strong><code>RIO</code></strong><strong> Unbuffered Input and Output Functions</strong></summary><p id="c08cc4a3-f149-467d-9aa9-62a8f0f26240" class="">Applications can transfer data <strong>directly</strong> between memory and a file by calling the <code>rio_readn</code> and <code>rio_writen</code> functions.</p><pre id="75af01e5-fbad-4488-bcfd-d0573a33be1c" class="code"><code>#include &quot;csapp.h&quot;

ssize_t rio_readn(int fd, void *usrbuf, size_t n){
	size_t nleft = n;
	ssize_t nread;
	char *bufp = usrbuf;

	while (nleft &gt; 0) {
		if ((nread = read(fd, bufp, nleft)) &lt; 0) {
			if (errno == EINTR) /* Interrupted by sig handler return */
				nread = 0; /* and call read() again */
			else
				return -1; /* errno set by read() */
		}
		else if (nread == 0)
			break; /* EOF */
		neleft -= nread;
		bufp += nread;
	}
	return (n - nleft); /* Return &gt;= 0 */
}

ssize_t rio_writen(int fd, void *usrbuf, size_t n){
	size_t nleft = n;
	ssize_t nwritten;
	char *bufp = usrbuf;

	while (nleft &gt; 0) {
		if ((nwritten = write(fd, bufp, nleft)) &lt;= 0) {
			if (errno = EINTR) /* Interrupted by sig handler return */
				nwritten = 0; /* and call write() again */
			else
				return -1; /* errno set by write() */
		}
		nleft -= nwritten;
		bufp += nwritten;
	}
	return n;
}</code></pre><ul id="f4d9d4ee-13b8-4788-bd9d-83524cf3ff74" class="bulleted-list"><li style="list-style-type:disc"><code>rio_readn</code> <strong>transfers </strong>up to <code>n</code> bytes from the <strong>current file position of descriptor </strong><strong><code>fd</code></strong> to <strong>memory location </strong><strong><code>usrbuf</code></strong>.</li></ul><ul id="2a73bece-206d-4251-ae52-5f0a007febc2" class="bulleted-list"><li style="list-style-type:disc"><code>rio_readn</code> can only return a <strong>short count</strong> if it encounters <strong>EOF</strong>.</li></ul><ul id="8d0f55b6-5d6a-48eb-a9ea-e9b666ecb455" class="bulleted-list"><li style="list-style-type:disc"><code>rio_writen</code> <strong>transfers </strong><code>n</code> bytes from <strong>location </strong><strong><code>usrbuf</code></strong> to <strong>descriptor </strong><strong><code>fd</code></strong>.</li></ul><ul id="e1f14969-aad7-48f4-9e84-bae49a078834" class="bulleted-list"><li style="list-style-type:disc">The <code>rio_writen</code> <strong>never </strong>returns a <strong>short count</strong>.</li></ul><ul id="d98aa30d-b5de-4236-a8b6-59ac290e1ab4" class="bulleted-list"><li style="list-style-type:disc">Calls to <code>rio_readn</code> and <code>rio_writen</code> can be <strong>interleaved </strong>arbitrarily on the <strong>same descriptor</strong>.</li></ul><ul id="b129e2d8-8b92-42cd-8fbf-617d250cba18" class="bulleted-list"><li style="list-style-type:disc">Each function manually <strong>restarts the </strong><strong><code>read</code></strong><strong> or </strong><strong><code>write</code></strong><strong> function</strong> if it is <strong>interrupted</strong> by the return from an <strong>application signal handler</strong>.</li></ul></details></li></ul><ul id="ddfa59c9-cdf4-4491-bb4c-53ee677354f0" class="toggle"><li><details open=""><summary><strong><code>RIO</code></strong><strong> Buffered Input Functions</strong></summary><ul id="09d3faf0-db9f-4760-a0fe-0c6a0ac1d0b9" class="bulleted-list"><li style="list-style-type:disc"><strong>Read buffer - </strong><strong><code>rio_t</code></strong><strong>, </strong><strong><code>rio_readinitb</code></strong><pre id="40d1d760-e2be-4aea-99c3-58a4029ae08f" class="code"><code>#define RIO_BUFSIZE 8192
typedef struct {
	int rio_fd; /* Descriptor for this internal buf */
	int rio_cnt; /* Unread bytes in internal buf */
	char *rio_bufptr; /* Next unread byte in internal buf */
	char rio_buf[RIO_BUFSIZE]; /* Internal buffer */
} rio_t;

void rio_readinitb(rio_t *rp, int fd){
	rp-&gt;rio_fd = fd;
	rp-&gt;rio_cnt = 0;
	rp-&gt;rio_bufptr = rp-&gt;rio_buf;
}</code></pre><ul id="d9133bfa-96c8-465f-8d84-ace1fe276c3f" class="bulleted-list"><li style="list-style-type:circle"><code>rio_t</code> is the <strong>read buffer</strong> used in <code>RIO</code> package’s <strong>buffered </strong>input functions.</li></ul><ul id="ac443b49-78bf-495c-bad3-db03e3dcf35c" class="bulleted-list"><li style="list-style-type:circle"><code>rio_readinitb</code> sets up an <strong>empty read buffer</strong> and associates an <strong>open file descriptor</strong> with that buffer. <code>rio_readinitb</code> is called <strong>once </strong>per <strong>open descriptor</strong>.</li></ul></li></ul><ul id="dd9dfc96-97ba-4338-b6f4-f15452ac9081" class="bulleted-list"><li style="list-style-type:disc"><strong>Buffered Input Function - </strong><strong><code>rio_read</code></strong><pre id="31f3e85c-279f-43ca-97bb-c691aae1ffb1" class="code"><code>static ssize_t rio_read(rio_t *rp, char *usrbuf, size_t n){
	int cnt;
	
	while (rp-&gt;rio_cnt &lt;= 0){ /* Refill if buf is empty */
		rp-&gt;rio_cnt = read(rp-&gt;rio_fd, rp-&gt;rio_buf, sizeof(rp-&gt;rio_buf));
		if(rp-&gt;rio_cnt &lt; 0) {
			if (errno != EITNR) /* Interrupted by sig handler return */
				return -1;
		}
		else if (rp-&gt;rio_cnt == 0) /* EOF */
			return 0;
		else rp-&gt;rio_bufptr = rp-&gt;rio_buf; /* Reset buffer ptr */
	}

	/* Copy min(n, rp-&gt;rio_cnt) bytes from internal buf to user buf */
	cnt = n;
	if (rp-&gt;rio_cnt &lt; n) cnt = rp-&gt;rio_cnt;
	memcpy(usrbuf, rp-&gt;rio_bufptr, cnt);
	rp-&gt;rio_bufptr += cnt;
	rp-&gt;rio_cnt -= cnt;
	return cnt;
}</code></pre><ul id="ae6575a7-1fe3-4cf6-bfc1-f098b5db07d1" class="bulleted-list"><li style="list-style-type:circle"><code>rio_read</code> is a <strong>buffered version</strong> of the <strong>Linux </strong><strong><code>read</code></strong>.</li></ul><ol type="1" id="2099ab08-94b3-468d-a633-23552e881765" class="numbered-list" start="1"><li>When <code>rio_read</code> is called with a request to read <code>n</code> bytes, there are <strong><code>rp-&gt;rio_cnt</code></strong><strong> unread bytes</strong> in the <strong>read buffer</strong>.</li></ol><ol type="1" id="cc33bd54-6141-4d5d-b4fd-9c9d00006194" class="numbered-list" start="2"><li>If the buffer is <strong>empty </strong>→ <strong>replenish </strong>the buffer with a <strong>call to </strong><strong><code>read</code></strong>. A <strong>short count</strong> from this <code>read</code> is not an error; it simply has the effect of <strong>partially filling the read buffer</strong>.</li></ol><ol type="1" id="483e46a7-8ffa-4bf6-a78b-63922c0f3417" class="numbered-list" start="3"><li>Once the buffer is <strong>nonempty </strong>→ <code>rio_read</code> <strong>copies </strong>the <strong><code>min(n, rp-&gt;rio_cnt)</code></strong> bytes from the <strong>read buffer</strong> to the <strong>user buffer</strong> and returns the <strong>number of bytes copied</strong>.</li></ol></li></ul><ul id="2c1191f0-7622-413c-acd8-a33e182e0a85" class="bulleted-list"><li style="list-style-type:disc"><strong>Buffered Input Function - </strong><strong><code>rio_readlineb</code></strong><strong>, </strong><strong><code>rio_readnb</code></strong><pre id="58bcba9f-28ef-4704-80aa-74b048787b33" class="code"><code>ssize_t rio_readlineb(rio_t *rp, void *usrbuf, size_t maxlen){
	int n, rc;
	char c, *bufp = usrbuf;

	for (n = 1; n &lt; maxlen; n++){
		if ((rc = rio_read(rp, &amp;c, 1)) == 1) {
			*bufp++ = c;
			if(c == &#x27;\n&#x27;) {
				n++;
				break;
			}
		} else if (rc == 0) {
			if (n == 1) return 0; /* EOF, no data read */
			else break; /* EOF, some data was read */
		} else return -1; /* Error */
	}
	*bufp = 0; /* Terminate with NULL */
	return n-1;
}</code></pre><ul id="25159009-ebf9-4151-b8b9-a8bd6b5e9794" class="bulleted-list"><li style="list-style-type:circle"><code>rio_readlineb</code> reads the next text line from file <code>rp</code>, copies it to memory location <code>usrbuf</code>, and terminates the text line with the NULL character.</li></ul><ul id="a31b9b01-4f15-477f-92a0-9ea62e402258" class="bulleted-list"><li style="list-style-type:circle"><code>rio_readlineb</code> reads at most <code>maxlen-1</code> bytes, leaving room for the terminating NULL. Text lines that exceed <code>maxlen-1</code> bytes are truncated and terminated with a NULL.</li></ul><ul id="69674ed3-f038-42d9-9c11-ac5f45149261" class="bulleted-list"><li style="list-style-type:circle">Using <strong><code>rio_readlineb</code></strong> is much more <strong>efficient </strong>than using <strong><code>read</code></strong><strong> </strong>to <strong>transfer 1 byte at a time</strong>, checking each byte for the newline character.</li></ul><pre id="b7be124a-a103-47bd-8536-b72898f7e35d" class="code"><code>ssize_t rio_readnb(rio_t *rp, void *usrbuf, size_t n){
	size_t nleft = n;
	ssize_t nread;
	char *bufp = usrbuf;
	
	while (nleft &gt; 0) {
		if ((nread = rio_read(rp, bufp, nleft)) &lt; 0) return -1; /* errno set by read() */
		else if (nread == 0) break; /* EOF */
		nleft -= nread;
		bufp += nread;
	}
	return (n - nleft); /* Return &gt;= 0 */
}</code></pre><ul id="21645533-e4ed-42f8-8bd0-6914ddaf8c14" class="bulleted-list"><li style="list-style-type:circle"><strong><code>rio_readnb</code></strong><strong> </strong>reads up to <code>n</code> bytes from file <code>rp</code> to memory location <code>usrbuf</code>. </li></ul><ul id="f59fd685-7089-4256-b43d-3caf3d3cc48f" class="bulleted-list"><li style="list-style-type:circle"><strong><code>rio_readnb</code></strong><strong> </strong>has the <strong>same structure</strong> as <strong><code>rio_readn</code></strong>, with <strong><code>rio_read</code></strong> substituted for <code>read</code>.</li></ul><ul id="898143b7-9fa7-4aea-a23a-f913c7073ad3" class="bulleted-list"><li style="list-style-type:circle">Calls to <strong><code>rio_readlineb</code></strong><strong> </strong>and <strong><code>rio_readnb</code></strong><strong> </strong>can be <strong>interleaved</strong> arbitrarily on the <strong>same descriptor</strong>. ↔ Calls to these <strong>buffered functions</strong> <strong>shouldn’t be interleaved</strong> with calls to the <strong>unbuffered </strong><strong><code>rio_readn</code></strong><strong> function</strong>.</li></ul><ul id="bc895681-c808-4241-8596-bed022ab88b9" class="bulleted-list"><li style="list-style-type:circle"><strong>Example Code - Copying a text file from standard input to standard output</strong><pre id="de3c891f-799b-4475-a7f1-9e01041999b5" class="code"><code>#include &quot;csapp.h&quot;

int main(int argc, char **argv){
	int n;
	rio_t rio;
	char buf[MAXLINE];

	Rio_readinitb(&amp;rio, STDIN_FILENO);
	while((n = Rio_readlineb(&amp;rio, buf, MAXLINE)) != 0)
		Rio_writen(STDOUT_FILENO, buf, n);
}</code></pre></li></ul></li></ul></details></li></ul></div><h2 id="0a7bf4a9-707c-4d51-b9d1-4e2a94507c12" class=""><details open=""><summary><mark class="highlight-blue">10.6</mark> Reading File Metadata</summary></details></h2><div class="indented"><p id="a1c9291b-54b6-4e60-9839-fed9a711723f" class="">An <strong>application </strong>can retrieve information about a file (<strong>metadata</strong>) by calling the <code>stat</code> and <code>fstat</code>.</p><pre id="63efe93b-f247-4800-9ef5-13f3802e38fa" class="code"><code>#include &lt;unistd.h&gt;
#include &lt;sys/stat.h&gt;

int stat(const char *filename, struct stat *buf);
int fstat(int fd, struct stat *buf);</code></pre><ul id="ed357dfb-8849-4796-bd84-b62a14e1d8ca" class="bulleted-list"><li style="list-style-type:disc"><code>stat</code> takes a <strong>filename </strong>as input and fills the members of a <strong><code>stat</code></strong><strong> structure</strong>.<figure id="94b012d2-6d34-4502-b815-da7bc9b3aa95" class="image"><a href="/assets/images/CSAPP-10/Untitled%202.png"><img style="width:432px" src="/assets/images/CSAPP-10/Untitled%202.png"/></a></figure><ul id="b301c8b8-fe2f-4e73-967e-a2e89f00d407" class="bulleted-list"><li style="list-style-type:circle"><code>st_size</code> contains the <strong>file size</strong> in bytes.</li></ul><ul id="82623df9-b9b6-4541-8253-d5cd1bd11e8c" class="bulleted-list"><li style="list-style-type:circle"><code>st_mode</code> encodes both the <strong>file permission bits</strong> (<code>S_IRUSR</code>, <code>S_IWGRP</code>, …) and the <strong>file type</strong> (regular file, directory, socket, …).</li></ul><ul id="1d0304c5-a1a4-49b5-a549-9137ebdda857" class="bulleted-list"><li style="list-style-type:circle">can determine the <strong>file type</strong> from the <code>st_mode</code> using macros defined in <code>sys/stat</code>:<ul id="cbf4ec37-e8b0-43ac-96df-85207a1f363c" class="bulleted-list"><li style="list-style-type:square"><code>S_ISREG(m)</code> : Is this a <strong>regular </strong>file?</li></ul><ul id="6e2e7c4c-7cf0-4d18-9dbe-b96690929692" class="bulleted-list"><li style="list-style-type:square"><code>S_ISDIR(m)</code> : Is this a <strong>directory </strong>file?</li></ul><ul id="c7ff84e3-594a-4e14-807c-328466b31017" class="bulleted-list"><li style="list-style-type:square"><code>S_ISSOCK(m)</code> : Is this a network <strong>socket</strong>?</li></ul></li></ul><ul id="24c02893-3211-4784-83ad-3b5dc06d8a47" class="bulleted-list"><li style="list-style-type:circle">can check the <strong>file’s permission bit</strong> using the <code>st_mode</code> as <code>if (stat.st_mode &amp; S_IRUSR) readok = &quot;yes&quot;;</code>.</li></ul></li></ul><ul id="685bde4a-8b6a-4260-9fe0-4096aa816d54" class="bulleted-list"><li style="list-style-type:disc"><code>fstat</code> takes a filename as <strong>file descriptor</strong> instead of a file name.</li></ul></div><h2 id="ee82a8e1-3f06-4bbe-92eb-6173a5c42e4e" class=""><details open=""><summary><mark class="highlight-blue">10.7</mark> Reading Directory Contents</summary></details></h2><div class="indented"><p id="176daf19-b1bd-474a-8096-f1e0e8f1e324" class="">Applications can read the contents of a directory with the <code>readdir</code> family of functions.</p><pre id="d0350646-3897-4ef7-800e-7bcae0f1b818" class="code"><code>#include &lt;sys/types.h&gt;
#include &lt;dirent.h&gt;

DIR *opendir(const char *name);</code></pre><ul id="32697a6f-e9fb-4928-8391-f67893e7d0fe" class="bulleted-list"><li style="list-style-type:disc"><code>opendir</code> takes a <strong>pathname </strong>and returns a pointer to a <strong>directory stream</strong>. A <strong>stream </strong>is an abstraction for an <strong>ordered list of items</strong>.</li></ul><pre id="e738319e-8f11-48f0-9f3b-d860fefc0e75" class="code"><code>#include &lt;dirent.h&gt;

struct dirent *readdir(DIR *dirp);</code></pre><ul id="995a50a1-639d-4b32-92c5-a7ed03319820" class="bulleted-list"><li style="list-style-type:disc">Each call to <code>readdir</code> returns a pointer to the <strong>next directory entry</strong> in the stream <code>dirp</code>, or <strong>NULL </strong>if there are <strong>no more entries (end-of-stream)</strong>.</li></ul><ul id="07daae42-ac7c-40f5-ae8b-fdcd2a083c09" class="bulleted-list"><li style="list-style-type:disc">Each <strong>directory entry</strong> is a structure of the form<pre id="db1c7f77-bb39-4271-a9f0-af885c79313a" class="code"><code>struct dirent {
	ino_t d_ino; /* inode number */
	char d_name[256] /* Filename */
}</code></pre><ul id="e30763dc-e30b-4aea-97ea-b18a55f091e4" class="bulleted-list"><li style="list-style-type:circle"><code>d_name</code> is the <strong>filename</strong>.</li></ul><ul id="dc1fd9ae-bfb5-44c2-8a07-36a5fb1b9438" class="bulleted-list"><li style="list-style-type:circle"><code>d_ino</code> is the <strong>file location</strong>.</li></ul></li></ul><ul id="d3ad7627-c344-4092-bdd1-e0df05dede00" class="bulleted-list"><li style="list-style-type:disc">On <strong>error</strong>, <code>readdir</code> returns <strong>NULL </strong>and <strong>sets </strong><strong><code>errno</code></strong>. Checking if <code>readdir</code> has changed <code>errno</code> is the only way to distinguish an error from the end-of-stream condition.</li></ul><pre id="bf97bc0a-012f-40c4-a30c-a108aea88bb1" class="code"><code>#include &lt;dirent.h&gt;

int closedir(DIR *dirp);</code></pre><ul id="9327f469-8b87-4658-917f-1d1d2389ba5c" class="bulleted-list"><li style="list-style-type:disc"><code>closedir</code> closes the stream and frees up any of its resources.</li></ul></div><h2 id="f33af7c7-bdc8-43d4-aa21-66c111f9a9cb" class=""><details open=""><summary><mark class="highlight-blue">10.8</mark> Sharing Files</summary></details></h2><div class="indented"><ul id="aa1c24d4-b223-4f1b-b573-f67eb10bf30f" class="toggle"><li><details open=""><summary><strong>Descriptor table, file table, and v-node table</strong></summary><p id="f8693805-2e15-4e28-94df-afe422ea7ef9" class="">The <strong>kernel </strong>represents <strong>open files</strong> using 3 related data structures:</p><figure id="96df8ee9-c35d-4906-9dfc-ca2f483ad8db" class="image"><a href="/assets/images/CSAPP-10/Untitled%203.png"><img style="width:432px" src="/assets/images/CSAPP-10/Untitled%203.png"/></a></figure><ul id="06470f56-24c5-4471-bd43-b0ffe5634c13" class="bulleted-list"><li style="list-style-type:disc"><strong>Descriptor table</strong><ul id="4fedc559-c4d6-42cd-a94e-70d7c6c88ffd" class="bulleted-list"><li style="list-style-type:circle"><strong>Each process</strong> has its own descriptor table.</li></ul><ul id="370bd5f6-cada-4a53-8cc4-0181b37e5fff" class="bulleted-list"><li style="list-style-type:circle">Descriptor table’s entries are <strong>indexed </strong>by the <strong>process’s open file descriptors</strong>.</li></ul><ul id="8aae0198-c904-49da-ab56-932ba03e9b80" class="bulleted-list"><li style="list-style-type:circle">Each <strong>open descriptor entry </strong>points to an entry in the <strong>file table</strong>.</li></ul></li></ul><ul id="71f43842-4449-440a-bab9-6d0cddb4550c" class="bulleted-list"><li style="list-style-type:disc"><strong>File table</strong><ul id="c22186b6-a152-4d85-ae98-6ecae76ba09d" class="bulleted-list"><li style="list-style-type:circle">The <strong>set of open files</strong> is represented by a file table.</li></ul><ul id="1a550e4f-478a-4e3e-a18e-be197587644d" class="bulleted-list"><li style="list-style-type:circle">File table is <strong>shared by all processes</strong>.</li></ul><ul id="bfd71ceb-068a-4b43-beb9-2b16b38d0fd7" class="bulleted-list"><li style="list-style-type:circle">Each <strong>file table entry</strong> consists of:<ul id="7546333b-a18c-4e2e-a99f-018542fc63df" class="bulleted-list"><li style="list-style-type:square">the current <strong>file position</strong></li></ul><ul id="5ebaa45a-5794-472e-b954-aab312b49599" class="bulleted-list"><li style="list-style-type:square">a <strong>reference count</strong> - the number of descriptor entries that currently point to it</li></ul><ul id="42c8477a-93ac-473b-9d96-61d74a587326" class="bulleted-list"><li style="list-style-type:square">a pointer to an entry in the <strong>v-node table</strong></li></ul></li></ul><ul id="1618b3be-8280-4797-9051-a5cfa0fa0b07" class="bulleted-list"><li style="list-style-type:circle">The kernel won’t <strong>delete </strong>the file table entry until its <strong>reference count is zero</strong>.</li></ul></li></ul><ul id="dc774b0a-8848-4a85-84fa-f02d17d38700" class="bulleted-list"><li style="list-style-type:disc"><strong>v-node table</strong><ul id="7a1dd04d-9e4c-4082-b321-5fee8f942204" class="bulleted-list"><li style="list-style-type:circle">v-node table is <strong>shared by all processes</strong>.</li></ul><ul id="c6be1c8e-9e53-4640-a178-05e843baa8a5" class="bulleted-list"><li style="list-style-type:circle">Each entry contains most of the <strong>information in the </strong><strong><code>stat</code></strong><strong> structure</strong>.</li></ul></li></ul></details></li></ul><ul id="ea4e550b-ca29-4d80-af54-c0636844e9fa" class="toggle"><li><details open=""><summary><strong>File Sharing</strong></summary><p id="0d28f45a-5480-44e6-80ed-9737f97096af" class=""><strong>Multiple descriptors</strong> can <strong>reference the same file </strong>through <strong>different file table entries</strong>.</p><figure id="21b3c13b-31db-4929-9391-cdad07737a00" class="image"><a href="/assets/images/CSAPP-10/Untitled%204.png"><img style="width:384px" src="/assets/images/CSAPP-10/Untitled%204.png"/></a></figure><p id="62095841-8d25-4bc8-a83d-ca57141a4726" class="">This can happen if you <strong>call the </strong><strong><code>open</code></strong><strong> twice</strong> with the <strong>same filename</strong>.</p><p id="e852059d-236b-47ee-a2c9-e313ec3e0a69" class=""><strong>Each descriptor</strong> has its own <strong>distinct file position</strong>, so different reads on different descriptors can fetch data from different locations in the file.</p></details></li></ul><ul id="04604c20-79d2-432d-895e-c3dfa34c1c8e" class="toggle"><li><details open=""><summary><strong>The </strong><strong><code>fork</code></strong><strong> Revisited</strong></summary><figure id="469025ac-ac43-4861-9528-5322700b16f2" class="image"><a href="/assets/images/CSAPP-10/Untitled%205.png"><img style="width:384px" src="/assets/images/CSAPP-10/Untitled%205.png"/></a></figure><p id="2400563a-3670-4b7b-aca3-8c5c35b4a955" class="">When <code>fork</code> is called, the <strong>child </strong>gets its own <strong>duplicate copy</strong> of the <strong>parent’s descriptor table</strong>.</p><p id="58a6fb2c-90dc-461c-bf0c-6769c0ce1e28" class=""><strong>Parent and child</strong> share the <strong>same set of open file tables</strong> and thus share the <strong>same file position</strong>.</p><p id="06907396-16d6-4f04-aecb-28617e094713" class="">The <strong>parent and child</strong> must <strong>both close their descriptor</strong> before the kernel will delete the corresponding file table entry.</p></details></li></ul></div><h2 id="eb83f134-6a1b-4f9f-a53b-3242723728f1" class=""><details open=""><summary><mark class="highlight-blue">10.9</mark> I/O Redirection</summary></details></h2><div class="indented"><p id="faa62492-1abc-4b3d-8e91-b51a71652872" class="">Linux shells provide I/O redirection operators that allow users to associate standard input and output with disk files.</p><p id="c8c6726a-d4aa-4793-8d86-5954856959fa" class="">Typing <code>linux&gt; ls &gt; foo.txt</code> causes the shell to load and execute the <code>ls</code> program, with standard output redirected to disk file <code>foo.txt</code>.</p><p id="7a102a0b-ee22-424f-9d70-036c692cbf47" class="">I/O redirection uses the <code>dup2</code> function:</p><pre id="e84ba064-872b-4d34-825b-59b3f41ef2f8" class="code"><code>#include &lt;unistd.h&gt;

int dup2(int oldfd, int newfd);</code></pre><ul id="5859eae8-0d54-46a8-a61b-8090715ccdaa" class="bulleted-list"><li style="list-style-type:disc"><code>dup2</code> copies descriptor table entry <code>oldfd</code> to descriptor table entry <code>newfd</code>, overwriting the previous contents of descriptor table entry <code>newfd</code>.</li></ul><ul id="232b0ef7-09ef-4782-9b53-9b66cf757a32" class="bulleted-list"><li style="list-style-type:disc">If <code>newfd</code> was already open, then <code>dup2</code> closes <code>newfd</code> before it copies <code>oldfd</code>.</li></ul></div><h2 id="fb63a41b-6e48-49e8-8848-c57cdbb23a48" class=""><details open=""><summary><mark class="highlight-blue">10.10</mark> Standard I/O</summary></details></h2><div class="indented"><p id="996cd15a-b52a-41e5-a283-b750ff60d51e" class="">The C language defines a <strong>standard I/O library</strong>, that provides programmers with a <strong>higher-level alternative to Unix I/O</strong>. The library <code>libc</code> provides several functions:</p><ul id="5d55b906-ebf4-4c68-b4ba-3f5f0a4d76df" class="bulleted-list"><li style="list-style-type:disc"><code>fopen</code>, <code>fclose</code> - for opening and closing files</li></ul><ul id="2bd7b4cb-dec1-4c5f-acea-159d0c739432" class="bulleted-list"><li style="list-style-type:disc"><code>fread</code>, <code>fwrite</code> - reading and writing bytes</li></ul><ul id="a48dc62d-a822-400b-b092-107761ec2b9a" class="bulleted-list"><li style="list-style-type:disc"><code>fgets</code>, <code>fputs</code> - reading and writing strings</li></ul><ul id="c087322a-7551-469a-9275-b72d12db50ea" class="bulleted-list"><li style="list-style-type:disc"><code>scanf</code>, <code>printf</code> - sophisticated formatted I/O</li></ul><p id="2e4a7668-09eb-4360-9bf8-2d83aaf8615e" class="">The <strong>standard I/O library</strong> models an open file as a <strong>stream</strong>, which is a <strong>pointer to a structure of type </strong><strong><code>FILE</code></strong>.</p><p id="3ac9a804-e051-4a97-98bf-289d24320bf8" class="">Every <strong>ANSI C program</strong> begins with <strong>3 open streams</strong>, <code>stdin</code>, <code>stdout</code>, and <code>stderr</code>:</p><pre id="921d51e8-ad97-4b3d-9435-672fc74385c2" class="code"><code>#include &lt;stdio.h&gt;
extern FILE *stdin; /* Standard input (descriptor 0) */
extern FILE *stdout; /* Standard output (descriptor 1) */
extern FILE *stderr; /* Standard error (descriptor 2) */</code></pre><p id="06e63f76-d428-49bc-996c-406a33151ad8" class="">A stream of type <code>FILE</code> is an <strong>abstraction for a file descriptor </strong>and <strong>a stream buffer</strong>, which is for <strong>minimizing the number of expensive Linux I/O system calls</strong>.</p></div><h2 id="ab44ca8f-719d-4158-85fb-edba4bd9e7f3" class=""><details open=""><summary><mark class="highlight-blue">10.11</mark> Putting It Together: Which I/O Functions Should I Use?</summary></details></h2><div class="indented"><figure id="b2c9f6f5-e63c-4db9-95e3-f0bf4278cccb" class="image"><a href="/assets/images/CSAPP-10/Untitled%206.png"><img style="width:576px" src="/assets/images/CSAPP-10/Untitled%206.png"/></a></figure><ul id="8e59b56a-9055-42fe-95a0-0928139c90d1" class="bulleted-list"><li style="list-style-type:disc">The <strong>Unix I/O </strong>model is implemented in the <strong>OS kernel</strong>. - <code>open</code>, <code>close</code>, <code>lseek</code>, <code>read</code>, <code>write</code>, and <code>stat</code></li></ul><ul id="5b41d4f0-fb9a-4eae-b944-cf1415d29e39" class="bulleted-list"><li style="list-style-type:disc">The higher-level <strong><code>RIO</code></strong><strong> </strong>and <strong>standard I/O</strong> functions are implemented using the <strong>Unix I/O </strong>functions.</li></ul><ul id="da2704fa-83b2-4b6e-bbb9-ba04b7ae26d9" class="bulleted-list"><li style="list-style-type:disc">Which of these functions should you use in your programs? :<ol type="1" id="fcbe81fd-5823-463b-bbe1-623cf55c443b" class="numbered-list" start="1"><li>Use the <strong>standard I/O functions</strong> whenever possible.<p id="54e837b9-9873-4974-8fc1-0c577bf9c67e" class="">The standard I/O functions are the method of choice for I/O on disk and terminal devices.</p></li></ol><ol type="1" id="58b266b4-88d3-43ea-95ce-27150d9698ca" class="numbered-list" start="2"><li><strong>Don’t </strong>use <strong><code>scanf</code></strong><strong> </strong>or <strong><code>rio_readlineb</code></strong><strong> </strong>to read <strong>binary files</strong>.<p id="3a35bc77-e589-43a6-8edf-ce182cbb391f" class="">Functions like <code>scanf</code> and <code>rio_readlineb</code> are designed for <strong>reading text files</strong>. </p><p id="fe7f99d0-78c3-4996-8179-6880d65dc242" class="">Using these functions for reading binary files can lead to <strong>unpredictable errors</strong>. (<em>example : binary files can be littered with many </em><code><em>0xa</em></code><em> bytes that is irrelevant to </em><code><em>\n</em></code><em>.</em>)</p></li></ol><ol type="1" id="e0c88b2a-8534-47ff-9e27-ecb921aa9719" class="numbered-list" start="3"><li>Use the <code>RIO</code><strong> functions</strong> for I/O on <strong>network sockets</strong>.<p id="5c05bfd9-8f81-47cf-8310-d1e6372edf85" class=""><strong>Standard I/O </strong>poses some problems when used for input and output on <strong>networks</strong>.</p></li></ol></li></ul><ul id="3b92af61-01d2-4d55-b504-a7c7d1c15e5d" class="bulleted-list"><li style="list-style-type:disc"><strong>Standard I/O streams </strong>are <strong>full duplex</strong> - programs can perform input and output <strong>on the same stream</strong>. </li></ul><ul id="cb626b35-2d6d-4634-8fef-dfca785b34e5" class="bulleted-list"><li style="list-style-type:disc"><strong>Standard I/O</strong>’s streams have restrictions that interact badly with restrictions on <strong>sockets</strong>:<ul id="17755864-9b01-4dd9-9af4-bd4a6a1b5296" class="bulleted-list"><li style="list-style-type:circle"><strong>Input functions following output functions</strong><p id="7ef56c62-6269-4ad5-8594-591944619df3" class="">An <strong>input </strong>function can’t follow an <strong>output </strong>function without an <strong>intervening call to </strong><strong><code>fflush</code></strong><strong>, </strong><strong><code>fseek</code></strong><strong>, </strong><strong><code>fsetpos</code></strong><strong>, or </strong><strong><code>rewind</code></strong>.</p><p id="7baf9010-744c-4967-91b4-fa33e059b3be" class=""><code>fflush</code> empties the buffer, and the latter three use the Unix I/O <code>lseek</code> to reset the current file position.</p></li></ul><ul id="dfb21870-f4f0-4f82-b7a1-9b505f91a5c9" class="bulleted-list"><li style="list-style-type:circle"><strong>Output functions following input functions</strong><p id="2892b75f-b779-4017-82f6-0d8ce487b649" class="">An <strong>output </strong>function can’t follow an <strong>input </strong>function without an <strong>intervening call to </strong><strong><code>fseek</code></strong><strong>, </strong><strong><code>fsetpos</code></strong><strong>, or </strong><strong><code>rewind</code></strong>, unless the input function encounters an <strong>end-of-file</strong>.</p></li></ul><p id="0d500ffb-36c2-4ec5-8610-631beae1c989" class="">These restrictions can lead to a problem for <strong>network applications</strong> - it is <strong>illegal </strong>to use the <strong><code>lseek</code></strong><strong> on a socket. → Use </strong><strong><code>RIO</code></strong><strong> instead.</strong></p></li></ul></div><p id="eb0c987e-769a-4c41-9c68-a6e06ff8e135" class="">
</p></div></article></body></html>